/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Crayon Group Customer API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://apiv1.crayon.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ActivationLink
 */
export interface ActivationLink {
    /**
     * 
     * @type {string}
     * @memberof ActivationLink
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivationLink
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface ActivityLog
 */
export interface ActivityLog {
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    entity?: string;
    /**
     * 
     * @type {Array<ActivityLogItem>}
     * @memberof ActivityLog
     */
    items?: Array<ActivityLogItem>;
    /**
     * 
     * @type {number}
     * @memberof ActivityLog
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ActivityLogItem
 */
export interface ActivityLogItem {
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    entity?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    changedBy?: string;
    /**
     * 
     * @type {Date}
     * @memberof ActivityLogItem
     */
    changedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    changedColumn?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    changedFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    changedTo?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ActivityLogItem
     */
    customValues?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ActivityLogItem
     */
    changeType?: ActivityLogItem.ChangeTypeEnum;
}

/**
 * @export
 * @namespace ActivityLogItem
 */
export namespace ActivityLogItem {
    /**
     * @export
     * @enum {string}
     */
    export enum ChangeTypeEnum {
        Delete = <any> 'Delete',
        Insert = <any> 'Insert',
        Update = <any> 'Update'
    }
}

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    id?: number;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Address
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    completeAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    county?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    countryCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    primary?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    addressType?: Address.AddressTypeEnum;
}

/**
 * @export
 * @namespace Address
 */
export namespace Address {
    /**
     * @export
     * @enum {string}
     */
    export enum AddressTypeEnum {
        None = <any> 'None',
        Invoice = <any> 'Invoice',
        Delivery = <any> 'Delivery'
    }
}

/**
 * 
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     * 
     * @type {number}
     * @memberof AddressData
     */
    axAddressId?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    completeAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    zipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    county?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressData
     */
    countryCode?: string;
}

/**
 * 
 * @export
 * @interface AggregationItem
 */
export interface AggregationItem {
    /**
     * 
     * @type {string}
     * @memberof AggregationItem
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof AggregationItem
     */
    docCount?: number;
}

/**
 * 
 * @export
 * @interface Agreement
 */
export interface Agreement {
    /**
     * 
     * @type {number}
     * @memberof Agreement
     */
    id?: number;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Agreement
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    salesPriceCurrencyCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof Agreement
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Agreement
     */
    endDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Agreement
     */
    disabled?: boolean;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Agreement
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Agreement
     */
    program?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    customerNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    masterAgreement?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Agreement
     */
    hasTerms?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Agreement
     */
    agreementType?: Agreement.AgreementTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Agreement
     */
    parentAgreementId?: number;
    /**
     * 
     * @type {number}
     * @memberof Agreement
     */
    commitmentLevel?: number;
}

/**
 * @export
 * @namespace Agreement
 */
export namespace Agreement {
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypeEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}

/**
 * 
 * @export
 * @interface AgreementAccess
 */
export interface AgreementAccess {
    /**
     * 
     * @type {boolean}
     * @memberof AgreementAccess
     */
    hasAccess?: boolean;
    /**
     * 
     * @type {Agreement}
     * @memberof AgreementAccess
     */
    agreement?: Agreement;
}

/**
 * 
 * @export
 * @interface AgreementCollection
 */
export interface AgreementCollection {
    /**
     * 
     * @type {AgreementFilter}
     * @memberof AgreementCollection
     */
    filter?: AgreementFilter;
    /**
     * 
     * @type {Array<Agreement>}
     * @memberof AgreementCollection
     */
    items?: Array<Agreement>;
    /**
     * 
     * @type {number}
     * @memberof AgreementCollection
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface AgreementFilter
 */
export interface AgreementFilter {
    /**
     * 
     * @type {number}
     * @memberof AgreementFilter
     */
    organizationId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementFilter
     */
    organizationIds?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementFilter
     */
    pricelistIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AgreementFilter
     */
    status?: AgreementFilter.StatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementFilter
     */
    agreementTypes?: Array<AgreementFilter.AgreementTypesEnum>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementFilter
     */
    publisherIds?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementFilter
     */
    programIds?: Array<number>;
    /**
     * 
     * @type {Date}
     * @memberof AgreementFilter
     */
    searchDate?: Date;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementFilter
     */
    agreementIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AgreementFilter
     */
    salesPriceCurrency?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AgreementFilter
     */
    termRequired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AgreementFilter
     */
    publisherId?: number;
    /**
     * 
     * @type {Date}
     * @memberof AgreementFilter
     */
    endDateFrom?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AgreementFilter
     */
    endDateTo?: Date;
    /**
     * 
     * @type {number}
     * @memberof AgreementFilter
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementFilter
     */
    pageSize?: number;
    /**
     * 
     * @type {string}
     * @memberof AgreementFilter
     */
    search?: string;
}

/**
 * @export
 * @namespace AgreementFilter
 */
export namespace AgreementFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Inactive = <any> 'Inactive',
        ActiveInactive = <any> 'ActiveInactive'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypesEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}

/**
 * 
 * @export
 * @interface AgreementIdentityReference
 */
export interface AgreementIdentityReference {
    /**
     * 
     * @type {number}
     * @memberof AgreementIdentityReference
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AgreementIdentityReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AgreementIdentityReference
     */
    agreementNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof AgreementIdentityReference
     */
    commitmentLevel?: number;
}

/**
 * 
 * @export
 * @interface AgreementIdentityReferenceDto
 */
export interface AgreementIdentityReferenceDto {
    /**
     * 
     * @type {string}
     * @memberof AgreementIdentityReferenceDto
     */
    agreementNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof AgreementIdentityReferenceDto
     */
    commitmentLevel?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementIdentityReferenceDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AgreementIdentityReferenceDto
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface AgreementProduct
 */
export interface AgreementProduct {
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    uniqueId?: string;
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    productType?: AgreementProduct.ProductTypeEnum;
    /**
     * 
     * @type {ProductVariant}
     * @memberof AgreementProduct
     */
    productVariant?: ProductVariant;
    /**
     * 
     * @type {ObjectReference}
     * @memberof AgreementProduct
     */
    agreement?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof AgreementProduct
     */
    priceId?: number;
    /**
     * 
     * @type {Price}
     * @memberof AgreementProduct
     */
    recommendedRetailPrice?: Price;
    /**
     * 
     * @type {Price}
     * @memberof AgreementProduct
     */
    salesPrice?: Price;
    /**
     * 
     * @type {Price}
     * @memberof AgreementProduct
     */
    alternativeSalesPrice?: Price;
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    priceListName?: string;
    /**
     * 
     * @type {number}
     * @memberof AgreementProduct
     */
    monthMultiplier?: number;
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    priceCalculationType?: AgreementProduct.PriceCalculationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AgreementProduct
     */
    agreementType?: AgreementProduct.AgreementTypeEnum;
    /**
     * 
     * @type {ProductInformation}
     * @memberof AgreementProduct
     */
    productInformation?: ProductInformation;
    /**
     * 
     * @type {number}
     * @memberof AgreementProduct
     */
    minimumQuantity?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementProduct
     */
    maximumQuantity?: number;
}

/**
 * @export
 * @namespace AgreementProduct
 */
export namespace AgreementProduct {
    /**
     * @export
     * @enum {string}
     */
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Bundle = <any> 'Bundle',
        Service = <any> 'Service',
        Internal = <any> 'Internal'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PriceCalculationTypeEnum {
        None = <any> 'None',
        Default = <any> 'Default',
        SelectPlus = <any> 'SelectPlus',
        AdobeVip = <any> 'AdobeVip',
        Mpsa = <any> 'Mpsa'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypeEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}

/**
 * 
 * @export
 * @interface AgreementProductCollection
 */
export interface AgreementProductCollection {
    /**
     * 
     * @type {Array<PublisherAggregationItem>}
     * @memberof AgreementProductCollection
     */
    publishers?: Array<PublisherAggregationItem>;
    /**
     * 
     * @type {AgreementProductFilter}
     * @memberof AgreementProductCollection
     */
    filter?: AgreementProductFilter;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    pools?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    operatingSystems?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    offerings?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    levels?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    languages?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    licenseAgreementTypes?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    licenseTypes?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    productFamilies?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    programs?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    productTypes?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    purchasePeriods?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    purchaseUnits?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    versions?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    regions?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof AgreementProductCollection
     */
    productCategories?: Array<AggregationItem>;
    /**
     * 
     * @type {Array<ObjectReference>}
     * @memberof AgreementProductCollection
     */
    agreements?: Array<ObjectReference>;
    /**
     * 
     * @type {Array<AgreementProduct>}
     * @memberof AgreementProductCollection
     */
    items?: Array<AgreementProduct>;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductCollection
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface AgreementProductFilter
 */
export interface AgreementProductFilter {
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductFilter
     */
    agreementTypeIds?: Array<AgreementProductFilter.AgreementTypeIdsEnum>;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    pageSize?: number;
    /**
     * 
     * @type {string}
     * @memberof AgreementProductFilter
     */
    search?: string;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    priceListId?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    organizationId?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    customerTenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof AgreementProductFilter
     */
    agreementId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AgreementProductFilter
     */
    isTrial?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementProductFilter
     */
    agreementIds?: Array<number>;
    /**
     * 
     * @type {Date}
     * @memberof AgreementProductFilter
     */
    searchDate?: Date;
    /**
     * 
     * @type {AgreementProductsSubFilter}
     * @memberof AgreementProductFilter
     */
    include?: AgreementProductsSubFilter;
    /**
     * 
     * @type {AgreementProductsSubFilter}
     * @memberof AgreementProductFilter
     */
    exclude?: AgreementProductsSubFilter;
    /**
     * 
     * @type {string}
     * @memberof AgreementProductFilter
     */
    sortKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AgreementProductFilter
     */
    includeProductInformation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AgreementProductFilter
     */
    sortOrder?: AgreementProductFilter.SortOrderEnum;
}

/**
 * @export
 * @namespace AgreementProductFilter
 */
export namespace AgreementProductFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypeIdsEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Ascending = <any> 'Ascending',
        Descending = <any> 'Descending'
    }
}

/**
 * 
 * @export
 * @interface AgreementProductsSubFilter
 */
export interface AgreementProductsSubFilter {
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    partNumbers?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AgreementProductsSubFilter
     */
    publisherIds?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    publisherNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    poolNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    operatingSystemNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    levelNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    languageNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    licenseAgreementTypeNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    licenseTypeNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    productFamilyNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    productTypeNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    programNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    offeringNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    purchasePeriodNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    purchaseUnitNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    versionNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    regionNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgreementProductsSubFilter
     */
    productCategoryNames?: Array<string>;
}

/**
 * 
 * @export
 * @interface AgreementReport
 */
export interface AgreementReport {
    /**
     * 
     * @type {ObjectReferenceDto}
     * @memberof AgreementReport
     */
    productContainer?: ObjectReferenceDto;
    /**
     * 
     * @type {AgreementIdentityReferenceDto}
     * @memberof AgreementReport
     */
    agreement?: AgreementIdentityReferenceDto;
    /**
     * 
     * @type {string}
     * @memberof AgreementReport
     */
    status?: AgreementReport.StatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AgreementReport
     */
    hasValidAgreementTerm?: boolean;
}

/**
 * @export
 * @namespace AgreementReport
 */
export namespace AgreementReport {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        NotReported = <any> 'NotReported',
        ZeroUsageReported = <any> 'ZeroUsageReported',
        UsageReported = <any> 'UsageReported',
        UsageAndZeroUsageReported = <any> 'UsageAndZeroUsageReported'
    }
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAddress
 */
export interface ApiCollectionOfAddress {
    /**
     * 
     * @type {Array<Address>}
     * @memberof ApiCollectionOfAddress
     */
    items?: Array<Address>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAddress
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAgreementReport
 */
export interface ApiCollectionOfAgreementReport {
    /**
     * 
     * @type {Array<AgreementReport>}
     * @memberof ApiCollectionOfAgreementReport
     */
    items?: Array<AgreementReport>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAgreementReport
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAsset
 */
export interface ApiCollectionOfAsset {
    /**
     * 
     * @type {Array<Asset>}
     * @memberof ApiCollectionOfAsset
     */
    items?: Array<Asset>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAsset
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAssetOrder
 */
export interface ApiCollectionOfAssetOrder {
    /**
     * 
     * @type {Array<AssetOrder>}
     * @memberof ApiCollectionOfAssetOrder
     */
    items?: Array<AssetOrder>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAssetOrder
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAwsAccount
 */
export interface ApiCollectionOfAwsAccount {
    /**
     * 
     * @type {Array<AwsAccount>}
     * @memberof ApiCollectionOfAwsAccount
     */
    items?: Array<AwsAccount>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAwsAccount
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfAzureSubscription
 */
export interface ApiCollectionOfAzureSubscription {
    /**
     * 
     * @type {Array<AzureSubscription>}
     * @memberof ApiCollectionOfAzureSubscription
     */
    items?: Array<AzureSubscription>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfAzureSubscription
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfBillingCycle
 */
export interface ApiCollectionOfBillingCycle {
    /**
     * 
     * @type {Array<BillingCycle>}
     * @memberof ApiCollectionOfBillingCycle
     */
    items?: Array<BillingCycle>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfBillingCycle
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfBillingStatement
 */
export interface ApiCollectionOfBillingStatement {
    /**
     * 
     * @type {Array<BillingStatement>}
     * @memberof ApiCollectionOfBillingStatement
     */
    items?: Array<BillingStatement>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfBillingStatement
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfBlogItem
 */
export interface ApiCollectionOfBlogItem {
    /**
     * 
     * @type {Array<BlogItem>}
     * @memberof ApiCollectionOfBlogItem
     */
    items?: Array<BlogItem>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfBlogItem
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfBoolean
 */
export interface ApiCollectionOfBoolean {
    /**
     * 
     * @type {Array<boolean>}
     * @memberof ApiCollectionOfBoolean
     */
    items?: Array<boolean>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfBoolean
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfCategoryUsageCost
 */
export interface ApiCollectionOfCategoryUsageCost {
    /**
     * 
     * @type {Array<CategoryUsageCost>}
     * @memberof ApiCollectionOfCategoryUsageCost
     */
    items?: Array<CategoryUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfCategoryUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfClient
 */
export interface ApiCollectionOfClient {
    /**
     * 
     * @type {Array<Client>}
     * @memberof ApiCollectionOfClient
     */
    items?: Array<Client>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfClient
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfConsumer
 */
export interface ApiCollectionOfConsumer {
    /**
     * 
     * @type {Array<Consumer>}
     * @memberof ApiCollectionOfConsumer
     */
    items?: Array<Consumer>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfConsumer
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfCrayonAccount
 */
export interface ApiCollectionOfCrayonAccount {
    /**
     * 
     * @type {Array<CrayonAccount>}
     * @memberof ApiCollectionOfCrayonAccount
     */
    items?: Array<CrayonAccount>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfCrayonAccount
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfCustomerTenant
 */
export interface ApiCollectionOfCustomerTenant {
    /**
     * 
     * @type {Array<CustomerTenant>}
     * @memberof ApiCollectionOfCustomerTenant
     */
    items?: Array<CustomerTenant>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfCustomerTenant
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfGroupedBillingStatement
 */
export interface ApiCollectionOfGroupedBillingStatement {
    /**
     * 
     * @type {Array<GroupedBillingStatement>}
     * @memberof ApiCollectionOfGroupedBillingStatement
     */
    items?: Array<GroupedBillingStatement>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfGroupedBillingStatement
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfGrouping
 */
export interface ApiCollectionOfGrouping {
    /**
     * 
     * @type {Array<Grouping>}
     * @memberof ApiCollectionOfGrouping
     */
    items?: Array<Grouping>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfGrouping
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfInvoiceProfile
 */
export interface ApiCollectionOfInvoiceProfile {
    /**
     * 
     * @type {Array<InvoiceProfile>}
     * @memberof ApiCollectionOfInvoiceProfile
     */
    items?: Array<InvoiceProfile>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfInvoiceProfile
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfManagementLink
 */
export interface ApiCollectionOfManagementLink {
    /**
     * 
     * @type {Array<ManagementLink>}
     * @memberof ApiCollectionOfManagementLink
     */
    items?: Array<ManagementLink>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfManagementLink
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfManagementLinkGrouped
 */
export interface ApiCollectionOfManagementLinkGrouped {
    /**
     * 
     * @type {Array<ManagementLinkGrouped>}
     * @memberof ApiCollectionOfManagementLinkGrouped
     */
    items?: Array<ManagementLinkGrouped>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfManagementLinkGrouped
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfObjectReference
 */
export interface ApiCollectionOfObjectReference {
    /**
     * 
     * @type {Array<ObjectReference>}
     * @memberof ApiCollectionOfObjectReference
     */
    items?: Array<ObjectReference>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfObjectReference
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfOrganization
 */
export interface ApiCollectionOfOrganization {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof ApiCollectionOfOrganization
     */
    items?: Array<Organization>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfOrganization
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfOrganizationAccess
 */
export interface ApiCollectionOfOrganizationAccess {
    /**
     * 
     * @type {Array<OrganizationAccess>}
     * @memberof ApiCollectionOfOrganizationAccess
     */
    items?: Array<OrganizationAccess>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfOrganizationAccess
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfOrganizationUsageCost
 */
export interface ApiCollectionOfOrganizationUsageCost {
    /**
     * 
     * @type {Array<OrganizationUsageCost>}
     * @memberof ApiCollectionOfOrganizationUsageCost
     */
    items?: Array<OrganizationUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfOrganizationUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfProductContainer
 */
export interface ApiCollectionOfProductContainer {
    /**
     * 
     * @type {Array<ProductContainer>}
     * @memberof ApiCollectionOfProductContainer
     */
    items?: Array<ProductContainer>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfProductContainer
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfProgram
 */
export interface ApiCollectionOfProgram {
    /**
     * 
     * @type {Array<Program>}
     * @memberof ApiCollectionOfProgram
     */
    items?: Array<Program>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfProgram
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfPublisher
 */
export interface ApiCollectionOfPublisher {
    /**
     * 
     * @type {Array<Publisher>}
     * @memberof ApiCollectionOfPublisher
     */
    items?: Array<Publisher>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfPublisher
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfRegion
 */
export interface ApiCollectionOfRegion {
    /**
     * 
     * @type {Array<Region>}
     * @memberof ApiCollectionOfRegion
     */
    items?: Array<Region>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfRegion
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfResourceGroupUsageCost
 */
export interface ApiCollectionOfResourceGroupUsageCost {
    /**
     * 
     * @type {Array<ResourceGroupUsageCost>}
     * @memberof ApiCollectionOfResourceGroupUsageCost
     */
    items?: Array<ResourceGroupUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfResourceGroupUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfServiceAccountAgreement
 */
export interface ApiCollectionOfServiceAccountAgreement {
    /**
     * 
     * @type {Array<ServiceAccountAgreement>}
     * @memberof ApiCollectionOfServiceAccountAgreement
     */
    items?: Array<ServiceAccountAgreement>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfServiceAccountAgreement
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfSubcategoryUsageCost
 */
export interface ApiCollectionOfSubcategoryUsageCost {
    /**
     * 
     * @type {Array<SubcategoryUsageCost>}
     * @memberof ApiCollectionOfSubcategoryUsageCost
     */
    items?: Array<SubcategoryUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfSubcategoryUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfSubscription
 */
export interface ApiCollectionOfSubscription {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof ApiCollectionOfSubscription
     */
    items?: Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfSubscription
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfSubscriptionConversion
 */
export interface ApiCollectionOfSubscriptionConversion {
    /**
     * 
     * @type {Array<SubscriptionConversion>}
     * @memberof ApiCollectionOfSubscriptionConversion
     */
    items?: Array<SubscriptionConversion>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfSubscriptionConversion
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfSubscriptionResourceGroupUsageCost
 */
export interface ApiCollectionOfSubscriptionResourceGroupUsageCost {
    /**
     * 
     * @type {Array<SubscriptionResourceGroupUsageCost>}
     * @memberof ApiCollectionOfSubscriptionResourceGroupUsageCost
     */
    items?: Array<SubscriptionResourceGroupUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfSubscriptionResourceGroupUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfSubscriptionUsageCost
 */
export interface ApiCollectionOfSubscriptionUsageCost {
    /**
     * 
     * @type {Array<SubscriptionUsageCost>}
     * @memberof ApiCollectionOfSubscriptionUsageCost
     */
    items?: Array<SubscriptionUsageCost>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfSubscriptionUsageCost
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface ApiCollectionOfUser
 */
export interface ApiCollectionOfUser {
    /**
     * 
     * @type {Array<User>}
     * @memberof ApiCollectionOfUser
     */
    items?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof ApiCollectionOfUser
     */
    totalHits?: number;
}

/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    status?: Asset.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    externalOrderId?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    productId?: number;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    productVariantId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Asset
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Asset
     */
    expirationDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    scope?: Asset.ScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    assetType?: Asset.AssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    billingCycle?: Asset.BillingCycleEnum;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    publisherId?: number;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    programId?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    reservationId?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    reservationUsedInSubscriptionId?: number;
    /**
     * 
     * @type {SubscriptionLite}
     * @memberof Asset
     */
    reservationUsedInSubscription?: SubscriptionLite;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    purchaseCurrency?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    purchasePrice?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    salesCurrency?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    salesPrice?: number;
    /**
     * 
     * @type {Date}
     * @memberof Asset
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Asset
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    changedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    resellerPriceType?: Asset.ResellerPriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    resellerPriceTypeValue?: number;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    reservedInstanceArtifactResourceId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Asset
     */
    purchaseDate?: Date;
    /**
     * 
     * @type {ProductVariant}
     * @memberof Asset
     */
    productVariant?: ProductVariant;
}

/**
 * @export
 * @namespace Asset
 */
export namespace Asset {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Fulfilling = <any> 'Fulfilling',
        Succeeded = <any> 'Succeeded',
        Cancelled = <any> 'Cancelled',
        All = <any> 'All'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ScopeEnum {
        Shared = <any> 'Shared',
        Single = <any> 'Single'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AssetTypeEnum {
        Reservation = <any> 'Reservation',
        Software = <any> 'Software',
        Subscription = <any> 'Subscription'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResellerPriceTypeEnum {
        None = <any> 'None',
        Margin = <any> 'Margin',
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}

/**
 * 
 * @export
 * @interface AssetOrder
 */
export interface AssetOrder {
    /**
     * 
     * @type {string}
     * @memberof AssetOrder
     */
    externalOrderId?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetOrder
     */
    countryCode?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetOrder
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {Array<AssetOrderError>}
     * @memberof AssetOrder
     */
    errors?: Array<AssetOrderError>;
    /**
     * 
     * @type {Array<AssetOrderLine>}
     * @memberof AssetOrder
     */
    orderLines?: Array<AssetOrderLine>;
}

/**
 * 
 * @export
 * @interface AssetOrderError
 */
export interface AssetOrderError {
    /**
     * 
     * @type {string}
     * @memberof AssetOrderError
     */
    orderGroupId?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetOrderError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderError
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface AssetOrderLine
 */
export interface AssetOrderLine {
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    productId?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetOrderLine
     */
    subscriptionId?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    armRegionName?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    skuId?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetOrderLine
     */
    productVariantId?: number;
    /**
     * 
     * @type {number}
     * @memberof AssetOrderLine
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    billingCycle?: AssetOrderLine.BillingCycleEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AssetOrderLine
     */
    provisioningContext?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    type?: AssetOrderLine.TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AssetOrderLine
     */
    requiresInventoryCheck?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    catalogItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    termDuration?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    scope?: AssetOrderLine.ScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLine
     */
    resellerPriceType?: AssetOrderLine.ResellerPriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AssetOrderLine
     */
    resellerPriceTypeValue?: number;
    /**
     * 
     * @type {Array<AssetOrderLineError>}
     * @memberof AssetOrderLine
     */
    errors?: Array<AssetOrderLineError>;
}

/**
 * @export
 * @namespace AssetOrderLine
 */
export namespace AssetOrderLine {
    /**
     * @export
     * @enum {string}
     */
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Reservation = <any> 'Reservation',
        Software = <any> 'Software',
        Subscription = <any> 'Subscription'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ScopeEnum {
        Shared = <any> 'Shared',
        Single = <any> 'Single'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResellerPriceTypeEnum {
        None = <any> 'None',
        Margin = <any> 'Margin',
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}

/**
 * 
 * @export
 * @interface AssetOrderLineError
 */
export interface AssetOrderLineError {
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLineError
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetOrderLineError
     */
    description?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AssetOrderLineError
     */
    properties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface AwsAccount
 */
export interface AwsAccount {
    /**
     * 
     * @type {number}
     * @memberof AwsAccount
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    email?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof AwsAccount
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    externalPublisherCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    customerTenantType?: AwsAccount.CustomerTenantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AwsAccount
     */
    entityStatus?: AwsAccount.EntityStatusEnum;
    /**
     * 
     * @type {Organization}
     * @memberof AwsAccount
     */
    organization?: Organization;
    /**
     * 
     * @type {ObjectReference}
     * @memberof AwsAccount
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof AwsAccount
     */
    isActivated?: boolean;
    /**
     * 
     * @type {SubscriptionTags}
     * @memberof AwsAccount
     */
    tags?: SubscriptionTags;
}

/**
 * @export
 * @namespace AwsAccount
 */
export namespace AwsAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
}

/**
 * 
 * @export
 * @interface AzurePlan
 */
export interface AzurePlan {
    /**
     * 
     * @type {number}
     * @memberof AzurePlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AzurePlan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AzurePlan
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof AzurePlan
     */
    status?: AzurePlan.StatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AzurePlan
     */
    registeredForReservedInstance?: boolean;
    /**
     * 
     * @type {ObjectReference}
     * @memberof AzurePlan
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {CustomerTenantReference}
     * @memberof AzurePlan
     */
    customerTenant?: CustomerTenantReference;
}

/**
 * @export
 * @namespace AzurePlan
 */
export namespace AzurePlan {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
}

/**
 * 
 * @export
 * @interface AzureSubscription
 */
export interface AzureSubscription {
    /**
     * 
     * @type {number}
     * @memberof AzureSubscription
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AzureSubscription
     */
    azurePlanId?: number;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscription
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscription
     */
    friendlyName?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscription
     */
    status?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof AzureSubscription
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {AzureSubscriptionTags}
     * @memberof AzureSubscription
     */
    tags?: AzureSubscriptionTags;
}

/**
 * 
 * @export
 * @interface AzureSubscriptionTags
 */
export interface AzureSubscriptionTags {
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionTags
     */
    costCenter?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionTags
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionTags
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionTags
     */
    custom?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionTags
     */
    owner?: string;
}

/**
 * 
 * @export
 * @interface BillingCycle
 */
export interface BillingCycle {
    /**
     * 
     * @type {number}
     * @memberof BillingCycle
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingCycle
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface BillingStatement
 */
export interface BillingStatement {
    /**
     * 
     * @type {number}
     * @memberof BillingStatement
     */
    id?: number;
    /**
     * 
     * @type {Price}
     * @memberof BillingStatement
     */
    totalSalesPrice?: Price;
    /**
     * 
     * @type {ObjectReference}
     * @memberof BillingStatement
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof BillingStatement
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {Date}
     * @memberof BillingStatement
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BillingStatement
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BillingStatement
     */
    provisionType?: BillingStatement.ProvisionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BillingStatement
     */
    orderId?: string;
}

/**
 * @export
 * @namespace BillingStatement
 */
export namespace BillingStatement {
    /**
     * @export
     * @enum {string}
     */
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
}

/**
 * 
 * @export
 * @interface BlogItem
 */
export interface BlogItem {
    /**
     * 
     * @type {string}
     * @memberof BlogItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogItem
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogItem
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogItem
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof BlogItem
     */
    link?: string;
    /**
     * 
     * @type {Date}
     * @memberof BlogItem
     */
    publicationDate?: Date;
}

/**
 * 
 * @export
 * @interface CategoryUsageCost
 */
export interface CategoryUsageCost {
    /**
     * 
     * @type {string}
     * @memberof CategoryUsageCost
     */
    subcategory?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface CategoryUsageCostRequest
 */
export interface CategoryUsageCostRequest {
    /**
     * 
     * @type {number}
     * @memberof CategoryUsageCostRequest
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryUsageCostRequest
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUsageCostRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryUsageCostRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof CategoryUsageCostRequest
     */
    from?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CategoryUsageCostRequest
     */
    to?: Date;
}

/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    clientName?: string;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    clientUri?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Client
     */
    enabled?: boolean;
    /**
     * 
     * @type {Array<Secret>}
     * @memberof Client
     */
    clientSecrets?: Array<Secret>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Client
     */
    redirectUris?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof Client
     */
    timeStamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    flow?: Client.FlowEnum;
}

/**
 * @export
 * @namespace Client
 */
export namespace Client {
    /**
     * @export
     * @enum {string}
     */
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        ResourceOwner = <any> 'ResourceOwner',
        Other = <any> 'Other'
    }
}

/**
 * 
 * @export
 * @interface Consumer
 */
export interface Consumer {
    /**
     * 
     * @type {number}
     * @memberof Consumer
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Consumer
     */
    name?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Consumer
     */
    organization?: ObjectReference;
}

/**
 * 
 * @export
 * @interface CrayonAccount
 */
export interface CrayonAccount {
    /**
     * 
     * @type {number}
     * @memberof CrayonAccount
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    email?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CrayonAccount
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    externalPublisherCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    customerTenantType?: CrayonAccount.CustomerTenantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CrayonAccount
     */
    entityStatus?: CrayonAccount.EntityStatusEnum;
    /**
     * 
     * @type {Organization}
     * @memberof CrayonAccount
     */
    organization?: Organization;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CrayonAccount
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof CrayonAccount
     */
    isActivated?: boolean;
    /**
     * 
     * @type {CustomerTenantContact}
     * @memberof CrayonAccount
     */
    contact?: CustomerTenantContact;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CrayonAccount
     */
    program?: ObjectReference;
    /**
     * 
     * @type {number}
     * @memberof CrayonAccount
     */
    resellerMarkup?: number;
}

/**
 * @export
 * @namespace CrayonAccount
 */
export namespace CrayonAccount {
    /**
     * @export
     * @enum {string}
     */
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
}

/**
 * 
 * @export
 * @interface CreateAzureSubscriptionRequest
 */
export interface CreateAzureSubscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAzureSubscriptionRequest
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CustomerTenant
 */
export interface CustomerTenant {
    /**
     * 
     * @type {number}
     * @memberof CustomerTenant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    name?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CustomerTenant
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CustomerTenant
     */
    program?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    publisherCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    externalPublisherCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    domainPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    customerTenantType?: CustomerTenant.CustomerTenantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    entityStatus?: CustomerTenant.EntityStatusEnum;
    /**
     * 
     * @type {Organization}
     * @memberof CustomerTenant
     */
    organization?: Organization;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CustomerTenant
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof CustomerTenant
     */
    consumer?: ObjectReference;
    /**
     * 
     * @type {number}
     * @memberof CustomerTenant
     */
    resellerMarkup?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenant
     */
    defaultSubscriptionPriceType?: CustomerTenant.DefaultSubscriptionPriceTypeEnum;
    /**
     * 
     * @type {CustomerTenantAgreement}
     * @memberof CustomerTenant
     */
    agreement?: CustomerTenantAgreement;
}

/**
 * @export
 * @namespace CustomerTenant
 */
export namespace CustomerTenant {
    /**
     * @export
     * @enum {string}
     */
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DefaultSubscriptionPriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}

/**
 * 
 * @export
 * @interface CustomerTenantAddress
 */
export interface CustomerTenantAddress {
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    addressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    addressLine3?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAddress
     */
    countryName?: string;
}

/**
 * 
 * @export
 * @interface CustomerTenantAgreement
 */
export interface CustomerTenantAgreement {
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAgreement
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAgreement
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAgreement
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAgreement
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerTenantAgreement
     */
    sameAsPrimaryContact?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof CustomerTenantAgreement
     */
    dateAgreed?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerTenantAgreement
     */
    accepted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantAgreement
     */
    agreementType?: CustomerTenantAgreement.AgreementTypeEnum;
}

/**
 * @export
 * @namespace CustomerTenantAgreement
 */
export namespace CustomerTenantAgreement {
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypeEnum {
        MicrosoftCloudAgreement = <any> 'MicrosoftCloudAgreement',
        MicrosoftCustomerAgreement = <any> 'MicrosoftCustomerAgreement'
    }
}

/**
 * 
 * @export
 * @interface CustomerTenantContact
 */
export interface CustomerTenantContact {
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantContact
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantContact
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantContact
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantContact
     */
    phoneNumber?: string;
}

/**
 * 
 * @export
 * @interface CustomerTenantDetailed
 */
export interface CustomerTenantDetailed {
    /**
     * 
     * @type {CustomerTenant}
     * @memberof CustomerTenantDetailed
     */
    tenant?: CustomerTenant;
    /**
     * 
     * @type {CustomerTenantUser}
     * @memberof CustomerTenantDetailed
     */
    user?: CustomerTenantUser;
    /**
     * 
     * @type {CustomerTenantProfile}
     * @memberof CustomerTenantDetailed
     */
    profile?: CustomerTenantProfile;
}

/**
 * 
 * @export
 * @interface CustomerTenantProfile
 */
export interface CustomerTenantProfile {
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantProfile
     */
    cultureCode?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantProfile
     */
    languageCode?: string;
    /**
     * 
     * @type {CustomerTenantContact}
     * @memberof CustomerTenantProfile
     */
    contact?: CustomerTenantContact;
    /**
     * 
     * @type {CustomerTenantAddress}
     * @memberof CustomerTenantProfile
     */
    address?: CustomerTenantAddress;
    /**
     * 
     * @type {CustomerTenantAgreement}
     * @memberof CustomerTenantProfile
     */
    agreement?: CustomerTenantAgreement;
}

/**
 * 
 * @export
 * @interface CustomerTenantReference
 */
export interface CustomerTenantReference {
    /**
     * 
     * @type {number}
     * @memberof CustomerTenantReference
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface CustomerTenantUser
 */
export interface CustomerTenantUser {
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantUser
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerTenantUser
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface FacebookOrder
 */
export interface FacebookOrder {
    /**
     * 
     * @type {Array<FacebookOrderLine>}
     * @memberof FacebookOrder
     */
    lines?: Array<FacebookOrderLine>;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    contactName?: string;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    contactEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    consumerContactName?: string;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    consumerFullLegalName?: string;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    consumerContactEmail?: string;
    /**
     * 
     * @type {number}
     * @memberof FacebookOrder
     */
    organizationId?: number;
    /**
     * 
     * @type {number}
     * @memberof FacebookOrder
     */
    invoiceProfileId?: number;
    /**
     * 
     * @type {Date}
     * @memberof FacebookOrder
     */
    subscriptionStartDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrder
     */
    consumerSignupEmail?: string;
}

/**
 * 
 * @export
 * @interface FacebookOrderLine
 */
export interface FacebookOrderLine {
    /**
     * 
     * @type {number}
     * @memberof FacebookOrderLine
     */
    publisherId?: number;
    /**
     * 
     * @type {number}
     * @memberof FacebookOrderLine
     */
    agreementId?: number;
    /**
     * 
     * @type {number}
     * @memberof FacebookOrderLine
     */
    productVariantId?: number;
    /**
     * 
     * @type {string}
     * @memberof FacebookOrderLine
     */
    sku?: string;
    /**
     * 
     * @type {number}
     * @memberof FacebookOrderLine
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface GoogleOrder
 */
export interface GoogleOrder {
    /**
     * 
     * @type {Array<GoogleOrderLine>}
     * @memberof GoogleOrder
     */
    lines?: Array<GoogleOrderLine>;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    contactName?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    contactEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerContactName?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerFullLegalName?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerContactEmail?: string;
    /**
     * 
     * @type {number}
     * @memberof GoogleOrder
     */
    organizationId?: number;
    /**
     * 
     * @type {number}
     * @memberof GoogleOrder
     */
    invoiceProfileId?: number;
    /**
     * 
     * @type {Date}
     * @memberof GoogleOrder
     */
    subscriptionStartDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    domainName?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerStreetAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerCity?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerState?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerZipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    consumerPhoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    primaryAdminName?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrder
     */
    primaryAdminUserName?: string;
}

/**
 * 
 * @export
 * @interface GoogleOrderLine
 */
export interface GoogleOrderLine {
    /**
     * 
     * @type {number}
     * @memberof GoogleOrderLine
     */
    publisherId?: number;
    /**
     * 
     * @type {number}
     * @memberof GoogleOrderLine
     */
    agreementId?: number;
    /**
     * 
     * @type {number}
     * @memberof GoogleOrderLine
     */
    productVariantId?: number;
    /**
     * 
     * @type {string}
     * @memberof GoogleOrderLine
     */
    sku?: string;
    /**
     * 
     * @type {number}
     * @memberof GoogleOrderLine
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface GroupedBillingStatement
 */
export interface GroupedBillingStatement {
    /**
     * 
     * @type {number}
     * @memberof GroupedBillingStatement
     */
    groupId?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupedBillingStatement
     */
    id?: number;
    /**
     * 
     * @type {Price}
     * @memberof GroupedBillingStatement
     */
    totalSalesPrice?: Price;
    /**
     * 
     * @type {ObjectReference}
     * @memberof GroupedBillingStatement
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof GroupedBillingStatement
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {Date}
     * @memberof GroupedBillingStatement
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof GroupedBillingStatement
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof GroupedBillingStatement
     */
    provisionType?: GroupedBillingStatement.ProvisionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GroupedBillingStatement
     */
    orderId?: string;
}

/**
 * @export
 * @namespace GroupedBillingStatement
 */
export namespace GroupedBillingStatement {
    /**
     * @export
     * @enum {string}
     */
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
}

/**
 * 
 * @export
 * @interface Grouping
 */
export interface Grouping {
    /**
     * 
     * @type {number}
     * @memberof Grouping
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Grouping
     */
    name?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Grouping
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Grouping
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {Date}
     * @memberof Grouping
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Grouping
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Grouping
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Grouping
     */
    isRemoved?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Grouping
     */
    invoiceReference?: string;
}

/**
 * 
 * @export
 * @interface InvoiceProfile
 */
export interface InvoiceProfile {
    /**
     * 
     * @type {number}
     * @memberof InvoiceProfile
     */
    id?: number;
    /**
     * 
     * @type {ObjectReference}
     * @memberof InvoiceProfile
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof InvoiceProfile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceProfile
     */
    invoiceReference?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceProfile
     */
    customerReference?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceProfile
     */
    requisitionNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceProfile
     */
    invoiceAddressId?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceProfile
     */
    deliveryAddressId?: number;
    /**
     * 
     * @type {AddressData}
     * @memberof InvoiceProfile
     */
    deliveryAddress?: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof InvoiceProfile
     */
    invoiceAddress?: AddressData;
}

/**
 * 
 * @export
 * @interface ManagementLink
 */
export interface ManagementLink {
    /**
     * 
     * @type {string}
     * @memberof ManagementLink
     */
    link?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ManagementLink
     */
    resellerCustomer?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ManagementLink
     */
    subscription?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof ManagementLink
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface ManagementLinkGrouped
 */
export interface ManagementLinkGrouped {
    /**
     * 
     * @type {string}
     * @memberof ManagementLinkGrouped
     */
    link?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ManagementLinkGrouped
     */
    resellerCustomer?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof ManagementLinkGrouped
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface Me
 */
export interface Me {
    /**
     * 
     * @type {string}
     * @memberof Me
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Me
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof Me
     */
    token?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Me
     */
    claims?: Array<string>;
}

/**
 * 
 * @export
 * @interface MinimumCommitmentLight
 */
export interface MinimumCommitmentLight {
    /**
     * 
     * @type {number}
     * @memberof MinimumCommitmentLight
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof MinimumCommitmentLight
     */
    months?: number;
    /**
     * 
     * @type {string}
     * @memberof MinimumCommitmentLight
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ObjectReference
 */
export interface ObjectReference {
    /**
     * 
     * @type {number}
     * @memberof ObjectReference
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ObjectReferenceDto
 */
export interface ObjectReferenceDto {
    /**
     * 
     * @type {number}
     * @memberof ObjectReferenceDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectReferenceDto
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    parentId?: number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    crayonCompanyName?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    accountNumber?: string;
}

/**
 * 
 * @export
 * @interface OrganizationAccess
 */
export interface OrganizationAccess {
    /**
     * 
     * @type {number}
     * @memberof OrganizationAccess
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationAccess
     */
    allAgreements?: boolean;
    /**
     * 
     * @type {Array<AgreementAccess>}
     * @memberof OrganizationAccess
     */
    agreements?: Array<AgreementAccess>;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationAccess
     */
    organization?: Organization;
    /**
     * 
     * @type {UserProfile}
     * @memberof OrganizationAccess
     */
    user?: UserProfile;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAccess
     */
    role?: OrganizationAccess.RoleEnum;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAccess
     */
    crayonCompanyName?: string;
    /**
     * 
     * @type {Date}
     * @memberof OrganizationAccess
     */
    timestamp?: Date;
}

/**
 * @export
 * @namespace OrganizationAccess
 */
export namespace OrganizationAccess {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        None = <any> 'None',
        User = <any> 'User',
        Administrator = <any> 'Administrator',
        Viewer = <any> 'Viewer',
        EditRights = <any> 'EditRights',
        All = <any> 'All'
    }
}

/**
 * 
 * @export
 * @interface OrganizationSalesContact
 */
export interface OrganizationSalesContact {
    /**
     * 
     * @type {string}
     * @memberof OrganizationSalesContact
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSalesContact
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationSalesContact
     */
    phone?: string;
}

/**
 * 
 * @export
 * @interface OrganizationUsageCost
 */
export interface OrganizationUsageCost {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCost
     */
    supplier?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCost
     */
    accountId?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCost
     */
    accountName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCost
     */
    subscriptionName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCost
     */
    subscriptionId?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface ProductContainer
 */
export interface ProductContainer {
    /**
     * 
     * @type {number}
     * @memberof ProductContainer
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductContainer
     */
    orderListId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    note?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainer
     */
    usageMonth?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductContainer
     */
    activeDraft?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductContainer
     */
    removed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    createdByUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    axContactUserId?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainer
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainer
     */
    orderStatusChangedDate?: Date;
    /**
     * 
     * @type {UserProfile}
     * @memberof ProductContainer
     */
    contactUser?: UserProfile;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductContainer
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductContainer
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {Program}
     * @memberof ProductContainer
     */
    program?: Program;
    /**
     * 
     * @type {Array<ProductRow>}
     * @memberof ProductContainer
     */
    productRows?: Array<ProductRow>;
    /**
     * 
     * @type {Array<ProductContainerComment>}
     * @memberof ProductContainer
     */
    comments?: Array<ProductContainerComment>;
    /**
     * 
     * @type {InvoiceProfile}
     * @memberof ProductContainer
     */
    invoiceProfile?: InvoiceProfile;
    /**
     * 
     * @type {AddressData}
     * @memberof ProductContainer
     */
    deliveryAddress?: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof ProductContainer
     */
    invoiceAddress?: AddressData;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    type?: ProductContainer.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    category?: ProductContainer.CategoryEnum;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainer
     */
    quoteValidToDate?: Date;
    /**
     * 
     * @type {Array<Price>}
     * @memberof ProductContainer
     */
    totalSalesPrice?: Array<Price>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof ProductContainer
     */
    totalAlternativeSalesPrice?: Array<Price>;
    /**
     * 
     * @type {Array<ProductContainerIssue>}
     * @memberof ProductContainer
     */
    issues?: Array<ProductContainerIssue>;
    /**
     * 
     * @type {ProductContainerCommentUser}
     * @memberof ProductContainer
     */
    submittedBy?: ProductContainerCommentUser;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainer
     */
    sent?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    invoiceReference?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    orderReference?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainer
     */
    requisition?: string;
}

/**
 * @export
 * @namespace ProductContainer
 */
export namespace ProductContainer {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        None = <any> 'None',
        Draft = <any> 'Draft',
        Request = <any> 'Request',
        Order = <any> 'Order',
        Quote = <any> 'Quote',
        Template = <any> 'Template'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Report = <any> 'Report'
    }
}

/**
 * 
 * @export
 * @interface ProductContainerComment
 */
export interface ProductContainerComment {
    /**
     * 
     * @type {number}
     * @memberof ProductContainerComment
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductContainerComment
     */
    productContainerId?: number;
    /**
     * 
     * @type {ProductContainerCommentUser}
     * @memberof ProductContainerComment
     */
    user?: ProductContainerCommentUser;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerComment
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainerComment
     */
    timeStamp?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProductContainerComment
     */
    modified?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ProductContainerComment
     */
    removed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerComment
     */
    productContainerCommentType?: ProductContainerComment.ProductContainerCommentTypeEnum;
}

/**
 * @export
 * @namespace ProductContainerComment
 */
export namespace ProductContainerComment {
    /**
     * @export
     * @enum {string}
     */
    export enum ProductContainerCommentTypeEnum {
        None = <any> 'None',
        Comment = <any> 'Comment',
        DraftCreated = <any> 'DraftCreated',
        DraftModified = <any> 'DraftModified',
        QuoteCreated = <any> 'QuoteCreated',
        QuoteModified = <any> 'QuoteModified',
        RequestCreated = <any> 'RequestCreated',
        RequestModifed = <any> 'RequestModifed',
        OrderSubmitted = <any> 'OrderSubmitted',
        OrderInvoiced = <any> 'OrderInvoiced',
        Removed = <any> 'Removed',
        TemplateCreated = <any> 'TemplateCreated',
        TemplateModifed = <any> 'TemplateModifed',
        RequestDeclined = <any> 'RequestDeclined',
        SystemMessage = <any> 'SystemMessage'
    }
}

/**
 * 
 * @export
 * @interface ProductContainerCommentUser
 */
export interface ProductContainerCommentUser {
    /**
     * 
     * @type {string}
     * @memberof ProductContainerCommentUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerCommentUser
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerCommentUser
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerCommentUser
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductContainerCommentUser
     */
    crayonEmployee?: boolean;
}

/**
 * 
 * @export
 * @interface ProductContainerIssue
 */
export interface ProductContainerIssue {
    /**
     * 
     * @type {string}
     * @memberof ProductContainerIssue
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductContainerIssue
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface ProductInformation
 */
export interface ProductInformation {
    /**
     * 
     * @type {number}
     * @memberof ProductInformation
     */
    externalProductId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductInformation
     */
    cultureCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductInformation
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductInformation
     */
    learnMoreLink?: string;
}

/**
 * 
 * @export
 * @interface ProductReference
 */
export interface ProductReference {
    /**
     * 
     * @type {number}
     * @memberof ProductReference
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductReference
     */
    partNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductReference
     */
    publisherProductId?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductReference
     */
    itemLegalName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductReference
     */
    itemName?: string;
}

/**
 * 
 * @export
 * @interface ProductRow
 */
export interface ProductRow {
    /**
     * 
     * @type {number}
     * @memberof ProductRow
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRow
     */
    productContainerId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRow
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    usageCountryCode?: string;
    /**
     * 
     * @type {Price}
     * @memberof ProductRow
     */
    salesUnitPrice?: Price;
    /**
     * 
     * @type {Price}
     * @memberof ProductRow
     */
    alternativeSalesUnitPrice?: Price;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRow
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRow
     */
    program?: ObjectReference;
    /**
     * 
     * @type {AgreementIdentityReference}
     * @memberof ProductRow
     */
    agreement?: AgreementIdentityReference;
    /**
     * 
     * @type {ProductReference}
     * @memberof ProductRow
     */
    product?: ProductReference;
    /**
     * 
     * @type {ProductRowUser}
     * @memberof ProductRow
     */
    user?: ProductRowUser;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRow
     */
    productVariant?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRow
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {Grouping}
     * @memberof ProductRow
     */
    grouping?: Grouping;
    /**
     * 
     * @type {Array<ProductContainerIssue>}
     * @memberof ProductRow
     */
    issues?: Array<ProductContainerIssue>;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    offeringType?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    priceCalculation?: ProductRow.PriceCalculationEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    invoiceReference?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRow
     */
    customerReference?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductRow
     */
    salesPricePerAlternativeUnit?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRow
     */
    levelValue?: number;
}

/**
 * @export
 * @namespace ProductRow
 */
export namespace ProductRow {
    /**
     * @export
     * @enum {string}
     */
    export enum PriceCalculationEnum {
        None = <any> 'None',
        Default = <any> 'Default',
        SelectPlus = <any> 'SelectPlus',
        AdobeVip = <any> 'AdobeVip',
        Mpsa = <any> 'Mpsa'
    }
}

/**
 * 
 * @export
 * @interface ProductRowPatch
 */
export interface ProductRowPatch {
    /**
     * 
     * @type {number}
     * @memberof ProductRowPatch
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRowPatch
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductRowPatch
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRowPatch
     */
    usageCountryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRowPatch
     */
    userId?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRowPatch
     */
    agreement?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRowPatch
     */
    productVariant?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductRowPatch
     */
    grouping?: ObjectReference;
}

/**
 * 
 * @export
 * @interface ProductRowUser
 */
export interface ProductRowUser {
    /**
     * 
     * @type {string}
     * @memberof ProductRowUser
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRowUser
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRowUser
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductRowUser
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductRowUser
     */
    crayonEmployee?: boolean;
}

/**
 * 
 * @export
 * @interface ProductVariant
 */
export interface ProductVariant {
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    id?: number;
    /**
     * 
     * @type {ProductReference}
     * @memberof ProductVariant
     */
    product?: ProductReference;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    partNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    productName?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    program?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    productFamily?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    language?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    level?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    productType?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    pool?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    licenseType?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    licenseAgreementType?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    operatingSystem?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof ProductVariant
     */
    offering?: ObjectReference;
    /**
     * 
     * @type {MinimumCommitmentLight}
     * @memberof ProductVariant
     */
    minimumCommitment?: MinimumCommitmentLight;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    unitCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    purchaseUnit?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductVariant
     */
    addDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProductVariant
     */
    deleteDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    productCategory?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    region?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVariant
     */
    isTrial?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    defaultBillingCycleId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ProductVariant
     */
    availableBillingCycleIds?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProductVariant
     */
    attributes?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface Program
 */
export interface Program {
    /**
     * 
     * @type {number}
     * @memberof Program
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Program
     */
    isCommitment?: boolean;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Program
     */
    publisher?: ObjectReference;
}

/**
 * 
 * @export
 * @interface Publisher
 */
export interface Publisher {
    /**
     * 
     * @type {number}
     * @memberof Publisher
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Publisher
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface PublisherAggregationItem
 */
export interface PublisherAggregationItem {
    /**
     * 
     * @type {string}
     * @memberof PublisherAggregationItem
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof PublisherAggregationItem
     */
    docCount?: number;
    /**
     * 
     * @type {Array<AggregationItem>}
     * @memberof PublisherAggregationItem
     */
    programs?: Array<AggregationItem>;
}

/**
 * 
 * @export
 * @interface PutAzureSubscription
 */
export interface PutAzureSubscription {
    /**
     * 
     * @type {number}
     * @memberof PutAzureSubscription
     */
    id?: number;
    /**
     * 
     * @type {ObjectReference}
     * @memberof PutAzureSubscription
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {AzureSubscriptionTags}
     * @memberof PutAzureSubscription
     */
    tags?: AzureSubscriptionTags;
}

/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ResellerSalesPrice
 */
export interface ResellerSalesPrice {
    /**
     * 
     * @type {number}
     * @memberof ResellerSalesPrice
     */
    objectId?: number;
    /**
     * 
     * @type {string}
     * @memberof ResellerSalesPrice
     */
    objectType?: ResellerSalesPrice.ObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResellerSalesPrice
     */
    type?: ResellerSalesPrice.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResellerSalesPrice
     */
    priceType?: ResellerSalesPrice.PriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ResellerSalesPrice
     */
    value?: number;
    /**
     * 
     * @type {Date}
     * @memberof ResellerSalesPrice
     */
    fromDate?: Date;
}

/**
 * @export
 * @namespace ResellerSalesPrice
 */
export namespace ResellerSalesPrice {
    /**
     * @export
     * @enum {string}
     */
    export enum ObjectTypeEnum {
        Organization = <any> 'Organization',
        CustomerTenant = <any> 'CustomerTenant',
        Subscription = <any> 'Subscription',
        SubscriptionAddon = <any> 'SubscriptionAddon'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        License = <any> 'License',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PriceTypeEnum {
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}

/**
 * 
 * @export
 * @interface ResellerSalesPriceToggle
 */
export interface ResellerSalesPriceToggle {
    /**
     * 
     * @type {boolean}
     * @memberof ResellerSalesPriceToggle
     */
    toggle?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ResellerSalesPriceToggle
     */
    objectId?: number;
    /**
     * 
     * @type {string}
     * @memberof ResellerSalesPriceToggle
     */
    objectType?: ResellerSalesPriceToggle.ObjectTypeEnum;
}

/**
 * @export
 * @namespace ResellerSalesPriceToggle
 */
export namespace ResellerSalesPriceToggle {
    /**
     * @export
     * @enum {string}
     */
    export enum ObjectTypeEnum {
        Organization = <any> 'Organization',
        CustomerTenant = <any> 'CustomerTenant',
        Subscription = <any> 'Subscription',
        SubscriptionAddon = <any> 'SubscriptionAddon'
    }
}

/**
 * 
 * @export
 * @interface ResourceGroupUsageCost
 */
export interface ResourceGroupUsageCost {
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCost
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCost
     */
    subcategory?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCost
     */
    meter?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourceGroupUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface ResourceGroupUsageCostRequest
 */
export interface ResourceGroupUsageCostRequest {
    /**
     * 
     * @type {number}
     * @memberof ResourceGroupUsageCostRequest
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCostRequest
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCostRequest
     */
    resourceGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceGroupUsageCostRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof ResourceGroupUsageCostRequest
     */
    from?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ResourceGroupUsageCostRequest
     */
    to?: Date;
}

/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof Secret
     */
    expiration?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Secret
     */
    timeStamp?: Date;
}

/**
 * 
 * @export
 * @interface ServiceAccountAgreement
 */
export interface ServiceAccountAgreement {
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAgreement
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAgreement
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAgreement
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAgreement
     */
    email?: string;
    /**
     * 
     * @type {Date}
     * @memberof ServiceAccountAgreement
     */
    dateAgreed?: Date;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountAgreement
     */
    agreementType?: ServiceAccountAgreement.AgreementTypeEnum;
}

/**
 * @export
 * @namespace ServiceAccountAgreement
 */
export namespace ServiceAccountAgreement {
    /**
     * @export
     * @enum {string}
     */
    export enum AgreementTypeEnum {
        MicrosoftCloudAgreement = <any> 'MicrosoftCloudAgreement',
        MicrosoftCustomerAgreement = <any> 'MicrosoftCustomerAgreement'
    }
}

/**
 * 
 * @export
 * @interface SubcategoryUsageCost
 */
export interface SubcategoryUsageCost {
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCost
     */
    meter?: string;
    /**
     * 
     * @type {number}
     * @memberof SubcategoryUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface SubcategoryUsageCostRequest
 */
export interface SubcategoryUsageCostRequest {
    /**
     * 
     * @type {number}
     * @memberof SubcategoryUsageCostRequest
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCostRequest
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCostRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCostRequest
     */
    subcategory?: string;
    /**
     * 
     * @type {string}
     * @memberof SubcategoryUsageCostRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubcategoryUsageCostRequest
     */
    from?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubcategoryUsageCostRequest
     */
    to?: Date;
}

/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    entitlementId?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Subscription
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Subscription
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {CustomerTenantReference}
     * @memberof Subscription
     */
    customerTenant?: CustomerTenantReference;
    /**
     * 
     * @type {ProductReference}
     * @memberof Subscription
     */
    product?: ProductReference;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    status?: Subscription.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    provisionType?: Subscription.ProvisionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    availableAddonsCount?: number;
    /**
     * 
     * @type {Array<SubscriptionAddOn>}
     * @memberof Subscription
     */
    subscriptions?: Array<SubscriptionAddOn>;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    orderId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    creationDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    billingCycle?: Subscription.BillingCycleEnum;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    markup?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    isTrial?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    priceType?: Subscription.PriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    salesPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    registeredForReservedInstance?: boolean;
    /**
     * 
     * @type {ObjectReference}
     * @memberof Subscription
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {SubscriptionTags}
     * @memberof Subscription
     */
    subscriptionTags?: SubscriptionTags;
}

/**
 * @export
 * @namespace Subscription
 */
export namespace Subscription {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}

/**
 * 
 * @export
 * @interface SubscriptionAddOn
 */
export interface SubscriptionAddOn {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionAddOn
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionAddOn
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionAddOn
     */
    publisherCustomerId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionAddOn
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionAddOn
     */
    status?: SubscriptionAddOn.StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionAddOn
     */
    quantity?: number;
    /**
     * 
     * @type {ObjectReference}
     * @memberof SubscriptionAddOn
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionAddOn
     */
    orderId?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionAddOn
     */
    creationDate?: Date;
    /**
     * 
     * @type {ProductReference}
     * @memberof SubscriptionAddOn
     */
    product?: ProductReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof SubscriptionAddOn
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionAddOn
     */
    markup?: number;
    /**
     * 
     * @type {SubscriptionTags}
     * @memberof SubscriptionAddOn
     */
    subscriptionTags?: SubscriptionTags;
}

/**
 * @export
 * @namespace SubscriptionAddOn
 */
export namespace SubscriptionAddOn {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
}

/**
 * 
 * @export
 * @interface SubscriptionConversion
 */
export interface SubscriptionConversion {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionConversion
     */
    billingCycle?: SubscriptionConversion.BillingCycleEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionConversion
     */
    offerId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionConversion
     */
    orderId?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionConversion
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionConversion
     */
    targetOfferId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionConversion
     */
    productName?: string;
}

/**
 * @export
 * @namespace SubscriptionConversion
 */
export namespace SubscriptionConversion {
    /**
     * @export
     * @enum {string}
     */
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
}

/**
 * 
 * @export
 * @interface SubscriptionDetailed
 */
export interface SubscriptionDetailed {
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionDetailed
     */
    effectiveStartDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionDetailed
     */
    commitmentEndDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    suspensionReasons?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    originalAgreementId?: number;
    /**
     * 
     * @type {SubscriptionPricing}
     * @memberof SubscriptionDetailed
     */
    pricing?: SubscriptionPricing;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    entitlementId?: string;
    /**
     * 
     * @type {ObjectReference}
     * @memberof SubscriptionDetailed
     */
    publisher?: ObjectReference;
    /**
     * 
     * @type {ObjectReference}
     * @memberof SubscriptionDetailed
     */
    organization?: ObjectReference;
    /**
     * 
     * @type {CustomerTenantReference}
     * @memberof SubscriptionDetailed
     */
    customerTenant?: CustomerTenantReference;
    /**
     * 
     * @type {ProductReference}
     * @memberof SubscriptionDetailed
     */
    product?: ProductReference;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    status?: SubscriptionDetailed.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    provisionType?: SubscriptionDetailed.ProvisionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    availableAddonsCount?: number;
    /**
     * 
     * @type {Array<SubscriptionAddOn>}
     * @memberof SubscriptionDetailed
     */
    subscriptions?: Array<SubscriptionAddOn>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    orderId?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionDetailed
     */
    creationDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    billingCycle?: SubscriptionDetailed.BillingCycleEnum;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    markup?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionDetailed
     */
    isTrial?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionDetailed
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionDetailed
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDetailed
     */
    priceType?: SubscriptionDetailed.PriceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionDetailed
     */
    salesPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionDetailed
     */
    registeredForReservedInstance?: boolean;
    /**
     * 
     * @type {ObjectReference}
     * @memberof SubscriptionDetailed
     */
    invoiceProfile?: ObjectReference;
    /**
     * 
     * @type {SubscriptionTags}
     * @memberof SubscriptionDetailed
     */
    subscriptionTags?: SubscriptionTags;
}

/**
 * @export
 * @namespace SubscriptionDetailed
 */
export namespace SubscriptionDetailed {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}

/**
 * 
 * @export
 * @interface SubscriptionLite
 */
export interface SubscriptionLite {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionLite
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionLite
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionLite
     */
    publisherSubscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionLite
     */
    resellerCustomerName?: string;
}

/**
 * 
 * @export
 * @interface SubscriptionPricing
 */
export interface SubscriptionPricing {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPricing
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPricing
     */
    purchasePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPricing
     */
    recommendedRetailPrice?: number;
}

/**
 * 
 * @export
 * @interface SubscriptionResourceGroupUsageCost
 */
export interface SubscriptionResourceGroupUsageCost {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResourceGroupUsageCost
     */
    resourceGroup?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionResourceGroupUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResourceGroupUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface SubscriptionTags
 */
export interface SubscriptionTags {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTags
     */
    subscriptionId?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTags
     */
    costCenter?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTags
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTags
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTags
     */
    custom?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTags
     */
    owner?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionTags
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionTags
     */
    modifiedDate?: Date;
}

/**
 * 
 * @export
 * @interface SubscriptionUsageCost
 */
export interface SubscriptionUsageCost {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageCost
     */
    category?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUsageCost
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageCost
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface SubscriptionUsageCostRequest
 */
export interface SubscriptionUsageCostRequest {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUsageCostRequest
     */
    resellerCustomerId?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageCostRequest
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageCostRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionUsageCostRequest
     */
    from?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionUsageCostRequest
     */
    to?: Date;
}

/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    identityToken?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    expiresIn?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    tokenType?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    refreshToken?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    emailConfirmed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    lockoutEnabled?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof User
     */
    lockoutEnd?: Date;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phoneNumber?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    phoneNumberConfirmed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    twoFactorEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    tenantAdmin?: boolean;
}

/**
 * 
 * @export
 * @interface UserChangePassword
 */
export interface UserChangePassword {
    /**
     * 
     * @type {string}
     * @memberof UserChangePassword
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChangePassword
     */
    oldPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UserChangePassword
     */
    newPassword?: string;
}

/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    lastName?: string;
}


/**
 * ActivityLogsApi - fetch parameter creator
 * @export
 */
export const ActivityLogsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [entity] 
         * @param {number} [id] 
         * @param {Array<number>} [ids] 
         * @param {Date} [searchDate] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(entity?: string, id?: number, ids?: Array<number>, searchDate?: Date, from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ActivityLogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (entity !== undefined) {
                localVarQueryParameter['Entity'] = entity;
            }

            if (id !== undefined) {
                localVarQueryParameter['Id'] = id;
            }

            if (ids) {
                localVarQueryParameter['Ids'] = ids;
            }

            if (searchDate !== undefined) {
                localVarQueryParameter['SearchDate'] = (searchDate as any).toISOString();
            }

            if (from !== undefined) {
                localVarQueryParameter['From'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = (to as any).toISOString();
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogsApi - functional programming interface
 * @export
 */
export const ActivityLogsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [entity] 
         * @param {number} [id] 
         * @param {Array<number>} [ids] 
         * @param {Date} [searchDate] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(entity?: string, id?: number, ids?: Array<number>, searchDate?: Date, from?: Date, to?: Date, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityLog> {
            const localVarFetchArgs = ActivityLogsApiFetchParamCreator(configuration).get(entity, id, ids, searchDate, from, to, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityLogsApi - factory interface
 * @export
 */
export const ActivityLogsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [entity] 
         * @param {number} [id] 
         * @param {Array<number>} [ids] 
         * @param {Date} [searchDate] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(entity?: string, id?: number, ids?: Array<number>, searchDate?: Date, from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
            return ActivityLogsApiFp(configuration).get(entity, id, ids, searchDate, from, to, page, pageSize, options)(fetch, basePath);
        },
    };
};

/**
 * ActivityLogsApi - object-oriented interface
 * @export
 * @class ActivityLogsApi
 * @extends {BaseAPI}
 */
export class ActivityLogsApi extends BaseAPI {
    /**
     * 
     * @param {string} [entity] 
     * @param {number} [id] 
     * @param {Array<number>} [ids] 
     * @param {Date} [searchDate] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogsApi
     */
    public get(entity?: string, id?: number, ids?: Array<number>, searchDate?: Date, from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
        return ActivityLogsApiFp(this.configuration).get(entity, id, ids, searchDate, from, to, page, pageSize, options)(this.fetch, this.basePath);
    }

}

/**
 * AddressesApi - fetch parameter creator
 * @export
 */
export const AddressesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {'None' | 'Invoice' | 'Delivery'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId: number, type?: 'None' | 'Invoice' | 'Delivery', options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling get.');
            }
            const localVarPath = `/api/v1/organizations/{organizationId}/Addresses`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(organizationId: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/organizations/{organizationId}/Addresses/{id}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {'None' | 'Invoice' | 'Delivery'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId: number, type?: 'None' | 'Invoice' | 'Delivery', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAddress> {
            const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).get(organizationId, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(organizationId: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Address> {
            const localVarFetchArgs = AddressesApiFetchParamCreator(configuration).getById(organizationId, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {'None' | 'Invoice' | 'Delivery'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId: number, type?: 'None' | 'Invoice' | 'Delivery', options?: any) {
            return AddressesApiFp(configuration).get(organizationId, type, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(organizationId: number, id: number, options?: any) {
            return AddressesApiFp(configuration).getById(organizationId, id, options)(fetch, basePath);
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * 
     * @param {number} organizationId 
     * @param {'None' | 'Invoice' | 'Delivery'} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public get(organizationId: number, type?: 'None' | 'Invoice' | 'Delivery', options?: any) {
        return AddressesApiFp(this.configuration).get(organizationId, type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public getById(organizationId: number, id: number, options?: any) {
        return AddressesApiFp(this.configuration).getById(organizationId, id, options)(this.fetch, this.basePath);
    }

}

/**
 * AgreementProductsApi - fetch parameter creator
 * @export
 */
export const AgreementProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypeIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [priceListId] 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [agreementId] 
         * @param {boolean} [isTrial] 
         * @param {Array<number>} [agreementIds] 
         * @param {Date} [searchDate] 
         * @param {Array<string>} [includePartNumbers] 
         * @param {Array<number>} [includePublisherIds] 
         * @param {Array<string>} [includePublisherNames] 
         * @param {Array<string>} [includePoolNames] 
         * @param {Array<string>} [includeOperatingSystemNames] 
         * @param {Array<string>} [includeLevelNames] 
         * @param {Array<string>} [includeLanguageNames] 
         * @param {Array<string>} [includeLicenseAgreementTypeNames] 
         * @param {Array<string>} [includeLicenseTypeNames] 
         * @param {Array<string>} [includeProductFamilyNames] 
         * @param {Array<string>} [includeProductTypeNames] 
         * @param {Array<string>} [includeProgramNames] 
         * @param {Array<string>} [includeOfferingNames] 
         * @param {Array<string>} [includePurchasePeriodNames] 
         * @param {Array<string>} [includePurchaseUnitNames] 
         * @param {Array<string>} [includeVersionNames] 
         * @param {Array<string>} [includeRegionNames] 
         * @param {Array<string>} [includeProductCategoryNames] 
         * @param {Array<string>} [excludePartNumbers] 
         * @param {Array<number>} [excludePublisherIds] 
         * @param {Array<string>} [excludePublisherNames] 
         * @param {Array<string>} [excludePoolNames] 
         * @param {Array<string>} [excludeOperatingSystemNames] 
         * @param {Array<string>} [excludeLevelNames] 
         * @param {Array<string>} [excludeLanguageNames] 
         * @param {Array<string>} [excludeLicenseAgreementTypeNames] 
         * @param {Array<string>} [excludeLicenseTypeNames] 
         * @param {Array<string>} [excludeProductFamilyNames] 
         * @param {Array<string>} [excludeProductTypeNames] 
         * @param {Array<string>} [excludeProgramNames] 
         * @param {Array<string>} [excludeOfferingNames] 
         * @param {Array<string>} [excludePurchasePeriodNames] 
         * @param {Array<string>} [excludePurchaseUnitNames] 
         * @param {Array<string>} [excludeVersionNames] 
         * @param {Array<string>} [excludeRegionNames] 
         * @param {Array<string>} [excludeProductCategoryNames] 
         * @param {string} [sortKey] 
         * @param {boolean} [includeProductInformation] 
         * @param {'Ascending' | 'Descending'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(agreementTypeIds?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, page?: number, pageSize?: number, search?: string, priceListId?: number, organizationId?: number, customerTenantId?: number, agreementId?: number, isTrial?: boolean, agreementIds?: Array<number>, searchDate?: Date, includePartNumbers?: Array<string>, includePublisherIds?: Array<number>, includePublisherNames?: Array<string>, includePoolNames?: Array<string>, includeOperatingSystemNames?: Array<string>, includeLevelNames?: Array<string>, includeLanguageNames?: Array<string>, includeLicenseAgreementTypeNames?: Array<string>, includeLicenseTypeNames?: Array<string>, includeProductFamilyNames?: Array<string>, includeProductTypeNames?: Array<string>, includeProgramNames?: Array<string>, includeOfferingNames?: Array<string>, includePurchasePeriodNames?: Array<string>, includePurchaseUnitNames?: Array<string>, includeVersionNames?: Array<string>, includeRegionNames?: Array<string>, includeProductCategoryNames?: Array<string>, excludePartNumbers?: Array<string>, excludePublisherIds?: Array<number>, excludePublisherNames?: Array<string>, excludePoolNames?: Array<string>, excludeOperatingSystemNames?: Array<string>, excludeLevelNames?: Array<string>, excludeLanguageNames?: Array<string>, excludeLicenseAgreementTypeNames?: Array<string>, excludeLicenseTypeNames?: Array<string>, excludeProductFamilyNames?: Array<string>, excludeProductTypeNames?: Array<string>, excludeProgramNames?: Array<string>, excludeOfferingNames?: Array<string>, excludePurchasePeriodNames?: Array<string>, excludePurchaseUnitNames?: Array<string>, excludeVersionNames?: Array<string>, excludeRegionNames?: Array<string>, excludeProductCategoryNames?: Array<string>, sortKey?: string, includeProductInformation?: boolean, sortOrder?: 'Ascending' | 'Descending', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/AgreementProducts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (agreementTypeIds) {
                localVarQueryParameter['AgreementTypeIds'] = agreementTypeIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (priceListId !== undefined) {
                localVarQueryParameter['PriceListId'] = priceListId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (customerTenantId !== undefined) {
                localVarQueryParameter['CustomerTenantId'] = customerTenantId;
            }

            if (agreementId !== undefined) {
                localVarQueryParameter['AgreementId'] = agreementId;
            }

            if (isTrial !== undefined) {
                localVarQueryParameter['IsTrial'] = isTrial;
            }

            if (agreementIds) {
                localVarQueryParameter['AgreementIds'] = agreementIds;
            }

            if (searchDate !== undefined) {
                localVarQueryParameter['SearchDate'] = (searchDate as any).toISOString();
            }

            if (includePartNumbers) {
                localVarQueryParameter['Include.PartNumbers'] = includePartNumbers;
            }

            if (includePublisherIds) {
                localVarQueryParameter['Include.PublisherIds'] = includePublisherIds;
            }

            if (includePublisherNames) {
                localVarQueryParameter['Include.PublisherNames'] = includePublisherNames;
            }

            if (includePoolNames) {
                localVarQueryParameter['Include.PoolNames'] = includePoolNames;
            }

            if (includeOperatingSystemNames) {
                localVarQueryParameter['Include.OperatingSystemNames'] = includeOperatingSystemNames;
            }

            if (includeLevelNames) {
                localVarQueryParameter['Include.LevelNames'] = includeLevelNames;
            }

            if (includeLanguageNames) {
                localVarQueryParameter['Include.LanguageNames'] = includeLanguageNames;
            }

            if (includeLicenseAgreementTypeNames) {
                localVarQueryParameter['Include.LicenseAgreementTypeNames'] = includeLicenseAgreementTypeNames;
            }

            if (includeLicenseTypeNames) {
                localVarQueryParameter['Include.LicenseTypeNames'] = includeLicenseTypeNames;
            }

            if (includeProductFamilyNames) {
                localVarQueryParameter['Include.ProductFamilyNames'] = includeProductFamilyNames;
            }

            if (includeProductTypeNames) {
                localVarQueryParameter['Include.ProductTypeNames'] = includeProductTypeNames;
            }

            if (includeProgramNames) {
                localVarQueryParameter['Include.ProgramNames'] = includeProgramNames;
            }

            if (includeOfferingNames) {
                localVarQueryParameter['Include.OfferingNames'] = includeOfferingNames;
            }

            if (includePurchasePeriodNames) {
                localVarQueryParameter['Include.PurchasePeriodNames'] = includePurchasePeriodNames;
            }

            if (includePurchaseUnitNames) {
                localVarQueryParameter['Include.PurchaseUnitNames'] = includePurchaseUnitNames;
            }

            if (includeVersionNames) {
                localVarQueryParameter['Include.VersionNames'] = includeVersionNames;
            }

            if (includeRegionNames) {
                localVarQueryParameter['Include.RegionNames'] = includeRegionNames;
            }

            if (includeProductCategoryNames) {
                localVarQueryParameter['Include.ProductCategoryNames'] = includeProductCategoryNames;
            }

            if (excludePartNumbers) {
                localVarQueryParameter['Exclude.PartNumbers'] = excludePartNumbers;
            }

            if (excludePublisherIds) {
                localVarQueryParameter['Exclude.PublisherIds'] = excludePublisherIds;
            }

            if (excludePublisherNames) {
                localVarQueryParameter['Exclude.PublisherNames'] = excludePublisherNames;
            }

            if (excludePoolNames) {
                localVarQueryParameter['Exclude.PoolNames'] = excludePoolNames;
            }

            if (excludeOperatingSystemNames) {
                localVarQueryParameter['Exclude.OperatingSystemNames'] = excludeOperatingSystemNames;
            }

            if (excludeLevelNames) {
                localVarQueryParameter['Exclude.LevelNames'] = excludeLevelNames;
            }

            if (excludeLanguageNames) {
                localVarQueryParameter['Exclude.LanguageNames'] = excludeLanguageNames;
            }

            if (excludeLicenseAgreementTypeNames) {
                localVarQueryParameter['Exclude.LicenseAgreementTypeNames'] = excludeLicenseAgreementTypeNames;
            }

            if (excludeLicenseTypeNames) {
                localVarQueryParameter['Exclude.LicenseTypeNames'] = excludeLicenseTypeNames;
            }

            if (excludeProductFamilyNames) {
                localVarQueryParameter['Exclude.ProductFamilyNames'] = excludeProductFamilyNames;
            }

            if (excludeProductTypeNames) {
                localVarQueryParameter['Exclude.ProductTypeNames'] = excludeProductTypeNames;
            }

            if (excludeProgramNames) {
                localVarQueryParameter['Exclude.ProgramNames'] = excludeProgramNames;
            }

            if (excludeOfferingNames) {
                localVarQueryParameter['Exclude.OfferingNames'] = excludeOfferingNames;
            }

            if (excludePurchasePeriodNames) {
                localVarQueryParameter['Exclude.PurchasePeriodNames'] = excludePurchasePeriodNames;
            }

            if (excludePurchaseUnitNames) {
                localVarQueryParameter['Exclude.PurchaseUnitNames'] = excludePurchaseUnitNames;
            }

            if (excludeVersionNames) {
                localVarQueryParameter['Exclude.VersionNames'] = excludeVersionNames;
            }

            if (excludeRegionNames) {
                localVarQueryParameter['Exclude.RegionNames'] = excludeRegionNames;
            }

            if (excludeProductCategoryNames) {
                localVarQueryParameter['Exclude.ProductCategoryNames'] = excludeProductCategoryNames;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['SortKey'] = sortKey;
            }

            if (includeProductInformation !== undefined) {
                localVarQueryParameter['IncludeProductInformation'] = includeProductInformation;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['SortOrder'] = sortOrder;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsExcelFile(filter?: AgreementProductFilter, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/AgreementProducts/file/xlsx`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AgreementProductFilter" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(filter || {}) : (filter || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationSdk133(filter?: AgreementProductFilter, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/AgreementProducts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AgreementProductFilter" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(filter || {}) : (filter || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partNumber 
         * @param {number} [resellerCustomerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedBillingCycles(partNumber: string, resellerCustomerId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'partNumber' is not null or undefined
            if (partNumber === null || partNumber === undefined) {
                throw new RequiredError('partNumber','Required parameter partNumber was null or undefined when calling getSupportedBillingCycles.');
            }
            const localVarPath = `/api/v1/AgreementProducts/{partNumber}/supportedbillingcycles`
                .replace(`{${"partNumber"}}`, encodeURIComponent(String(partNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (resellerCustomerId !== undefined) {
                localVarQueryParameter['resellerCustomerId'] = resellerCustomerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgreementProductsApi - functional programming interface
 * @export
 */
export const AgreementProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypeIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [priceListId] 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [agreementId] 
         * @param {boolean} [isTrial] 
         * @param {Array<number>} [agreementIds] 
         * @param {Date} [searchDate] 
         * @param {Array<string>} [includePartNumbers] 
         * @param {Array<number>} [includePublisherIds] 
         * @param {Array<string>} [includePublisherNames] 
         * @param {Array<string>} [includePoolNames] 
         * @param {Array<string>} [includeOperatingSystemNames] 
         * @param {Array<string>} [includeLevelNames] 
         * @param {Array<string>} [includeLanguageNames] 
         * @param {Array<string>} [includeLicenseAgreementTypeNames] 
         * @param {Array<string>} [includeLicenseTypeNames] 
         * @param {Array<string>} [includeProductFamilyNames] 
         * @param {Array<string>} [includeProductTypeNames] 
         * @param {Array<string>} [includeProgramNames] 
         * @param {Array<string>} [includeOfferingNames] 
         * @param {Array<string>} [includePurchasePeriodNames] 
         * @param {Array<string>} [includePurchaseUnitNames] 
         * @param {Array<string>} [includeVersionNames] 
         * @param {Array<string>} [includeRegionNames] 
         * @param {Array<string>} [includeProductCategoryNames] 
         * @param {Array<string>} [excludePartNumbers] 
         * @param {Array<number>} [excludePublisherIds] 
         * @param {Array<string>} [excludePublisherNames] 
         * @param {Array<string>} [excludePoolNames] 
         * @param {Array<string>} [excludeOperatingSystemNames] 
         * @param {Array<string>} [excludeLevelNames] 
         * @param {Array<string>} [excludeLanguageNames] 
         * @param {Array<string>} [excludeLicenseAgreementTypeNames] 
         * @param {Array<string>} [excludeLicenseTypeNames] 
         * @param {Array<string>} [excludeProductFamilyNames] 
         * @param {Array<string>} [excludeProductTypeNames] 
         * @param {Array<string>} [excludeProgramNames] 
         * @param {Array<string>} [excludeOfferingNames] 
         * @param {Array<string>} [excludePurchasePeriodNames] 
         * @param {Array<string>} [excludePurchaseUnitNames] 
         * @param {Array<string>} [excludeVersionNames] 
         * @param {Array<string>} [excludeRegionNames] 
         * @param {Array<string>} [excludeProductCategoryNames] 
         * @param {string} [sortKey] 
         * @param {boolean} [includeProductInformation] 
         * @param {'Ascending' | 'Descending'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(agreementTypeIds?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, page?: number, pageSize?: number, search?: string, priceListId?: number, organizationId?: number, customerTenantId?: number, agreementId?: number, isTrial?: boolean, agreementIds?: Array<number>, searchDate?: Date, includePartNumbers?: Array<string>, includePublisherIds?: Array<number>, includePublisherNames?: Array<string>, includePoolNames?: Array<string>, includeOperatingSystemNames?: Array<string>, includeLevelNames?: Array<string>, includeLanguageNames?: Array<string>, includeLicenseAgreementTypeNames?: Array<string>, includeLicenseTypeNames?: Array<string>, includeProductFamilyNames?: Array<string>, includeProductTypeNames?: Array<string>, includeProgramNames?: Array<string>, includeOfferingNames?: Array<string>, includePurchasePeriodNames?: Array<string>, includePurchaseUnitNames?: Array<string>, includeVersionNames?: Array<string>, includeRegionNames?: Array<string>, includeProductCategoryNames?: Array<string>, excludePartNumbers?: Array<string>, excludePublisherIds?: Array<number>, excludePublisherNames?: Array<string>, excludePoolNames?: Array<string>, excludeOperatingSystemNames?: Array<string>, excludeLevelNames?: Array<string>, excludeLanguageNames?: Array<string>, excludeLicenseAgreementTypeNames?: Array<string>, excludeLicenseTypeNames?: Array<string>, excludeProductFamilyNames?: Array<string>, excludeProductTypeNames?: Array<string>, excludeProgramNames?: Array<string>, excludeOfferingNames?: Array<string>, excludePurchasePeriodNames?: Array<string>, excludePurchaseUnitNames?: Array<string>, excludeVersionNames?: Array<string>, excludeRegionNames?: Array<string>, excludeProductCategoryNames?: Array<string>, sortKey?: string, includeProductInformation?: boolean, sortOrder?: 'Ascending' | 'Descending', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AgreementProductCollection> {
            const localVarFetchArgs = AgreementProductsApiFetchParamCreator(configuration).get(agreementTypeIds, page, pageSize, search, priceListId, organizationId, customerTenantId, agreementId, isTrial, agreementIds, searchDate, includePartNumbers, includePublisherIds, includePublisherNames, includePoolNames, includeOperatingSystemNames, includeLevelNames, includeLanguageNames, includeLicenseAgreementTypeNames, includeLicenseTypeNames, includeProductFamilyNames, includeProductTypeNames, includeProgramNames, includeOfferingNames, includePurchasePeriodNames, includePurchaseUnitNames, includeVersionNames, includeRegionNames, includeProductCategoryNames, excludePartNumbers, excludePublisherIds, excludePublisherNames, excludePoolNames, excludeOperatingSystemNames, excludeLevelNames, excludeLanguageNames, excludeLicenseAgreementTypeNames, excludeLicenseTypeNames, excludeProductFamilyNames, excludeProductTypeNames, excludeProgramNames, excludeOfferingNames, excludePurchasePeriodNames, excludePurchaseUnitNames, excludeVersionNames, excludeRegionNames, excludeProductCategoryNames, sortKey, includeProductInformation, sortOrder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsExcelFile(filter?: AgreementProductFilter, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgreementProductsApiFetchParamCreator(configuration).getAsExcelFile(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationSdk133(filter?: AgreementProductFilter, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AgreementProductCollection> {
            const localVarFetchArgs = AgreementProductsApiFetchParamCreator(configuration).getOperationSdk133(filter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} partNumber 
         * @param {number} [resellerCustomerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedBillingCycles(partNumber: string, resellerCustomerId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AgreementProductsApiFetchParamCreator(configuration).getSupportedBillingCycles(partNumber, resellerCustomerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgreementProductsApi - factory interface
 * @export
 */
export const AgreementProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypeIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [priceListId] 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [agreementId] 
         * @param {boolean} [isTrial] 
         * @param {Array<number>} [agreementIds] 
         * @param {Date} [searchDate] 
         * @param {Array<string>} [includePartNumbers] 
         * @param {Array<number>} [includePublisherIds] 
         * @param {Array<string>} [includePublisherNames] 
         * @param {Array<string>} [includePoolNames] 
         * @param {Array<string>} [includeOperatingSystemNames] 
         * @param {Array<string>} [includeLevelNames] 
         * @param {Array<string>} [includeLanguageNames] 
         * @param {Array<string>} [includeLicenseAgreementTypeNames] 
         * @param {Array<string>} [includeLicenseTypeNames] 
         * @param {Array<string>} [includeProductFamilyNames] 
         * @param {Array<string>} [includeProductTypeNames] 
         * @param {Array<string>} [includeProgramNames] 
         * @param {Array<string>} [includeOfferingNames] 
         * @param {Array<string>} [includePurchasePeriodNames] 
         * @param {Array<string>} [includePurchaseUnitNames] 
         * @param {Array<string>} [includeVersionNames] 
         * @param {Array<string>} [includeRegionNames] 
         * @param {Array<string>} [includeProductCategoryNames] 
         * @param {Array<string>} [excludePartNumbers] 
         * @param {Array<number>} [excludePublisherIds] 
         * @param {Array<string>} [excludePublisherNames] 
         * @param {Array<string>} [excludePoolNames] 
         * @param {Array<string>} [excludeOperatingSystemNames] 
         * @param {Array<string>} [excludeLevelNames] 
         * @param {Array<string>} [excludeLanguageNames] 
         * @param {Array<string>} [excludeLicenseAgreementTypeNames] 
         * @param {Array<string>} [excludeLicenseTypeNames] 
         * @param {Array<string>} [excludeProductFamilyNames] 
         * @param {Array<string>} [excludeProductTypeNames] 
         * @param {Array<string>} [excludeProgramNames] 
         * @param {Array<string>} [excludeOfferingNames] 
         * @param {Array<string>} [excludePurchasePeriodNames] 
         * @param {Array<string>} [excludePurchaseUnitNames] 
         * @param {Array<string>} [excludeVersionNames] 
         * @param {Array<string>} [excludeRegionNames] 
         * @param {Array<string>} [excludeProductCategoryNames] 
         * @param {string} [sortKey] 
         * @param {boolean} [includeProductInformation] 
         * @param {'Ascending' | 'Descending'} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(agreementTypeIds?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, page?: number, pageSize?: number, search?: string, priceListId?: number, organizationId?: number, customerTenantId?: number, agreementId?: number, isTrial?: boolean, agreementIds?: Array<number>, searchDate?: Date, includePartNumbers?: Array<string>, includePublisherIds?: Array<number>, includePublisherNames?: Array<string>, includePoolNames?: Array<string>, includeOperatingSystemNames?: Array<string>, includeLevelNames?: Array<string>, includeLanguageNames?: Array<string>, includeLicenseAgreementTypeNames?: Array<string>, includeLicenseTypeNames?: Array<string>, includeProductFamilyNames?: Array<string>, includeProductTypeNames?: Array<string>, includeProgramNames?: Array<string>, includeOfferingNames?: Array<string>, includePurchasePeriodNames?: Array<string>, includePurchaseUnitNames?: Array<string>, includeVersionNames?: Array<string>, includeRegionNames?: Array<string>, includeProductCategoryNames?: Array<string>, excludePartNumbers?: Array<string>, excludePublisherIds?: Array<number>, excludePublisherNames?: Array<string>, excludePoolNames?: Array<string>, excludeOperatingSystemNames?: Array<string>, excludeLevelNames?: Array<string>, excludeLanguageNames?: Array<string>, excludeLicenseAgreementTypeNames?: Array<string>, excludeLicenseTypeNames?: Array<string>, excludeProductFamilyNames?: Array<string>, excludeProductTypeNames?: Array<string>, excludeProgramNames?: Array<string>, excludeOfferingNames?: Array<string>, excludePurchasePeriodNames?: Array<string>, excludePurchaseUnitNames?: Array<string>, excludeVersionNames?: Array<string>, excludeRegionNames?: Array<string>, excludeProductCategoryNames?: Array<string>, sortKey?: string, includeProductInformation?: boolean, sortOrder?: 'Ascending' | 'Descending', options?: any) {
            return AgreementProductsApiFp(configuration).get(agreementTypeIds, page, pageSize, search, priceListId, organizationId, customerTenantId, agreementId, isTrial, agreementIds, searchDate, includePartNumbers, includePublisherIds, includePublisherNames, includePoolNames, includeOperatingSystemNames, includeLevelNames, includeLanguageNames, includeLicenseAgreementTypeNames, includeLicenseTypeNames, includeProductFamilyNames, includeProductTypeNames, includeProgramNames, includeOfferingNames, includePurchasePeriodNames, includePurchaseUnitNames, includeVersionNames, includeRegionNames, includeProductCategoryNames, excludePartNumbers, excludePublisherIds, excludePublisherNames, excludePoolNames, excludeOperatingSystemNames, excludeLevelNames, excludeLanguageNames, excludeLicenseAgreementTypeNames, excludeLicenseTypeNames, excludeProductFamilyNames, excludeProductTypeNames, excludeProgramNames, excludeOfferingNames, excludePurchasePeriodNames, excludePurchaseUnitNames, excludeVersionNames, excludeRegionNames, excludeProductCategoryNames, sortKey, includeProductInformation, sortOrder, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsExcelFile(filter?: AgreementProductFilter, options?: any) {
            return AgreementProductsApiFp(configuration).getAsExcelFile(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AgreementProductFilter} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationSdk133(filter?: AgreementProductFilter, options?: any) {
            return AgreementProductsApiFp(configuration).getOperationSdk133(filter, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} partNumber 
         * @param {number} [resellerCustomerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedBillingCycles(partNumber: string, resellerCustomerId?: number, options?: any) {
            return AgreementProductsApiFp(configuration).getSupportedBillingCycles(partNumber, resellerCustomerId, options)(fetch, basePath);
        },
    };
};

/**
 * AgreementProductsApi - object-oriented interface
 * @export
 * @class AgreementProductsApi
 * @extends {BaseAPI}
 */
export class AgreementProductsApi extends BaseAPI {
    /**
     * 
     * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypeIds] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {number} [priceListId] 
     * @param {number} [organizationId] 
     * @param {number} [customerTenantId] 
     * @param {number} [agreementId] 
     * @param {boolean} [isTrial] 
     * @param {Array<number>} [agreementIds] 
     * @param {Date} [searchDate] 
     * @param {Array<string>} [includePartNumbers] 
     * @param {Array<number>} [includePublisherIds] 
     * @param {Array<string>} [includePublisherNames] 
     * @param {Array<string>} [includePoolNames] 
     * @param {Array<string>} [includeOperatingSystemNames] 
     * @param {Array<string>} [includeLevelNames] 
     * @param {Array<string>} [includeLanguageNames] 
     * @param {Array<string>} [includeLicenseAgreementTypeNames] 
     * @param {Array<string>} [includeLicenseTypeNames] 
     * @param {Array<string>} [includeProductFamilyNames] 
     * @param {Array<string>} [includeProductTypeNames] 
     * @param {Array<string>} [includeProgramNames] 
     * @param {Array<string>} [includeOfferingNames] 
     * @param {Array<string>} [includePurchasePeriodNames] 
     * @param {Array<string>} [includePurchaseUnitNames] 
     * @param {Array<string>} [includeVersionNames] 
     * @param {Array<string>} [includeRegionNames] 
     * @param {Array<string>} [includeProductCategoryNames] 
     * @param {Array<string>} [excludePartNumbers] 
     * @param {Array<number>} [excludePublisherIds] 
     * @param {Array<string>} [excludePublisherNames] 
     * @param {Array<string>} [excludePoolNames] 
     * @param {Array<string>} [excludeOperatingSystemNames] 
     * @param {Array<string>} [excludeLevelNames] 
     * @param {Array<string>} [excludeLanguageNames] 
     * @param {Array<string>} [excludeLicenseAgreementTypeNames] 
     * @param {Array<string>} [excludeLicenseTypeNames] 
     * @param {Array<string>} [excludeProductFamilyNames] 
     * @param {Array<string>} [excludeProductTypeNames] 
     * @param {Array<string>} [excludeProgramNames] 
     * @param {Array<string>} [excludeOfferingNames] 
     * @param {Array<string>} [excludePurchasePeriodNames] 
     * @param {Array<string>} [excludePurchaseUnitNames] 
     * @param {Array<string>} [excludeVersionNames] 
     * @param {Array<string>} [excludeRegionNames] 
     * @param {Array<string>} [excludeProductCategoryNames] 
     * @param {string} [sortKey] 
     * @param {boolean} [includeProductInformation] 
     * @param {'Ascending' | 'Descending'} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementProductsApi
     */
    public get(agreementTypeIds?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, page?: number, pageSize?: number, search?: string, priceListId?: number, organizationId?: number, customerTenantId?: number, agreementId?: number, isTrial?: boolean, agreementIds?: Array<number>, searchDate?: Date, includePartNumbers?: Array<string>, includePublisherIds?: Array<number>, includePublisherNames?: Array<string>, includePoolNames?: Array<string>, includeOperatingSystemNames?: Array<string>, includeLevelNames?: Array<string>, includeLanguageNames?: Array<string>, includeLicenseAgreementTypeNames?: Array<string>, includeLicenseTypeNames?: Array<string>, includeProductFamilyNames?: Array<string>, includeProductTypeNames?: Array<string>, includeProgramNames?: Array<string>, includeOfferingNames?: Array<string>, includePurchasePeriodNames?: Array<string>, includePurchaseUnitNames?: Array<string>, includeVersionNames?: Array<string>, includeRegionNames?: Array<string>, includeProductCategoryNames?: Array<string>, excludePartNumbers?: Array<string>, excludePublisherIds?: Array<number>, excludePublisherNames?: Array<string>, excludePoolNames?: Array<string>, excludeOperatingSystemNames?: Array<string>, excludeLevelNames?: Array<string>, excludeLanguageNames?: Array<string>, excludeLicenseAgreementTypeNames?: Array<string>, excludeLicenseTypeNames?: Array<string>, excludeProductFamilyNames?: Array<string>, excludeProductTypeNames?: Array<string>, excludeProgramNames?: Array<string>, excludeOfferingNames?: Array<string>, excludePurchasePeriodNames?: Array<string>, excludePurchaseUnitNames?: Array<string>, excludeVersionNames?: Array<string>, excludeRegionNames?: Array<string>, excludeProductCategoryNames?: Array<string>, sortKey?: string, includeProductInformation?: boolean, sortOrder?: 'Ascending' | 'Descending', options?: any) {
        return AgreementProductsApiFp(this.configuration).get(agreementTypeIds, page, pageSize, search, priceListId, organizationId, customerTenantId, agreementId, isTrial, agreementIds, searchDate, includePartNumbers, includePublisherIds, includePublisherNames, includePoolNames, includeOperatingSystemNames, includeLevelNames, includeLanguageNames, includeLicenseAgreementTypeNames, includeLicenseTypeNames, includeProductFamilyNames, includeProductTypeNames, includeProgramNames, includeOfferingNames, includePurchasePeriodNames, includePurchaseUnitNames, includeVersionNames, includeRegionNames, includeProductCategoryNames, excludePartNumbers, excludePublisherIds, excludePublisherNames, excludePoolNames, excludeOperatingSystemNames, excludeLevelNames, excludeLanguageNames, excludeLicenseAgreementTypeNames, excludeLicenseTypeNames, excludeProductFamilyNames, excludeProductTypeNames, excludeProgramNames, excludeOfferingNames, excludePurchasePeriodNames, excludePurchaseUnitNames, excludeVersionNames, excludeRegionNames, excludeProductCategoryNames, sortKey, includeProductInformation, sortOrder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AgreementProductFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementProductsApi
     */
    public getAsExcelFile(filter?: AgreementProductFilter, options?: any) {
        return AgreementProductsApiFp(this.configuration).getAsExcelFile(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AgreementProductFilter} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementProductsApi
     */
    public getOperationSdk133(filter?: AgreementProductFilter, options?: any) {
        return AgreementProductsApiFp(this.configuration).getOperationSdk133(filter, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} partNumber 
     * @param {number} [resellerCustomerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementProductsApi
     */
    public getSupportedBillingCycles(partNumber: string, resellerCustomerId?: number, options?: any) {
        return AgreementProductsApiFp(this.configuration).getSupportedBillingCycles(partNumber, resellerCustomerId, options)(this.fetch, this.basePath);
    }

}

/**
 * AgreementReportsApi - fetch parameter creator
 * @export
 */
export const AgreementReportsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} productContainerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(productContainerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productContainerId' is not null or undefined
            if (productContainerId === null || productContainerId === undefined) {
                throw new RequiredError('productContainerId','Required parameter productContainerId was null or undefined when calling get.');
            }
            const localVarPath = `/api/v1/AgreementReports/{productContainerId}`
                .replace(`{${"productContainerId"}}`, encodeURIComponent(String(productContainerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} agreementId 
         * @param {AgreementReport} [agreementReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(agreementId: number, agreementReport?: AgreementReport, options: any = {}): FetchArgs {
            // verify required parameter 'agreementId' is not null or undefined
            if (agreementId === null || agreementId === undefined) {
                throw new RequiredError('agreementId','Required parameter agreementId was null or undefined when calling update.');
            }
            const localVarPath = `/api/v1/AgreementReports/{agreementId}`
                .replace(`{${"agreementId"}}`, encodeURIComponent(String(agreementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AgreementReport" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(agreementReport || {}) : (agreementReport || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgreementReportsApi - functional programming interface
 * @export
 */
export const AgreementReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} productContainerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(productContainerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAgreementReport> {
            const localVarFetchArgs = AgreementReportsApiFetchParamCreator(configuration).get(productContainerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} agreementId 
         * @param {AgreementReport} [agreementReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(agreementId: number, agreementReport?: AgreementReport, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AgreementReport> {
            const localVarFetchArgs = AgreementReportsApiFetchParamCreator(configuration).update(agreementId, agreementReport, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgreementReportsApi - factory interface
 * @export
 */
export const AgreementReportsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} productContainerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(productContainerId: number, options?: any) {
            return AgreementReportsApiFp(configuration).get(productContainerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} agreementId 
         * @param {AgreementReport} [agreementReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(agreementId: number, agreementReport?: AgreementReport, options?: any) {
            return AgreementReportsApiFp(configuration).update(agreementId, agreementReport, options)(fetch, basePath);
        },
    };
};

/**
 * AgreementReportsApi - object-oriented interface
 * @export
 * @class AgreementReportsApi
 * @extends {BaseAPI}
 */
export class AgreementReportsApi extends BaseAPI {
    /**
     * 
     * @param {number} productContainerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementReportsApi
     */
    public get(productContainerId: number, options?: any) {
        return AgreementReportsApiFp(this.configuration).get(productContainerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} agreementId 
     * @param {AgreementReport} [agreementReport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementReportsApi
     */
    public update(agreementId: number, agreementReport?: AgreementReport, options?: any) {
        return AgreementReportsApiFp(this.configuration).update(agreementId, agreementReport, options)(this.fetch, this.basePath);
    }

}

/**
 * AgreementsApi - fetch parameter creator
 * @export
 */
export const AgreementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [organizationId] 
         * @param {Array<number>} [organizationIds] 
         * @param {Array<number>} [pricelistIds] 
         * @param {'None' | 'Active' | 'Inactive' | 'ActiveInactive'} [status] 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypes] 
         * @param {Array<number>} [publisherIds] 
         * @param {Array<number>} [programIds] 
         * @param {Date} [searchDate] 
         * @param {Array<number>} [agreementIds] 
         * @param {string} [salesPriceCurrency] 
         * @param {boolean} [termRequired] 
         * @param {number} [publisherId] 
         * @param {Date} [endDateFrom] 
         * @param {Date} [endDateTo] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, organizationIds?: Array<number>, pricelistIds?: Array<number>, status?: 'None' | 'Active' | 'Inactive' | 'ActiveInactive', agreementTypes?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, publisherIds?: Array<number>, programIds?: Array<number>, searchDate?: Date, agreementIds?: Array<number>, salesPriceCurrency?: string, termRequired?: boolean, publisherId?: number, endDateFrom?: Date, endDateTo?: Date, page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Agreements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (organizationIds) {
                localVarQueryParameter['OrganizationIds'] = organizationIds;
            }

            if (pricelistIds) {
                localVarQueryParameter['PricelistIds'] = pricelistIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (agreementTypes) {
                localVarQueryParameter['AgreementTypes'] = agreementTypes;
            }

            if (publisherIds) {
                localVarQueryParameter['PublisherIds'] = publisherIds;
            }

            if (programIds) {
                localVarQueryParameter['ProgramIds'] = programIds;
            }

            if (searchDate !== undefined) {
                localVarQueryParameter['SearchDate'] = (searchDate as any).toISOString();
            }

            if (agreementIds) {
                localVarQueryParameter['AgreementIds'] = agreementIds;
            }

            if (salesPriceCurrency !== undefined) {
                localVarQueryParameter['SalesPriceCurrency'] = salesPriceCurrency;
            }

            if (termRequired !== undefined) {
                localVarQueryParameter['TermRequired'] = termRequired;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (endDateFrom !== undefined) {
                localVarQueryParameter['EndDateFrom'] = (endDateFrom as any).toISOString();
            }

            if (endDateTo !== undefined) {
                localVarQueryParameter['EndDateTo'] = (endDateTo as any).toISOString();
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgreementsApi - functional programming interface
 * @export
 */
export const AgreementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [organizationId] 
         * @param {Array<number>} [organizationIds] 
         * @param {Array<number>} [pricelistIds] 
         * @param {'None' | 'Active' | 'Inactive' | 'ActiveInactive'} [status] 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypes] 
         * @param {Array<number>} [publisherIds] 
         * @param {Array<number>} [programIds] 
         * @param {Date} [searchDate] 
         * @param {Array<number>} [agreementIds] 
         * @param {string} [salesPriceCurrency] 
         * @param {boolean} [termRequired] 
         * @param {number} [publisherId] 
         * @param {Date} [endDateFrom] 
         * @param {Date} [endDateTo] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, organizationIds?: Array<number>, pricelistIds?: Array<number>, status?: 'None' | 'Active' | 'Inactive' | 'ActiveInactive', agreementTypes?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, publisherIds?: Array<number>, programIds?: Array<number>, searchDate?: Date, agreementIds?: Array<number>, salesPriceCurrency?: string, termRequired?: boolean, publisherId?: number, endDateFrom?: Date, endDateTo?: Date, page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AgreementCollection> {
            const localVarFetchArgs = AgreementsApiFetchParamCreator(configuration).get(organizationId, organizationIds, pricelistIds, status, agreementTypes, publisherIds, programIds, searchDate, agreementIds, salesPriceCurrency, termRequired, publisherId, endDateFrom, endDateTo, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgreementsApi - factory interface
 * @export
 */
export const AgreementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [organizationId] 
         * @param {Array<number>} [organizationIds] 
         * @param {Array<number>} [pricelistIds] 
         * @param {'None' | 'Active' | 'Inactive' | 'ActiveInactive'} [status] 
         * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypes] 
         * @param {Array<number>} [publisherIds] 
         * @param {Array<number>} [programIds] 
         * @param {Date} [searchDate] 
         * @param {Array<number>} [agreementIds] 
         * @param {string} [salesPriceCurrency] 
         * @param {boolean} [termRequired] 
         * @param {number} [publisherId] 
         * @param {Date} [endDateFrom] 
         * @param {Date} [endDateTo] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, organizationIds?: Array<number>, pricelistIds?: Array<number>, status?: 'None' | 'Active' | 'Inactive' | 'ActiveInactive', agreementTypes?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, publisherIds?: Array<number>, programIds?: Array<number>, searchDate?: Date, agreementIds?: Array<number>, salesPriceCurrency?: string, termRequired?: boolean, publisherId?: number, endDateFrom?: Date, endDateTo?: Date, page?: number, pageSize?: number, search?: string, options?: any) {
            return AgreementsApiFp(configuration).get(organizationId, organizationIds, pricelistIds, status, agreementTypes, publisherIds, programIds, searchDate, agreementIds, salesPriceCurrency, termRequired, publisherId, endDateFrom, endDateTo, page, pageSize, search, options)(fetch, basePath);
        },
    };
};

/**
 * AgreementsApi - object-oriented interface
 * @export
 * @class AgreementsApi
 * @extends {BaseAPI}
 */
export class AgreementsApi extends BaseAPI {
    /**
     * 
     * @param {number} [organizationId] 
     * @param {Array<number>} [organizationIds] 
     * @param {Array<number>} [pricelistIds] 
     * @param {'None' | 'Active' | 'Inactive' | 'ActiveInactive'} [status] 
     * @param {Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>} [agreementTypes] 
     * @param {Array<number>} [publisherIds] 
     * @param {Array<number>} [programIds] 
     * @param {Date} [searchDate] 
     * @param {Array<number>} [agreementIds] 
     * @param {string} [salesPriceCurrency] 
     * @param {boolean} [termRequired] 
     * @param {number} [publisherId] 
     * @param {Date} [endDateFrom] 
     * @param {Date} [endDateTo] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgreementsApi
     */
    public get(organizationId?: number, organizationIds?: Array<number>, pricelistIds?: Array<number>, status?: 'None' | 'Active' | 'Inactive' | 'ActiveInactive', agreementTypes?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, publisherIds?: Array<number>, programIds?: Array<number>, searchDate?: Date, agreementIds?: Array<number>, salesPriceCurrency?: string, termRequired?: boolean, publisherId?: number, endDateFrom?: Date, endDateTo?: Date, page?: number, pageSize?: number, search?: string, options?: any) {
        return AgreementsApiFp(this.configuration).get(organizationId, organizationIds, pricelistIds, status, agreementTypes, publisherIds, programIds, searchDate, agreementIds, salesPriceCurrency, termRequired, publisherId, endDateFrom, endDateTo, page, pageSize, search, options)(this.fetch, this.basePath);
    }

}

/**
 * AssetsApi - fetch parameter creator
 * @export
 */
export const AssetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: AssetOrder, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Assets/checkout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (resellerCustomerId !== undefined) {
                localVarQueryParameter['ResellerCustomerId'] = resellerCustomerId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (externalOrderId !== undefined) {
                localVarQueryParameter['ExternalOrderId'] = externalOrderId;
            }

            if (externalOrderIds) {
                localVarQueryParameter['ExternalOrderIds'] = externalOrderIds;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['ReservationId'] = reservationId;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['AssetType'] = assetType;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetOrdersAsync(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Assets/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (resellerCustomerId !== undefined) {
                localVarQueryParameter['ResellerCustomerId'] = resellerCustomerId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (externalOrderId !== undefined) {
                localVarQueryParameter['ExternalOrderId'] = externalOrderId;
            }

            if (externalOrderIds) {
                localVarQueryParameter['ExternalOrderIds'] = externalOrderIds;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['ReservationId'] = reservationId;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['AssetType'] = assetType;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAsync(order?: AssetOrder, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Assets/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: AssetOrder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).checkoutAsync(order, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAsset> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).get(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetOrdersAsync(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAssetOrder> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).getAssetOrdersAsync(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAsync(order?: AssetOrder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetOrder> {
            const localVarFetchArgs = AssetsApiFetchParamCreator(configuration).verifyAsync(order, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: AssetOrder, options?: any) {
            return AssetsApiFp(configuration).checkoutAsync(order, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any) {
            return AssetsApiFp(configuration).get(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [resellerCustomerId] 
         * @param {number} [publisherId] 
         * @param {string} [externalOrderId] 
         * @param {Array<string>} [externalOrderIds] 
         * @param {string} [reservationId] 
         * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
         * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetOrdersAsync(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any) {
            return AssetsApiFp(configuration).getAssetOrdersAsync(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AssetOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAsync(order?: AssetOrder, options?: any) {
            return AssetsApiFp(configuration).verifyAsync(order, options)(fetch, basePath);
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @param {AssetOrder} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public checkoutAsync(order?: AssetOrder, options?: any) {
        return AssetsApiFp(this.configuration).checkoutAsync(order, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [resellerCustomerId] 
     * @param {number} [publisherId] 
     * @param {string} [externalOrderId] 
     * @param {Array<string>} [externalOrderIds] 
     * @param {string} [reservationId] 
     * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
     * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public get(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any) {
        return AssetsApiFp(this.configuration).get(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [resellerCustomerId] 
     * @param {number} [publisherId] 
     * @param {string} [externalOrderId] 
     * @param {Array<string>} [externalOrderIds] 
     * @param {string} [reservationId] 
     * @param {'Reservation' | 'Software' | 'Subscription'} [assetType] 
     * @param {'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'} [status] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAssetOrdersAsync(resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options?: any) {
        return AssetsApiFp(this.configuration).getAssetOrdersAsync(resellerCustomerId, publisherId, externalOrderId, externalOrderIds, reservationId, assetType, status, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AssetOrder} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public verifyAsync(order?: AssetOrder, options?: any) {
        return AssetsApiFp(this.configuration).verifyAsync(order, options)(this.fetch, this.basePath);
    }

}

/**
 * AwsAccountsApi - fetch parameter creator
 * @export
 */
export const AwsAccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccountById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAwsAccountById.');
            }
            const localVarPath = `/api/v1/AwsAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/AwsAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (consumerId !== undefined) {
                localVarQueryParameter['ConsumerId'] = consumerId;
            }

            if (customerTenantType !== undefined) {
                localVarQueryParameter['CustomerTenantType'] = customerTenantType;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {AwsAccount} [awsAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, awsAccount?: AwsAccount, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/AwsAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AwsAccount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(awsAccount || {}) : (awsAccount || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AwsAccountsApi - functional programming interface
 * @export
 */
export const AwsAccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccountById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AwsAccount> {
            const localVarFetchArgs = AwsAccountsApiFetchParamCreator(configuration).getAwsAccountById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAwsAccount> {
            const localVarFetchArgs = AwsAccountsApiFetchParamCreator(configuration).getAwsAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {AwsAccount} [awsAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, awsAccount?: AwsAccount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AwsAccount> {
            const localVarFetchArgs = AwsAccountsApiFetchParamCreator(configuration).put(id, awsAccount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AwsAccountsApi - factory interface
 * @export
 */
export const AwsAccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccountById(id: number, options?: any) {
            return AwsAccountsApiFp(configuration).getAwsAccountById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAwsAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any) {
            return AwsAccountsApiFp(configuration).getAwsAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {AwsAccount} [awsAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, awsAccount?: AwsAccount, options?: any) {
            return AwsAccountsApiFp(configuration).put(id, awsAccount, options)(fetch, basePath);
        },
    };
};

/**
 * AwsAccountsApi - object-oriented interface
 * @export
 * @class AwsAccountsApi
 * @extends {BaseAPI}
 */
export class AwsAccountsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AwsAccountsApi
     */
    public getAwsAccountById(id: number, options?: any) {
        return AwsAccountsApiFp(this.configuration).getAwsAccountById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {number} [publisherId] 
     * @param {number} [consumerId] 
     * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AwsAccountsApi
     */
    public getAwsAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any) {
        return AwsAccountsApiFp(this.configuration).getAwsAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {AwsAccount} [awsAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AwsAccountsApi
     */
    public put(id: number, awsAccount?: AwsAccount, options?: any) {
        return AwsAccountsApiFp(this.configuration).put(id, awsAccount, options)(this.fetch, this.basePath);
    }

}

/**
 * AzurePlansApi - fetch parameter creator
 * @export
 */
export const AzurePlansApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} azurePlanId 
         * @param {CreateAzureSubscriptionRequest} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(azurePlanId: number, requestBody?: CreateAzureSubscriptionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'azurePlanId' is not null or undefined
            if (azurePlanId === null || azurePlanId === undefined) {
                throw new RequiredError('azurePlanId','Required parameter azurePlanId was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions`
                .replace(`{${"azurePlanId"}}`, encodeURIComponent(String(azurePlanId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAzureSubscriptionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionById(azurePlanId: number, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'azurePlanId' is not null or undefined
            if (azurePlanId === null || azurePlanId === undefined) {
                throw new RequiredError('azurePlanId','Required parameter azurePlanId was null or undefined when calling getSubscriptionById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSubscriptionById.');
            }
            const localVarPath = `/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions/{id}`
                .replace(`{${"azurePlanId"}}`, encodeURIComponent(String(azurePlanId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(azurePlanId: number, search?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'azurePlanId' is not null or undefined
            if (azurePlanId === null || azurePlanId === undefined) {
                throw new RequiredError('azurePlanId','Required parameter azurePlanId was null or undefined when calling getSubscriptions.');
            }
            const localVarPath = `/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions`
                .replace(`{${"azurePlanId"}}`, encodeURIComponent(String(azurePlanId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {PutAzureSubscription} [azureSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(azurePlanId: number, id: number, azureSubscription?: PutAzureSubscription, options: any = {}): FetchArgs {
            // verify required parameter 'azurePlanId' is not null or undefined
            if (azurePlanId === null || azurePlanId === undefined) {
                throw new RequiredError('azurePlanId','Required parameter azurePlanId was null or undefined when calling updateSubscription.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSubscription.');
            }
            const localVarPath = `/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions/{id}`
                .replace(`{${"azurePlanId"}}`, encodeURIComponent(String(azurePlanId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PutAzureSubscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(azureSubscription || {}) : (azureSubscription || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AzurePlansApi - functional programming interface
 * @export
 */
export const AzurePlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} azurePlanId 
         * @param {CreateAzureSubscriptionRequest} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(azurePlanId: number, requestBody?: CreateAzureSubscriptionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AzurePlansApiFetchParamCreator(configuration).createSubscription(azurePlanId, requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionById(azurePlanId: number, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AzureSubscription> {
            const localVarFetchArgs = AzurePlansApiFetchParamCreator(configuration).getSubscriptionById(azurePlanId, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(azurePlanId: number, search?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfAzureSubscription> {
            const localVarFetchArgs = AzurePlansApiFetchParamCreator(configuration).getSubscriptions(azurePlanId, search, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {PutAzureSubscription} [azureSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(azurePlanId: number, id: number, azureSubscription?: PutAzureSubscription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AzureSubscription> {
            const localVarFetchArgs = AzurePlansApiFetchParamCreator(configuration).updateSubscription(azurePlanId, id, azureSubscription, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AzurePlansApi - factory interface
 * @export
 */
export const AzurePlansApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} azurePlanId 
         * @param {CreateAzureSubscriptionRequest} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(azurePlanId: number, requestBody?: CreateAzureSubscriptionRequest, options?: any) {
            return AzurePlansApiFp(configuration).createSubscription(azurePlanId, requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionById(azurePlanId: number, id: number, options?: any) {
            return AzurePlansApiFp(configuration).getSubscriptionById(azurePlanId, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(azurePlanId: number, search?: string, page?: number, pageSize?: number, options?: any) {
            return AzurePlansApiFp(configuration).getSubscriptions(azurePlanId, search, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} azurePlanId 
         * @param {number} id 
         * @param {PutAzureSubscription} [azureSubscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(azurePlanId: number, id: number, azureSubscription?: PutAzureSubscription, options?: any) {
            return AzurePlansApiFp(configuration).updateSubscription(azurePlanId, id, azureSubscription, options)(fetch, basePath);
        },
    };
};

/**
 * AzurePlansApi - object-oriented interface
 * @export
 * @class AzurePlansApi
 * @extends {BaseAPI}
 */
export class AzurePlansApi extends BaseAPI {
    /**
     * 
     * @param {number} azurePlanId 
     * @param {CreateAzureSubscriptionRequest} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzurePlansApi
     */
    public createSubscription(azurePlanId: number, requestBody?: CreateAzureSubscriptionRequest, options?: any) {
        return AzurePlansApiFp(this.configuration).createSubscription(azurePlanId, requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} azurePlanId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzurePlansApi
     */
    public getSubscriptionById(azurePlanId: number, id: number, options?: any) {
        return AzurePlansApiFp(this.configuration).getSubscriptionById(azurePlanId, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} azurePlanId 
     * @param {string} [search] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzurePlansApi
     */
    public getSubscriptions(azurePlanId: number, search?: string, page?: number, pageSize?: number, options?: any) {
        return AzurePlansApiFp(this.configuration).getSubscriptions(azurePlanId, search, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} azurePlanId 
     * @param {number} id 
     * @param {PutAzureSubscription} [azureSubscription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzurePlansApi
     */
    public updateSubscription(azurePlanId: number, id: number, azureSubscription?: PutAzureSubscription, options?: any) {
        return AzurePlansApiFp(this.configuration).updateSubscription(azurePlanId, id, azureSubscription, options)(this.fetch, this.basePath);
    }

}

/**
 * BillingCyclesApi - fetch parameter creator
 * @export
 */
export const BillingCyclesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [includeUnknown] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingCycles(includeUnknown?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/BillingCycles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (includeUnknown !== undefined) {
                localVarQueryParameter['includeUnknown'] = includeUnknown;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProductVariantId(productVariantId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productVariantId' is not null or undefined
            if (productVariantId === null || productVariantId === undefined) {
                throw new RequiredError('productVariantId','Required parameter productVariantId was null or undefined when calling getByProductVariantId.');
            }
            const localVarPath = `/api/v1/BillingCycles/productVariant/{productVariantId}`
                .replace(`{${"productVariantId"}}`, encodeURIComponent(String(productVariantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCspNameDictionary(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/BillingCycles/cspNameDictionary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingCyclesApi - functional programming interface
 * @export
 */
export const BillingCyclesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [includeUnknown] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingCycles(includeUnknown?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfBillingCycle> {
            const localVarFetchArgs = BillingCyclesApiFetchParamCreator(configuration).getAllBillingCycles(includeUnknown, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProductVariantId(productVariantId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfBillingCycle> {
            const localVarFetchArgs = BillingCyclesApiFetchParamCreator(configuration).getByProductVariantId(productVariantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCspNameDictionary(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
            const localVarFetchArgs = BillingCyclesApiFetchParamCreator(configuration).getCspNameDictionary(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BillingCyclesApi - factory interface
 * @export
 */
export const BillingCyclesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {boolean} [includeUnknown] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBillingCycles(includeUnknown?: boolean, options?: any) {
            return BillingCyclesApiFp(configuration).getAllBillingCycles(includeUnknown, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProductVariantId(productVariantId: number, options?: any) {
            return BillingCyclesApiFp(configuration).getByProductVariantId(productVariantId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCspNameDictionary(options?: any) {
            return BillingCyclesApiFp(configuration).getCspNameDictionary(options)(fetch, basePath);
        },
    };
};

/**
 * BillingCyclesApi - object-oriented interface
 * @export
 * @class BillingCyclesApi
 * @extends {BaseAPI}
 */
export class BillingCyclesApi extends BaseAPI {
    /**
     * 
     * @param {boolean} [includeUnknown] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCyclesApi
     */
    public getAllBillingCycles(includeUnknown?: boolean, options?: any) {
        return BillingCyclesApiFp(this.configuration).getAllBillingCycles(includeUnknown, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} productVariantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCyclesApi
     */
    public getByProductVariantId(productVariantId: number, options?: any) {
        return BillingCyclesApiFp(this.configuration).getByProductVariantId(productVariantId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingCyclesApi
     */
    public getCspNameDictionary(options?: any) {
        return BillingCyclesApiFp(this.configuration).getCspNameDictionary(options)(this.fetch, this.basePath);
    }

}

/**
 * BillingStatementsApi - fetch parameter creator
 * @export
 */
export const BillingStatementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingRecordsFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBillingRecordsFile.');
            }
            const localVarPath = `/api/v1/BillingStatements/{id}/billingrecordsfile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatementFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getBillingStatementFile.');
            }
            const localVarPath = `/api/v1/BillingStatements/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/BillingStatements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (invoiceProfileId !== undefined) {
                localVarQueryParameter['InvoiceProfileId'] = invoiceProfileId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (provisionType !== undefined) {
                localVarQueryParameter['ProvisionType'] = provisionType;
            }

            if (from !== undefined) {
                localVarQueryParameter['From'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = (to as any).toISOString();
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/BillingStatements/grouped`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (invoiceProfileId !== undefined) {
                localVarQueryParameter['InvoiceProfileId'] = invoiceProfileId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (provisionType !== undefined) {
                localVarQueryParameter['ProvisionType'] = provisionType;
            }

            if (from !== undefined) {
                localVarQueryParameter['From'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = (to as any).toISOString();
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReconciliationFile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getReconciliationFile.');
            }
            const localVarPath = `/api/v1/BillingStatements/{id}/reconciliationfile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingStatementsApi - functional programming interface
 * @export
 */
export const BillingStatementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingRecordsFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BillingStatementsApiFetchParamCreator(configuration).getBillingRecordsFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatementFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BillingStatementsApiFetchParamCreator(configuration).getBillingStatementFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfBillingStatement> {
            const localVarFetchArgs = BillingStatementsApiFetchParamCreator(configuration).getBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfGroupedBillingStatement> {
            const localVarFetchArgs = BillingStatementsApiFetchParamCreator(configuration).getGroupedBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReconciliationFile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BillingStatementsApiFetchParamCreator(configuration).getReconciliationFile(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BillingStatementsApi - factory interface
 * @export
 */
export const BillingStatementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingRecordsFile(id: number, options?: any) {
            return BillingStatementsApiFp(configuration).getBillingRecordsFile(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatementFile(id: number, options?: any) {
            return BillingStatementsApiFp(configuration).getBillingStatementFile(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
            return BillingStatementsApiFp(configuration).getBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [invoiceProfileId] 
         * @param {number} [organizationId] 
         * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
            return BillingStatementsApiFp(configuration).getGroupedBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReconciliationFile(id: number, options?: any) {
            return BillingStatementsApiFp(configuration).getReconciliationFile(id, options)(fetch, basePath);
        },
    };
};

/**
 * BillingStatementsApi - object-oriented interface
 * @export
 * @class BillingStatementsApi
 * @extends {BaseAPI}
 */
export class BillingStatementsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingStatementsApi
     */
    public getBillingRecordsFile(id: number, options?: any) {
        return BillingStatementsApiFp(this.configuration).getBillingRecordsFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingStatementsApi
     */
    public getBillingStatementFile(id: number, options?: any) {
        return BillingStatementsApiFp(this.configuration).getBillingStatementFile(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [invoiceProfileId] 
     * @param {number} [organizationId] 
     * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingStatementsApi
     */
    public getBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
        return BillingStatementsApiFp(this.configuration).getBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [invoiceProfileId] 
     * @param {number} [organizationId] 
     * @param {'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'} [provisionType] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingStatementsApi
     */
    public getGroupedBillingStatements(invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options?: any) {
        return BillingStatementsApiFp(this.configuration).getGroupedBillingStatements(invoiceProfileId, organizationId, provisionType, from, to, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingStatementsApi
     */
    public getReconciliationFile(id: number, options?: any) {
        return BillingStatementsApiFp(this.configuration).getReconciliationFile(id, options)(this.fetch, this.basePath);
    }

}

/**
 * BlogItemsApi - fetch parameter creator
 * @export
 */
export const BlogItemsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForDirectCustomers(count?: number, organizationId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/BlogItems`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogItemsApi - functional programming interface
 * @export
 */
export const BlogItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForDirectCustomers(count?: number, organizationId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfBlogItem> {
            const localVarFetchArgs = BlogItemsApiFetchParamCreator(configuration).getForDirectCustomers(count, organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BlogItemsApi - factory interface
 * @export
 */
export const BlogItemsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [count] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForDirectCustomers(count?: number, organizationId?: number, options?: any) {
            return BlogItemsApiFp(configuration).getForDirectCustomers(count, organizationId, options)(fetch, basePath);
        },
    };
};

/**
 * BlogItemsApi - object-oriented interface
 * @export
 * @class BlogItemsApi
 * @extends {BaseAPI}
 */
export class BlogItemsApi extends BaseAPI {
    /**
     * 
     * @param {number} [count] 
     * @param {number} [organizationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogItemsApi
     */
    public getForDirectCustomers(count?: number, organizationId?: number, options?: any) {
        return BlogItemsApiFp(this.configuration).getForDirectCustomers(count, organizationId, options)(this.fetch, this.basePath);
    }

}

/**
 * ClientsApi - fetch parameter creator
 * @export
 */
export const ClientsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/v1/Clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Clients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(clientId: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/Clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(client?: Client, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Clients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Client" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(client || {}) : (client || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clientId 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(clientId: string, client?: Client, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/Clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Client" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(client || {}) : (client || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ClientsApiFetchParamCreator(configuration)._delete(clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfClient> {
            const localVarFetchArgs = ClientsApiFetchParamCreator(configuration).get(page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(clientId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Client> {
            const localVarFetchArgs = ClientsApiFetchParamCreator(configuration).getById(clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(client?: Client, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Client> {
            const localVarFetchArgs = ClientsApiFetchParamCreator(configuration).post(client, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} clientId 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(clientId: string, client?: Client, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Client> {
            const localVarFetchArgs = ClientsApiFetchParamCreator(configuration).put(clientId, client, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId: string, options?: any) {
            return ClientsApiFp(configuration)._delete(clientId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options?: any) {
            return ClientsApiFp(configuration).get(page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} clientId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(clientId: string, options?: any) {
            return ClientsApiFp(configuration).getById(clientId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(client?: Client, options?: any) {
            return ClientsApiFp(configuration).post(client, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} clientId 
         * @param {Client} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(clientId: string, client?: Client, options?: any) {
            return ClientsApiFp(configuration).put(clientId, client, options)(fetch, basePath);
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public _delete(clientId: string, options?: any) {
        return ClientsApiFp(this.configuration)._delete(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public get(page?: number, pageSize?: number, search?: string, options?: any) {
        return ClientsApiFp(this.configuration).get(page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} clientId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public getById(clientId: string, options?: any) {
        return ClientsApiFp(this.configuration).getById(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Client} [client] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public post(client?: Client, options?: any) {
        return ClientsApiFp(this.configuration).post(client, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} clientId 
     * @param {Client} [client] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public put(clientId: string, client?: Client, options?: any) {
        return ClientsApiFp(this.configuration).put(clientId, client, options)(this.fetch, this.basePath);
    }

}

/**
 * ConsumersApi - fetch parameter creator
 * @export
 */
export const ConsumersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConsumer(consumer?: Consumer, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Consumers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Consumer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(consumer || {}) : (consumer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsumer(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteConsumer.');
            }
            const localVarPath = `/api/v1/Consumers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Consumers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsumerById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getConsumerById.');
            }
            const localVarPath = `/api/v1/Consumers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsumer(id: number, consumer?: Consumer, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateConsumer.');
            }
            const localVarPath = `/api/v1/Consumers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Consumer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(consumer || {}) : (consumer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsumersApi - functional programming interface
 * @export
 */
export const ConsumersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConsumer(consumer?: Consumer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Consumer> {
            const localVarFetchArgs = ConsumersApiFetchParamCreator(configuration).addConsumer(consumer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsumer(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ConsumersApiFetchParamCreator(configuration).deleteConsumer(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfConsumer> {
            const localVarFetchArgs = ConsumersApiFetchParamCreator(configuration).get(organizationId, search, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsumerById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Consumer> {
            const localVarFetchArgs = ConsumersApiFetchParamCreator(configuration).getConsumerById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsumer(id: number, consumer?: Consumer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Consumer> {
            const localVarFetchArgs = ConsumersApiFetchParamCreator(configuration).updateConsumer(id, consumer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConsumersApi - factory interface
 * @export
 */
export const ConsumersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addConsumer(consumer?: Consumer, options?: any) {
            return ConsumersApiFp(configuration).addConsumer(consumer, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConsumer(id: number, options?: any) {
            return ConsumersApiFp(configuration).deleteConsumer(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, options?: any) {
            return ConsumersApiFp(configuration).get(organizationId, search, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsumerById(id: number, options?: any) {
            return ConsumersApiFp(configuration).getConsumerById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Consumer} [consumer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsumer(id: number, consumer?: Consumer, options?: any) {
            return ConsumersApiFp(configuration).updateConsumer(id, consumer, options)(fetch, basePath);
        },
    };
};

/**
 * ConsumersApi - object-oriented interface
 * @export
 * @class ConsumersApi
 * @extends {BaseAPI}
 */
export class ConsumersApi extends BaseAPI {
    /**
     * 
     * @param {Consumer} [consumer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumersApi
     */
    public addConsumer(consumer?: Consumer, options?: any) {
        return ConsumersApiFp(this.configuration).addConsumer(consumer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumersApi
     */
    public deleteConsumer(id: number, options?: any) {
        return ConsumersApiFp(this.configuration).deleteConsumer(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {string} [search] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumersApi
     */
    public get(organizationId?: number, search?: string, page?: number, pageSize?: number, options?: any) {
        return ConsumersApiFp(this.configuration).get(organizationId, search, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumersApi
     */
    public getConsumerById(id: number, options?: any) {
        return ConsumersApiFp(this.configuration).getConsumerById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {Consumer} [consumer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsumersApi
     */
    public updateConsumer(id: number, consumer?: Consumer, options?: any) {
        return ConsumersApiFp(this.configuration).updateConsumer(id, consumer, options)(this.fetch, this.basePath);
    }

}

/**
 * CrayonAccountsApi - fetch parameter creator
 * @export
 */
export const CrayonAccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccountById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCrayonAccountById.');
            }
            const localVarPath = `/api/v1/CrayonAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/CrayonAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (consumerId !== undefined) {
                localVarQueryParameter['ConsumerId'] = consumerId;
            }

            if (customerTenantType !== undefined) {
                localVarQueryParameter['CustomerTenantType'] = customerTenantType;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(crayonAccount?: CrayonAccount, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/CrayonAccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CrayonAccount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(crayonAccount || {}) : (crayonAccount || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, crayonAccount?: CrayonAccount, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/CrayonAccounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CrayonAccount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(crayonAccount || {}) : (crayonAccount || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrayonAccountsApi - functional programming interface
 * @export
 */
export const CrayonAccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccountById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrayonAccount> {
            const localVarFetchArgs = CrayonAccountsApiFetchParamCreator(configuration).getCrayonAccountById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfCrayonAccount> {
            const localVarFetchArgs = CrayonAccountsApiFetchParamCreator(configuration).getCrayonAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(crayonAccount?: CrayonAccount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrayonAccount> {
            const localVarFetchArgs = CrayonAccountsApiFetchParamCreator(configuration).post(crayonAccount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, crayonAccount?: CrayonAccount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrayonAccount> {
            const localVarFetchArgs = CrayonAccountsApiFetchParamCreator(configuration).put(id, crayonAccount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CrayonAccountsApi - factory interface
 * @export
 */
export const CrayonAccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccountById(id: number, options?: any) {
            return CrayonAccountsApiFp(configuration).getCrayonAccountById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [consumerId] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrayonAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any) {
            return CrayonAccountsApiFp(configuration).getCrayonAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(crayonAccount?: CrayonAccount, options?: any) {
            return CrayonAccountsApiFp(configuration).post(crayonAccount, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CrayonAccount} [crayonAccount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, crayonAccount?: CrayonAccount, options?: any) {
            return CrayonAccountsApiFp(configuration).put(id, crayonAccount, options)(fetch, basePath);
        },
    };
};

/**
 * CrayonAccountsApi - object-oriented interface
 * @export
 * @class CrayonAccountsApi
 * @extends {BaseAPI}
 */
export class CrayonAccountsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrayonAccountsApi
     */
    public getCrayonAccountById(id: number, options?: any) {
        return CrayonAccountsApiFp(this.configuration).getCrayonAccountById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {number} [publisherId] 
     * @param {number} [consumerId] 
     * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrayonAccountsApi
     */
    public getCrayonAccounts(organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options?: any) {
        return CrayonAccountsApiFp(this.configuration).getCrayonAccounts(organizationId, publisherId, consumerId, customerTenantType, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CrayonAccount} [crayonAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrayonAccountsApi
     */
    public post(crayonAccount?: CrayonAccount, options?: any) {
        return CrayonAccountsApiFp(this.configuration).post(crayonAccount, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {CrayonAccount} [crayonAccount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrayonAccountsApi
     */
    public put(id: number, crayonAccount?: CrayonAccount, options?: any) {
        return CrayonAccountsApiFp(this.configuration).put(id, crayonAccount, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerTenantAgreementsApi - fetch parameter creator
 * @export
 */
export const CustomerTenantAgreementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} customerTenantId 
         * @param {ServiceAccountAgreement} [agreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(customerTenantId: number, agreement?: ServiceAccountAgreement, options: any = {}): FetchArgs {
            // verify required parameter 'customerTenantId' is not null or undefined
            if (customerTenantId === null || customerTenantId === undefined) {
                throw new RequiredError('customerTenantId','Required parameter customerTenantId was null or undefined when calling add.');
            }
            const localVarPath = `/api/v1/customertenants/{customerTenantId}/agreements`
                .replace(`{${"customerTenantId"}}`, encodeURIComponent(String(customerTenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ServiceAccountAgreement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(agreement || {}) : (agreement || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement'} [agreementTypeConsent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(customerTenantId: number, agreementTypeConsent?: 'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement', options: any = {}): FetchArgs {
            // verify required parameter 'customerTenantId' is not null or undefined
            if (customerTenantId === null || customerTenantId === undefined) {
                throw new RequiredError('customerTenantId','Required parameter customerTenantId was null or undefined when calling get.');
            }
            const localVarPath = `/api/v1/customertenants/{customerTenantId}/agreements`
                .replace(`{${"customerTenantId"}}`, encodeURIComponent(String(customerTenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (agreementTypeConsent !== undefined) {
                localVarQueryParameter['AgreementTypeConsent'] = agreementTypeConsent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerTenantAgreementsApi - functional programming interface
 * @export
 */
export const CustomerTenantAgreementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} customerTenantId 
         * @param {ServiceAccountAgreement} [agreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(customerTenantId: number, agreement?: ServiceAccountAgreement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServiceAccountAgreement> {
            const localVarFetchArgs = CustomerTenantAgreementsApiFetchParamCreator(configuration).add(customerTenantId, agreement, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement'} [agreementTypeConsent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(customerTenantId: number, agreementTypeConsent?: 'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfServiceAccountAgreement> {
            const localVarFetchArgs = CustomerTenantAgreementsApiFetchParamCreator(configuration).get(customerTenantId, agreementTypeConsent, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerTenantAgreementsApi - factory interface
 * @export
 */
export const CustomerTenantAgreementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} customerTenantId 
         * @param {ServiceAccountAgreement} [agreement] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(customerTenantId: number, agreement?: ServiceAccountAgreement, options?: any) {
            return CustomerTenantAgreementsApiFp(configuration).add(customerTenantId, agreement, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement'} [agreementTypeConsent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(customerTenantId: number, agreementTypeConsent?: 'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement', options?: any) {
            return CustomerTenantAgreementsApiFp(configuration).get(customerTenantId, agreementTypeConsent, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerTenantAgreementsApi - object-oriented interface
 * @export
 * @class CustomerTenantAgreementsApi
 * @extends {BaseAPI}
 */
export class CustomerTenantAgreementsApi extends BaseAPI {
    /**
     * 
     * @param {number} customerTenantId 
     * @param {ServiceAccountAgreement} [agreement] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantAgreementsApi
     */
    public add(customerTenantId: number, agreement?: ServiceAccountAgreement, options?: any) {
        return CustomerTenantAgreementsApiFp(this.configuration).add(customerTenantId, agreement, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} customerTenantId 
     * @param {'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement'} [agreementTypeConsent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantAgreementsApi
     */
    public get(customerTenantId: number, agreementTypeConsent?: 'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement', options?: any) {
        return CustomerTenantAgreementsApiFp(this.configuration).get(customerTenantId, agreementTypeConsent, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerTenantsApi - fetch parameter creator
 * @export
 */
export const CustomerTenantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerTenantDetailed} [existingTenant] 
         * @param {boolean} [syncFromPublisher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExisting(existingTenant?: CustomerTenantDetailed, syncFromPublisher?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/CustomerTenants/existing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (syncFromPublisher !== undefined) {
                localVarQueryParameter['syncFromPublisher'] = syncFromPublisher;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerTenantDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(existingTenant || {}) : (existingTenant || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCustomerById.');
            }
            const localVarPath = `/api/v1/CustomerTenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [programId] 
         * @param {number} [consumerId] 
         * @param {string} [domain] 
         * @param {string} [domainPrefix] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [invoiceProfileId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, publisherId?: number, programId?: number, consumerId?: number, domain?: string, domainPrefix?: string, customerTenantType?: 'None' | 'T1' | 'T2', invoiceProfileId?: number, page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/CustomerTenants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (programId !== undefined) {
                localVarQueryParameter['ProgramId'] = programId;
            }

            if (consumerId !== undefined) {
                localVarQueryParameter['ConsumerId'] = consumerId;
            }

            if (domain !== undefined) {
                localVarQueryParameter['Domain'] = domain;
            }

            if (domainPrefix !== undefined) {
                localVarQueryParameter['DomainPrefix'] = domainPrefix;
            }

            if (customerTenantType !== undefined) {
                localVarQueryParameter['CustomerTenantType'] = customerTenantType;
            }

            if (invoiceProfileId !== undefined) {
                localVarQueryParameter['InvoiceProfileId'] = invoiceProfileId;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzurePlan(customerTenantId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerTenantId' is not null or undefined
            if (customerTenantId === null || customerTenantId === undefined) {
                throw new RequiredError('customerTenantId','Required parameter customerTenantId was null or undefined when calling getAzurePlan.');
            }
            const localVarPath = `/api/v1/CustomerTenants/{customerTenantId}/azurePlan`
                .replace(`{${"customerTenantId"}}`, encodeURIComponent(String(customerTenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCustomerTenantById.');
            }
            const localVarPath = `/api/v1/CustomerTenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantDetailedById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCustomerTenantDetailedById.');
            }
            const localVarPath = `/api/v1/CustomerTenants/{id}/detailed`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(customerTenant?: CustomerTenantDetailed, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/CustomerTenants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerTenantDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerTenant || {}) : (customerTenant || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, customerTenant?: CustomerTenantDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/CustomerTenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerTenantDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerTenant || {}) : (customerTenant || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerTenantsApi - functional programming interface
 * @export
 */
export const CustomerTenantsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerTenantDetailed} [existingTenant] 
         * @param {boolean} [syncFromPublisher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExisting(existingTenant?: CustomerTenantDetailed, syncFromPublisher?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerTenantDetailed> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).addExisting(existingTenant, syncFromPublisher, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).deleteCustomerById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [programId] 
         * @param {number} [consumerId] 
         * @param {string} [domain] 
         * @param {string} [domainPrefix] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [invoiceProfileId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, publisherId?: number, programId?: number, consumerId?: number, domain?: string, domainPrefix?: string, customerTenantType?: 'None' | 'T1' | 'T2', invoiceProfileId?: number, page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfCustomerTenant> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).get(organizationId, publisherId, programId, consumerId, domain, domainPrefix, customerTenantType, invoiceProfileId, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzurePlan(customerTenantId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AzurePlan> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).getAzurePlan(customerTenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerTenant> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).getCustomerTenantById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantDetailedById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerTenantDetailed> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).getCustomerTenantDetailedById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(customerTenant?: CustomerTenantDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerTenantDetailed> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).post(customerTenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, customerTenant?: CustomerTenantDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerTenantDetailed> {
            const localVarFetchArgs = CustomerTenantsApiFetchParamCreator(configuration).put(id, customerTenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerTenantsApi - factory interface
 * @export
 */
export const CustomerTenantsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CustomerTenantDetailed} [existingTenant] 
         * @param {boolean} [syncFromPublisher] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExisting(existingTenant?: CustomerTenantDetailed, syncFromPublisher?: boolean, options?: any) {
            return CustomerTenantsApiFp(configuration).addExisting(existingTenant, syncFromPublisher, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerById(id: number, options?: any) {
            return CustomerTenantsApiFp(configuration).deleteCustomerById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [publisherId] 
         * @param {number} [programId] 
         * @param {number} [consumerId] 
         * @param {string} [domain] 
         * @param {string} [domainPrefix] 
         * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
         * @param {number} [invoiceProfileId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, publisherId?: number, programId?: number, consumerId?: number, domain?: string, domainPrefix?: string, customerTenantType?: 'None' | 'T1' | 'T2', invoiceProfileId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
            return CustomerTenantsApiFp(configuration).get(organizationId, publisherId, programId, consumerId, domain, domainPrefix, customerTenantType, invoiceProfileId, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} customerTenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzurePlan(customerTenantId: number, options?: any) {
            return CustomerTenantsApiFp(configuration).getAzurePlan(customerTenantId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantById(id: number, options?: any) {
            return CustomerTenantsApiFp(configuration).getCustomerTenantById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerTenantDetailedById(id: number, options?: any) {
            return CustomerTenantsApiFp(configuration).getCustomerTenantDetailedById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(customerTenant?: CustomerTenantDetailed, options?: any) {
            return CustomerTenantsApiFp(configuration).post(customerTenant, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CustomerTenantDetailed} [customerTenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, customerTenant?: CustomerTenantDetailed, options?: any) {
            return CustomerTenantsApiFp(configuration).put(id, customerTenant, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerTenantsApi - object-oriented interface
 * @export
 * @class CustomerTenantsApi
 * @extends {BaseAPI}
 */
export class CustomerTenantsApi extends BaseAPI {
    /**
     * 
     * @param {CustomerTenantDetailed} [existingTenant] 
     * @param {boolean} [syncFromPublisher] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public addExisting(existingTenant?: CustomerTenantDetailed, syncFromPublisher?: boolean, options?: any) {
        return CustomerTenantsApiFp(this.configuration).addExisting(existingTenant, syncFromPublisher, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public deleteCustomerById(id: number, options?: any) {
        return CustomerTenantsApiFp(this.configuration).deleteCustomerById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {number} [publisherId] 
     * @param {number} [programId] 
     * @param {number} [consumerId] 
     * @param {string} [domain] 
     * @param {string} [domainPrefix] 
     * @param {'None' | 'T1' | 'T2'} [customerTenantType] 
     * @param {number} [invoiceProfileId] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public get(organizationId?: number, publisherId?: number, programId?: number, consumerId?: number, domain?: string, domainPrefix?: string, customerTenantType?: 'None' | 'T1' | 'T2', invoiceProfileId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
        return CustomerTenantsApiFp(this.configuration).get(organizationId, publisherId, programId, consumerId, domain, domainPrefix, customerTenantType, invoiceProfileId, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} customerTenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public getAzurePlan(customerTenantId: number, options?: any) {
        return CustomerTenantsApiFp(this.configuration).getAzurePlan(customerTenantId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public getCustomerTenantById(id: number, options?: any) {
        return CustomerTenantsApiFp(this.configuration).getCustomerTenantById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public getCustomerTenantDetailedById(id: number, options?: any) {
        return CustomerTenantsApiFp(this.configuration).getCustomerTenantDetailedById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CustomerTenantDetailed} [customerTenant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public post(customerTenant?: CustomerTenantDetailed, options?: any) {
        return CustomerTenantsApiFp(this.configuration).post(customerTenant, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {CustomerTenantDetailed} [customerTenant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTenantsApi
     */
    public put(id: number, customerTenant?: CustomerTenantDetailed, options?: any) {
        return CustomerTenantsApiFp(this.configuration).put(id, customerTenant, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerTokenApi - fetch parameter creator
 * @export
 */
export const CustomerTokenApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/connect/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerTokenApi - functional programming interface
 * @export
 */
export const CustomerTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = CustomerTokenApiFetchParamCreator(configuration).post(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerTokenApi - factory interface
 * @export
 */
export const CustomerTokenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(options?: any) {
            return CustomerTokenApiFp(configuration).post(options)(fetch, basePath);
        },
    };
};

/**
 * CustomerTokenApi - object-oriented interface
 * @export
 * @class CustomerTokenApi
 * @extends {BaseAPI}
 */
export class CustomerTokenApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerTokenApi
     */
    public post(options?: any) {
        return CustomerTokenApiFp(this.configuration).post(options)(this.fetch, this.basePath);
    }

}

/**
 * FacebookOrdersApi - fetch parameter creator
 * @export
 */
export const FacebookOrdersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FacebookOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: FacebookOrder, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/FacebookOrders/checkout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FacebookOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FacebookOrdersApi - functional programming interface
 * @export
 */
export const FacebookOrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FacebookOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: FacebookOrder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FacebookOrdersApiFetchParamCreator(configuration).checkoutAsync(order, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FacebookOrdersApi - factory interface
 * @export
 */
export const FacebookOrdersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {FacebookOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: FacebookOrder, options?: any) {
            return FacebookOrdersApiFp(configuration).checkoutAsync(order, options)(fetch, basePath);
        },
    };
};

/**
 * FacebookOrdersApi - object-oriented interface
 * @export
 * @class FacebookOrdersApi
 * @extends {BaseAPI}
 */
export class FacebookOrdersApi extends BaseAPI {
    /**
     * 
     * @param {FacebookOrder} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacebookOrdersApi
     */
    public checkoutAsync(order?: FacebookOrder, options?: any) {
        return FacebookOrdersApiFp(this.configuration).checkoutAsync(order, options)(this.fetch, this.basePath);
    }

}

/**
 * GoogleOrdersApi - fetch parameter creator
 * @export
 */
export const GoogleOrdersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GoogleOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: GoogleOrder, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/GoogleOrders/checkout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GoogleOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleOrdersApi - functional programming interface
 * @export
 */
export const GoogleOrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GoogleOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: GoogleOrder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GoogleOrdersApiFetchParamCreator(configuration).checkoutAsync(order, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoogleOrdersApi - factory interface
 * @export
 */
export const GoogleOrdersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {GoogleOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkoutAsync(order?: GoogleOrder, options?: any) {
            return GoogleOrdersApiFp(configuration).checkoutAsync(order, options)(fetch, basePath);
        },
    };
};

/**
 * GoogleOrdersApi - object-oriented interface
 * @export
 * @class GoogleOrdersApi
 * @extends {BaseAPI}
 */
export class GoogleOrdersApi extends BaseAPI {
    /**
     * 
     * @param {GoogleOrder} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleOrdersApi
     */
    public checkoutAsync(order?: GoogleOrder, options?: any) {
        return GoogleOrdersApiFp(this.configuration).checkoutAsync(order, options)(this.fetch, this.basePath);
    }

}

/**
 * GroupingsApi - fetch parameter creator
 * @export
 */
export const GroupingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/v1/Groupings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {boolean} [includeRemoved] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, includeRemoved?: boolean, search?: string, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Groupings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (includeRemoved !== undefined) {
                localVarQueryParameter['IncludeRemoved'] = includeRemoved;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/Groupings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(grouping?: Grouping, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Groupings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Grouping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(grouping || {}) : (grouping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, grouping?: Grouping, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/Groupings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Grouping" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(grouping || {}) : (grouping || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupingsApi - functional programming interface
 * @export
 */
export const GroupingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupingsApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {boolean} [includeRemoved] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, includeRemoved?: boolean, search?: string, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfGrouping> {
            const localVarFetchArgs = GroupingsApiFetchParamCreator(configuration).get(organizationId, includeRemoved, search, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grouping> {
            const localVarFetchArgs = GroupingsApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(grouping?: Grouping, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grouping> {
            const localVarFetchArgs = GroupingsApiFetchParamCreator(configuration).post(grouping, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, grouping?: Grouping, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grouping> {
            const localVarFetchArgs = GroupingsApiFetchParamCreator(configuration).put(id, grouping, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupingsApi - factory interface
 * @export
 */
export const GroupingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return GroupingsApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {boolean} [includeRemoved] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, includeRemoved?: boolean, search?: string, page?: number, pageSize?: number, options?: any) {
            return GroupingsApiFp(configuration).get(organizationId, includeRemoved, search, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return GroupingsApiFp(configuration).getById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(grouping?: Grouping, options?: any) {
            return GroupingsApiFp(configuration).post(grouping, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Grouping} [grouping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, grouping?: Grouping, options?: any) {
            return GroupingsApiFp(configuration).put(id, grouping, options)(fetch, basePath);
        },
    };
};

/**
 * GroupingsApi - object-oriented interface
 * @export
 * @class GroupingsApi
 * @extends {BaseAPI}
 */
export class GroupingsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupingsApi
     */
    public _delete(id: number, options?: any) {
        return GroupingsApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {boolean} [includeRemoved] 
     * @param {string} [search] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupingsApi
     */
    public get(organizationId?: number, includeRemoved?: boolean, search?: string, page?: number, pageSize?: number, options?: any) {
        return GroupingsApiFp(this.configuration).get(organizationId, includeRemoved, search, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupingsApi
     */
    public getById(id: number, options?: any) {
        return GroupingsApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Grouping} [grouping] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupingsApi
     */
    public post(grouping?: Grouping, options?: any) {
        return GroupingsApiFp(this.configuration).post(grouping, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {Grouping} [grouping] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupingsApi
     */
    public put(id: number, grouping?: Grouping, options?: any) {
        return GroupingsApiFp(this.configuration).put(id, grouping, options)(this.fetch, this.basePath);
    }

}

/**
 * InvoiceProfilesApi - fetch parameter creator
 * @export
 */
export const InvoiceProfilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/v1/InvoiceProfiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/InvoiceProfiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/InvoiceProfiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(invoiceProfile?: InvoiceProfile, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/InvoiceProfiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InvoiceProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(invoiceProfile || {}) : (invoiceProfile || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, invoiceProfile?: InvoiceProfile, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/InvoiceProfiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InvoiceProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(invoiceProfile || {}) : (invoiceProfile || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceProfilesApi - functional programming interface
 * @export
 */
export const InvoiceProfilesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = InvoiceProfilesApiFetchParamCreator(configuration)._delete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfInvoiceProfile> {
            const localVarFetchArgs = InvoiceProfilesApiFetchParamCreator(configuration).get(organizationId, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceProfile> {
            const localVarFetchArgs = InvoiceProfilesApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(invoiceProfile?: InvoiceProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceProfile> {
            const localVarFetchArgs = InvoiceProfilesApiFetchParamCreator(configuration).post(invoiceProfile, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, invoiceProfile?: InvoiceProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceProfile> {
            const localVarFetchArgs = InvoiceProfilesApiFetchParamCreator(configuration).put(id, invoiceProfile, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoiceProfilesApi - factory interface
 * @export
 */
export const InvoiceProfilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: number, options?: any) {
            return InvoiceProfilesApiFp(configuration)._delete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
            return InvoiceProfilesApiFp(configuration).get(organizationId, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return InvoiceProfilesApiFp(configuration).getById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(invoiceProfile?: InvoiceProfile, options?: any) {
            return InvoiceProfilesApiFp(configuration).post(invoiceProfile, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {InvoiceProfile} [invoiceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, invoiceProfile?: InvoiceProfile, options?: any) {
            return InvoiceProfilesApiFp(configuration).put(id, invoiceProfile, options)(fetch, basePath);
        },
    };
};

/**
 * InvoiceProfilesApi - object-oriented interface
 * @export
 * @class InvoiceProfilesApi
 * @extends {BaseAPI}
 */
export class InvoiceProfilesApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceProfilesApi
     */
    public _delete(id: number, options?: any) {
        return InvoiceProfilesApiFp(this.configuration)._delete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceProfilesApi
     */
    public get(organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
        return InvoiceProfilesApiFp(this.configuration).get(organizationId, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceProfilesApi
     */
    public getById(id: number, options?: any) {
        return InvoiceProfilesApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {InvoiceProfile} [invoiceProfile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceProfilesApi
     */
    public post(invoiceProfile?: InvoiceProfile, options?: any) {
        return InvoiceProfilesApiFp(this.configuration).post(invoiceProfile, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {InvoiceProfile} [invoiceProfile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceProfilesApi
     */
    public put(id: number, invoiceProfile?: InvoiceProfile, options?: any) {
        return InvoiceProfilesApiFp(this.configuration).put(id, invoiceProfile, options)(this.fetch, this.basePath);
    }

}

/**
 * ManagementLinksApi - fetch parameter creator
 * @export
 */
export const ManagementLinksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ManagementLinks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (subscriptionIds) {
                localVarQueryParameter['SubscriptionIds'] = subscriptionIds;
            }

            if (resellerCustomerIds) {
                localVarQueryParameter['ResellerCustomerIds'] = resellerCustomerIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrouped(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ManagementLinks/grouped`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (subscriptionIds) {
                localVarQueryParameter['SubscriptionIds'] = subscriptionIds;
            }

            if (resellerCustomerIds) {
                localVarQueryParameter['ResellerCustomerIds'] = resellerCustomerIds;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagementLinksApi - functional programming interface
 * @export
 */
export const ManagementLinksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfManagementLink> {
            const localVarFetchArgs = ManagementLinksApiFetchParamCreator(configuration).get(subscriptionIds, resellerCustomerIds, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrouped(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfManagementLinkGrouped> {
            const localVarFetchArgs = ManagementLinksApiFetchParamCreator(configuration).getGrouped(subscriptionIds, resellerCustomerIds, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ManagementLinksApi - factory interface
 * @export
 */
export const ManagementLinksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any) {
            return ManagementLinksApiFp(configuration).get(subscriptionIds, resellerCustomerIds, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array<number>} [subscriptionIds] 
         * @param {Array<number>} [resellerCustomerIds] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrouped(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any) {
            return ManagementLinksApiFp(configuration).getGrouped(subscriptionIds, resellerCustomerIds, page, pageSize, options)(fetch, basePath);
        },
    };
};

/**
 * ManagementLinksApi - object-oriented interface
 * @export
 * @class ManagementLinksApi
 * @extends {BaseAPI}
 */
export class ManagementLinksApi extends BaseAPI {
    /**
     * 
     * @param {Array<number>} [subscriptionIds] 
     * @param {Array<number>} [resellerCustomerIds] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagementLinksApi
     */
    public get(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any) {
        return ManagementLinksApiFp(this.configuration).get(subscriptionIds, resellerCustomerIds, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Array<number>} [subscriptionIds] 
     * @param {Array<number>} [resellerCustomerIds] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagementLinksApi
     */
    public getGrouped(subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options?: any) {
        return ManagementLinksApiFp(this.configuration).getGrouped(subscriptionIds, resellerCustomerIds, page, pageSize, options)(this.fetch, this.basePath);
    }

}

/**
 * MeApi - fetch parameter creator
 * @export
 */
export const MeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Me> {
            const localVarFetchArgs = MeApiFetchParamCreator(configuration).get(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any) {
            return MeApiFp(configuration).get(options)(fetch, basePath);
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public get(options?: any) {
        return MeApiFp(this.configuration).get(options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationAccessApi - fetch parameter creator
 * @export
 */
export const OrganizationAccessApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(userId?: string, organizationId?: number, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/OrganizationAccess/grant`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccess(userId?: string, organizationId?: number, page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/OrganizationAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<OrganizationAccess>} [list] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(list?: Array<OrganizationAccess>, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/OrganizationAccess`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;OrganizationAccess&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(list || {}) : (list || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAccessApi - functional programming interface
 * @export
 */
export const OrganizationAccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfOrganizationAccess> {
            const localVarFetchArgs = OrganizationAccessApiFetchParamCreator(configuration).get(userId, organizationId, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccess(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfOrganizationAccess> {
            const localVarFetchArgs = OrganizationAccessApiFetchParamCreator(configuration).getOrganizationAccess(userId, organizationId, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array<OrganizationAccess>} [list] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(list?: Array<OrganizationAccess>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrganizationAccess>> {
            const localVarFetchArgs = OrganizationAccessApiFetchParamCreator(configuration).put(list, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationAccessApi - factory interface
 * @export
 */
export const OrganizationAccessApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any) {
            return OrganizationAccessApiFp(configuration).get(userId, organizationId, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccess(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any) {
            return OrganizationAccessApiFp(configuration).getOrganizationAccess(userId, organizationId, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array<OrganizationAccess>} [list] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(list?: Array<OrganizationAccess>, options?: any) {
            return OrganizationAccessApiFp(configuration).put(list, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationAccessApi - object-oriented interface
 * @export
 * @class OrganizationAccessApi
 * @extends {BaseAPI}
 */
export class OrganizationAccessApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {number} [organizationId] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccessApi
     */
    public get(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any) {
        return OrganizationAccessApiFp(this.configuration).get(userId, organizationId, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {number} [organizationId] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccessApi
     */
    public getOrganizationAccess(userId?: string, organizationId?: number, page?: number, pageSize?: number, options?: any) {
        return OrganizationAccessApiFp(this.configuration).getOrganizationAccess(userId, organizationId, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Array<OrganizationAccess>} [list] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAccessApi
     */
    public put(list?: Array<OrganizationAccess>, options?: any) {
        return OrganizationAccessApiFp(this.configuration).put(list, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/Organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSalesContact(organizationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getOrganizationSalesContact.');
            }
            const localVarPath = `/api/v1/Organizations/{organizationId}/salescontact`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasAccessAsync(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hasAccessAsync.');
            }
            const localVarPath = `/api/v1/Organizations/HasAccess/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfOrganization> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).get(page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organization> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSalesContact(organizationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationSalesContact> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationSalesContact(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasAccessAsync(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).hasAccessAsync(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(page?: number, pageSize?: number, search?: string, options?: any) {
            return OrganizationsApiFp(configuration).get(page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return OrganizationsApiFp(configuration).getById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSalesContact(organizationId: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationSalesContact(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasAccessAsync(id: number, options?: any) {
            return OrganizationsApiFp(configuration).hasAccessAsync(id, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public get(page?: number, pageSize?: number, search?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).get(page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getById(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationSalesContact(organizationId: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationSalesContact(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public hasAccessAsync(id: number, options?: any) {
        return OrganizationsApiFp(this.configuration).hasAccessAsync(id, options)(this.fetch, this.basePath);
    }

}

/**
 * PingApi - fetch parameter creator
 * @export
 */
export const PingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingApi - functional programming interface
 * @export
 */
export const PingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PingApiFetchParamCreator(configuration).get(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PingApi - factory interface
 * @export
 */
export const PingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any) {
            return PingApiFp(configuration).get(options)(fetch, basePath);
        },
    };
};

/**
 * PingApi - object-oriented interface
 * @export
 * @class PingApi
 * @extends {BaseAPI}
 */
export class PingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingApi
     */
    public get(options?: any) {
        return PingApiFp(this.configuration).get(options)(this.fetch, this.basePath);
    }

}

/**
 * ProductContainersApi - fetch parameter creator
 * @export
 */
export const ProductContainersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {number} [programId] 
         * @param {number} [organizationId] 
         * @param {boolean} [copyLast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportAsync(year?: number, month?: number, programId?: number, organizationId?: number, copyLast?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ProductContainers/reportbymonth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (copyLast !== undefined) {
                localVarQueryParameter['copyLast'] = copyLast;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductContainer(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProductContainer.');
            }
            const localVarPath = `/api/v1/ProductContainers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [activeDraft] 
         * @param {number} [programId] 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {string} [userId] 
         * @param {string} [sentByUserId] 
         * @param {'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template'} [type] 
         * @param {'None' | 'Seat' | 'Report'} [category] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {boolean} [includeRemoved] 
         * @param {boolean} [includeSubsidiaries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, activeDraft?: boolean, programId?: number, year?: number, month?: number, userId?: string, sentByUserId?: string, type?: 'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template', category?: 'None' | 'Seat' | 'Report', from?: Date, to?: Date, includeRemoved?: boolean, includeSubsidiaries?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ProductContainers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (activeDraft !== undefined) {
                localVarQueryParameter['ActiveDraft'] = activeDraft;
            }

            if (programId !== undefined) {
                localVarQueryParameter['ProgramId'] = programId;
            }

            if (year !== undefined) {
                localVarQueryParameter['Year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['Month'] = month;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (sentByUserId !== undefined) {
                localVarQueryParameter['SentByUserId'] = sentByUserId;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (category !== undefined) {
                localVarQueryParameter['Category'] = category;
            }

            if (from !== undefined) {
                localVarQueryParameter['From'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = (to as any).toISOString();
            }

            if (includeRemoved !== undefined) {
                localVarQueryParameter['IncludeRemoved'] = includeRemoved;
            }

            if (includeSubsidiaries !== undefined) {
                localVarQueryParameter['IncludeSubsidiaries'] = includeSubsidiaries;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/ProductContainers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdWithRowIssues(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getByIdWithRowIssues.');
            }
            const localVarPath = `/api/v1/ProductContainers/rowissues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateShoppingCart(organizationId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ProductContainers/getorcreateshoppingcart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productContainerId 
         * @param {number} productRowId 
         * @param {ProductRowPatch} [productRowPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProductRow(productContainerId: number, productRowId: number, productRowPatch?: ProductRowPatch, options: any = {}): FetchArgs {
            // verify required parameter 'productContainerId' is not null or undefined
            if (productContainerId === null || productContainerId === undefined) {
                throw new RequiredError('productContainerId','Required parameter productContainerId was null or undefined when calling patchProductRow.');
            }
            // verify required parameter 'productRowId' is not null or undefined
            if (productRowId === null || productRowId === undefined) {
                throw new RequiredError('productRowId','Required parameter productRowId was null or undefined when calling patchProductRow.');
            }
            const localVarPath = `/api/v1/ProductContainers/{productContainerId}/row/{productRowId}`
                .replace(`{${"productContainerId"}}`, encodeURIComponent(String(productContainerId)))
                .replace(`{${"productRowId"}}`, encodeURIComponent(String(productRowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductRowPatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(productRowPatch || {}) : (productRowPatch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ProductContainer} [productContainer] 
         * @param {boolean} [requireEulaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, productContainer?: ProductContainer, requireEulaAnalysis?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/ProductContainers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (requireEulaAnalysis !== undefined) {
                localVarQueryParameter['requireEulaAnalysis'] = requireEulaAnalysis;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductContainer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(productContainer || {}) : (productContainer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductContainersApi - functional programming interface
 * @export
 */
export const ProductContainersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {number} [programId] 
         * @param {number} [organizationId] 
         * @param {boolean} [copyLast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportAsync(year?: number, month?: number, programId?: number, organizationId?: number, copyLast?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).createReportAsync(year, month, programId, organizationId, copyLast, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductContainer(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).deleteProductContainer(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [activeDraft] 
         * @param {number} [programId] 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {string} [userId] 
         * @param {string} [sentByUserId] 
         * @param {'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template'} [type] 
         * @param {'None' | 'Seat' | 'Report'} [category] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {boolean} [includeRemoved] 
         * @param {boolean} [includeSubsidiaries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, activeDraft?: boolean, programId?: number, year?: number, month?: number, userId?: string, sentByUserId?: string, type?: 'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template', category?: 'None' | 'Seat' | 'Report', from?: Date, to?: Date, includeRemoved?: boolean, includeSubsidiaries?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).get(organizationId, search, page, pageSize, activeDraft, programId, year, month, userId, sentByUserId, type, category, from, to, includeRemoved, includeSubsidiaries, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdWithRowIssues(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).getByIdWithRowIssues(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateShoppingCart(organizationId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).getOrCreateShoppingCart(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} productContainerId 
         * @param {number} productRowId 
         * @param {ProductRowPatch} [productRowPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProductRow(productContainerId: number, productRowId: number, productRowPatch?: ProductRowPatch, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).patchProductRow(productContainerId, productRowId, productRowPatch, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {ProductContainer} [productContainer] 
         * @param {boolean} [requireEulaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, productContainer?: ProductContainer, requireEulaAnalysis?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductContainer> {
            const localVarFetchArgs = ProductContainersApiFetchParamCreator(configuration).put(id, productContainer, requireEulaAnalysis, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductContainersApi - factory interface
 * @export
 */
export const ProductContainersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {number} [programId] 
         * @param {number} [organizationId] 
         * @param {boolean} [copyLast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportAsync(year?: number, month?: number, programId?: number, organizationId?: number, copyLast?: boolean, options?: any) {
            return ProductContainersApiFp(configuration).createReportAsync(year, month, programId, organizationId, copyLast, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductContainer(id: number, options?: any) {
            return ProductContainersApiFp(configuration).deleteProductContainer(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {string} [search] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {boolean} [activeDraft] 
         * @param {number} [programId] 
         * @param {number} [year] 
         * @param {number} [month] 
         * @param {string} [userId] 
         * @param {string} [sentByUserId] 
         * @param {'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template'} [type] 
         * @param {'None' | 'Seat' | 'Report'} [category] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {boolean} [includeRemoved] 
         * @param {boolean} [includeSubsidiaries] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, search?: string, page?: number, pageSize?: number, activeDraft?: boolean, programId?: number, year?: number, month?: number, userId?: string, sentByUserId?: string, type?: 'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template', category?: 'None' | 'Seat' | 'Report', from?: Date, to?: Date, includeRemoved?: boolean, includeSubsidiaries?: boolean, options?: any) {
            return ProductContainersApiFp(configuration).get(organizationId, search, page, pageSize, activeDraft, programId, year, month, userId, sentByUserId, type, category, from, to, includeRemoved, includeSubsidiaries, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return ProductContainersApiFp(configuration).getById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByIdWithRowIssues(id: number, options?: any) {
            return ProductContainersApiFp(configuration).getByIdWithRowIssues(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateShoppingCart(organizationId?: number, options?: any) {
            return ProductContainersApiFp(configuration).getOrCreateShoppingCart(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} productContainerId 
         * @param {number} productRowId 
         * @param {ProductRowPatch} [productRowPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProductRow(productContainerId: number, productRowId: number, productRowPatch?: ProductRowPatch, options?: any) {
            return ProductContainersApiFp(configuration).patchProductRow(productContainerId, productRowId, productRowPatch, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {ProductContainer} [productContainer] 
         * @param {boolean} [requireEulaAnalysis] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, productContainer?: ProductContainer, requireEulaAnalysis?: boolean, options?: any) {
            return ProductContainersApiFp(configuration).put(id, productContainer, requireEulaAnalysis, options)(fetch, basePath);
        },
    };
};

/**
 * ProductContainersApi - object-oriented interface
 * @export
 * @class ProductContainersApi
 * @extends {BaseAPI}
 */
export class ProductContainersApi extends BaseAPI {
    /**
     * 
     * @param {number} [year] 
     * @param {number} [month] 
     * @param {number} [programId] 
     * @param {number} [organizationId] 
     * @param {boolean} [copyLast] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public createReportAsync(year?: number, month?: number, programId?: number, organizationId?: number, copyLast?: boolean, options?: any) {
        return ProductContainersApiFp(this.configuration).createReportAsync(year, month, programId, organizationId, copyLast, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public deleteProductContainer(id: number, options?: any) {
        return ProductContainersApiFp(this.configuration).deleteProductContainer(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {string} [search] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {boolean} [activeDraft] 
     * @param {number} [programId] 
     * @param {number} [year] 
     * @param {number} [month] 
     * @param {string} [userId] 
     * @param {string} [sentByUserId] 
     * @param {'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template'} [type] 
     * @param {'None' | 'Seat' | 'Report'} [category] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {boolean} [includeRemoved] 
     * @param {boolean} [includeSubsidiaries] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public get(organizationId?: number, search?: string, page?: number, pageSize?: number, activeDraft?: boolean, programId?: number, year?: number, month?: number, userId?: string, sentByUserId?: string, type?: 'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template', category?: 'None' | 'Seat' | 'Report', from?: Date, to?: Date, includeRemoved?: boolean, includeSubsidiaries?: boolean, options?: any) {
        return ProductContainersApiFp(this.configuration).get(organizationId, search, page, pageSize, activeDraft, programId, year, month, userId, sentByUserId, type, category, from, to, includeRemoved, includeSubsidiaries, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public getById(id: number, options?: any) {
        return ProductContainersApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public getByIdWithRowIssues(id: number, options?: any) {
        return ProductContainersApiFp(this.configuration).getByIdWithRowIssues(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public getOrCreateShoppingCart(organizationId?: number, options?: any) {
        return ProductContainersApiFp(this.configuration).getOrCreateShoppingCart(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} productContainerId 
     * @param {number} productRowId 
     * @param {ProductRowPatch} [productRowPatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public patchProductRow(productContainerId: number, productRowId: number, productRowPatch?: ProductRowPatch, options?: any) {
        return ProductContainersApiFp(this.configuration).patchProductRow(productContainerId, productRowId, productRowPatch, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {ProductContainer} [productContainer] 
     * @param {boolean} [requireEulaAnalysis] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductContainersApi
     */
    public put(id: number, productContainer?: ProductContainer, requireEulaAnalysis?: boolean, options?: any) {
        return ProductContainersApiFp(this.configuration).put(id, productContainer, requireEulaAnalysis, options)(this.fetch, this.basePath);
    }

}

/**
 * ProgramsApi - fetch parameter creator
 * @export
 */
export const ProgramsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [publisherId] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(publisherId?: number, programType?: 'None' | 'License' | 'Report' | 'Cloud', page?: number, pageSize?: number, search?: string, organizationId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Programs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (programType !== undefined) {
                localVarQueryParameter['ProgramType'] = programType;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/Programs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [publisherId] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(publisherId?: number, programType?: 'None' | 'License' | 'Report' | 'Cloud', page?: number, pageSize?: number, search?: string, organizationId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfProgram> {
            const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).get(publisherId, programType, page, pageSize, search, organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Program> {
            const localVarFetchArgs = ProgramsApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [publisherId] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(publisherId?: number, programType?: 'None' | 'License' | 'Report' | 'Cloud', page?: number, pageSize?: number, search?: string, organizationId?: number, options?: any) {
            return ProgramsApiFp(configuration).get(publisherId, programType, page, pageSize, search, organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return ProgramsApiFp(configuration).getById(id, options)(fetch, basePath);
        },
    };
};

/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI {
    /**
     * 
     * @param {number} [publisherId] 
     * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {number} [organizationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public get(publisherId?: number, programType?: 'None' | 'License' | 'Report' | 'Cloud', page?: number, pageSize?: number, search?: string, organizationId?: number, options?: any) {
        return ProgramsApiFp(this.configuration).get(publisherId, programType, page, pageSize, search, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    public getById(id: number, options?: any) {
        return ProgramsApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

}

/**
 * PublishersApi - fetch parameter creator
 * @export
 */
export const PublishersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [names] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(names?: Array<string>, page?: number, pageSize?: number, search?: string, programType?: 'None' | 'License' | 'Report' | 'Cloud', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Publishers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (names) {
                localVarQueryParameter['Names'] = names;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (programType !== undefined) {
                localVarQueryParameter['ProgramType'] = programType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getById.');
            }
            const localVarPath = `/api/v1/Publishers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishersApi - functional programming interface
 * @export
 */
export const PublishersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [names] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(names?: Array<string>, page?: number, pageSize?: number, search?: string, programType?: 'None' | 'License' | 'Report' | 'Cloud', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfPublisher> {
            const localVarFetchArgs = PublishersApiFetchParamCreator(configuration).get(names, page, pageSize, search, programType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Publisher> {
            const localVarFetchArgs = PublishersApiFetchParamCreator(configuration).getById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PublishersApi - factory interface
 * @export
 */
export const PublishersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {Array<string>} [names] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(names?: Array<string>, page?: number, pageSize?: number, search?: string, programType?: 'None' | 'License' | 'Report' | 'Cloud', options?: any) {
            return PublishersApiFp(configuration).get(names, page, pageSize, search, programType, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: number, options?: any) {
            return PublishersApiFp(configuration).getById(id, options)(fetch, basePath);
        },
    };
};

/**
 * PublishersApi - object-oriented interface
 * @export
 * @class PublishersApi
 * @extends {BaseAPI}
 */
export class PublishersApi extends BaseAPI {
    /**
     * 
     * @param {Array<string>} [names] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {'None' | 'License' | 'Report' | 'Cloud'} [programType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public get(names?: Array<string>, page?: number, pageSize?: number, search?: string, programType?: 'None' | 'License' | 'Report' | 'Cloud', options?: any) {
        return PublishersApiFp(this.configuration).get(names, page, pageSize, search, programType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public getById(id: number, options?: any) {
        return PublishersApiFp(this.configuration).getById(id, options)(this.fetch, this.basePath);
    }

}

/**
 * RegionsApi - fetch parameter creator
 * @export
 */
export const RegionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', organizationId?: number, page?: number, pageSize?: number, search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Regions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (regionList !== undefined) {
                localVarQueryParameter['RegionList'] = regionList;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [regionCode] 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRegionCode(regionCode?: string, regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Regions/bycode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (regionCode !== undefined) {
                localVarQueryParameter['regionCode'] = regionCode;
            }

            if (regionList !== undefined) {
                localVarQueryParameter['regionList'] = regionList;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfRegion> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).get(regionList, organizationId, page, pageSize, search, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [regionCode] 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRegionCode(regionCode?: string, regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Region> {
            const localVarFetchArgs = RegionsApiFetchParamCreator(configuration).getByRegionCode(regionCode, regionList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {number} [organizationId] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
            return RegionsApiFp(configuration).get(regionList, organizationId, page, pageSize, search, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [regionCode] 
         * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRegionCode(regionCode?: string, regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', options?: any) {
            return RegionsApiFp(configuration).getByRegionCode(regionCode, regionList, options)(fetch, basePath);
        },
    };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
    /**
     * 
     * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
     * @param {number} [organizationId] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public get(regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', organizationId?: number, page?: number, pageSize?: number, search?: string, options?: any) {
        return RegionsApiFp(this.configuration).get(regionList, organizationId, page, pageSize, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [regionCode] 
     * @param {'None' | 'MicrosoftCsp' | 'OrganizationSpecific'} [regionList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public getByRegionCode(regionCode?: string, regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', options?: any) {
        return RegionsApiFp(this.configuration).getByRegionCode(regionCode, regionList, options)(this.fetch, this.basePath);
    }

}

/**
 * ResellerSalesPricesApi - fetch parameter creator
 * @export
 */
export const ResellerSalesPricesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByFilterAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ResellerSalesPrices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['ObjectId'] = objectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['ObjectType'] = objectType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['FromDate'] = (fromDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ResellerSalesPrices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['ObjectId'] = objectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['ObjectType'] = objectType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['FromDate'] = (fromDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ResellerSalesPrices/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['Type'] = type;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['ObjectId'] = objectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['ObjectType'] = objectType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['FromDate'] = (fromDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAsync(resellerSalesPrice?: ResellerSalesPrice, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ResellerSalesPrices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResellerSalesPrice" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resellerSalesPrice || {}) : (resellerSalesPrice || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Date} oldFromDate 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAsync(oldFromDate: Date, resellerSalesPrice?: ResellerSalesPrice, options: any = {}): FetchArgs {
            // verify required parameter 'oldFromDate' is not null or undefined
            if (oldFromDate === null || oldFromDate === undefined) {
                throw new RequiredError('oldFromDate','Required parameter oldFromDate was null or undefined when calling putAsync.');
            }
            const localVarPath = `/api/v1/ResellerSalesPrices/{oldFromDate}`
                .replace(`{${"oldFromDate"}}`, encodeURIComponent(String(oldFromDate)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResellerSalesPrice" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resellerSalesPrice || {}) : (resellerSalesPrice || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResellerSalesPriceToggle} [resellerSalesPriceToggle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAsync(resellerSalesPriceToggle?: ResellerSalesPriceToggle, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/ResellerSalesPrices/toggle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResellerSalesPriceToggle" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resellerSalesPriceToggle || {}) : (resellerSalesPriceToggle || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResellerSalesPricesApi - functional programming interface
 * @export
 */
export const ResellerSalesPricesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByFilterAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).deleteByFilterAsync(type, objectId, objectType, fromDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResellerSalesPrice>> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).getAsync(type, objectId, objectType, fromDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResellerSalesPrice> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).getCurrentAsync(type, objectId, objectType, fromDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAsync(resellerSalesPrice?: ResellerSalesPrice, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResellerSalesPrice> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).postAsync(resellerSalesPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Date} oldFromDate 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAsync(oldFromDate: Date, resellerSalesPrice?: ResellerSalesPrice, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResellerSalesPrice> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).putAsync(oldFromDate, resellerSalesPrice, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ResellerSalesPriceToggle} [resellerSalesPriceToggle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAsync(resellerSalesPriceToggle?: ResellerSalesPriceToggle, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResellerSalesPricesApiFetchParamCreator(configuration).toggleAsync(resellerSalesPriceToggle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResellerSalesPricesApi - factory interface
 * @export
 */
export const ResellerSalesPricesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByFilterAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
            return ResellerSalesPricesApiFp(configuration).deleteByFilterAsync(type, objectId, objectType, fromDate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
            return ResellerSalesPricesApiFp(configuration).getAsync(type, objectId, objectType, fromDate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {'License' | 'Usage' | 'OneTime'} [type] 
         * @param {number} [objectId] 
         * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
         * @param {Date} [fromDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
            return ResellerSalesPricesApiFp(configuration).getCurrentAsync(type, objectId, objectType, fromDate, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAsync(resellerSalesPrice?: ResellerSalesPrice, options?: any) {
            return ResellerSalesPricesApiFp(configuration).postAsync(resellerSalesPrice, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Date} oldFromDate 
         * @param {ResellerSalesPrice} [resellerSalesPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAsync(oldFromDate: Date, resellerSalesPrice?: ResellerSalesPrice, options?: any) {
            return ResellerSalesPricesApiFp(configuration).putAsync(oldFromDate, resellerSalesPrice, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ResellerSalesPriceToggle} [resellerSalesPriceToggle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAsync(resellerSalesPriceToggle?: ResellerSalesPriceToggle, options?: any) {
            return ResellerSalesPricesApiFp(configuration).toggleAsync(resellerSalesPriceToggle, options)(fetch, basePath);
        },
    };
};

/**
 * ResellerSalesPricesApi - object-oriented interface
 * @export
 * @class ResellerSalesPricesApi
 * @extends {BaseAPI}
 */
export class ResellerSalesPricesApi extends BaseAPI {
    /**
     * 
     * @param {'License' | 'Usage' | 'OneTime'} [type] 
     * @param {number} [objectId] 
     * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
     * @param {Date} [fromDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public deleteByFilterAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).deleteByFilterAsync(type, objectId, objectType, fromDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {'License' | 'Usage' | 'OneTime'} [type] 
     * @param {number} [objectId] 
     * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
     * @param {Date} [fromDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public getAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).getAsync(type, objectId, objectType, fromDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {'License' | 'Usage' | 'OneTime'} [type] 
     * @param {number} [objectId] 
     * @param {'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'} [objectType] 
     * @param {Date} [fromDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public getCurrentAsync(type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).getCurrentAsync(type, objectId, objectType, fromDate, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ResellerSalesPrice} [resellerSalesPrice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public postAsync(resellerSalesPrice?: ResellerSalesPrice, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).postAsync(resellerSalesPrice, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Date} oldFromDate 
     * @param {ResellerSalesPrice} [resellerSalesPrice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public putAsync(oldFromDate: Date, resellerSalesPrice?: ResellerSalesPrice, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).putAsync(oldFromDate, resellerSalesPrice, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ResellerSalesPriceToggle} [resellerSalesPriceToggle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResellerSalesPricesApi
     */
    public toggleAsync(resellerSalesPriceToggle?: ResellerSalesPriceToggle, options?: any) {
        return ResellerSalesPricesApiFp(this.configuration).toggleAsync(resellerSalesPriceToggle, options)(this.fetch, this.basePath);
    }

}

/**
 * SecretsApi - fetch parameter creator
 * @export
 */
export const SecretsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [clientId] 
         * @param {number} [secretId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId?: string, secretId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Secrets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (secretId !== undefined) {
                localVarQueryParameter['secretId'] = secretId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(secret?: Secret, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Secrets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Secret" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(secret || {}) : (secret || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [clientId] 
         * @param {number} [secretId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId?: string, secretId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SecretsApiFetchParamCreator(configuration)._delete(clientId, secretId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(secret?: Secret, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Secret> {
            const localVarFetchArgs = SecretsApiFetchParamCreator(configuration).post(secret, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [clientId] 
         * @param {number} [secretId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(clientId?: string, secretId?: number, options?: any) {
            return SecretsApiFp(configuration)._delete(clientId, secretId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(secret?: Secret, options?: any) {
            return SecretsApiFp(configuration).post(secret, options)(fetch, basePath);
        },
    };
};

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI {
    /**
     * 
     * @param {string} [clientId] 
     * @param {number} [secretId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public _delete(clientId?: string, secretId?: number, options?: any) {
        return SecretsApiFp(this.configuration)._delete(clientId, secretId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Secret} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public post(secret?: Secret, options?: any) {
        return SecretsApiFp(this.configuration).post(secret, options)(this.fetch, this.basePath);
    }

}

/**
 * SubscriptionsApi - fetch parameter creator
 * @export
 */
export const SubscriptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling deleteSubscriptionTags.');
            }
            const localVarPath = `/api/v1/Subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [publisherId] 
         * @param {boolean} [refresh] 
         * @param {'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All'} [statuses] 
         * @param {boolean} [isTrial] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {boolean} [registeredForReservedInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, customerTenantId?: number, publisherId?: number, refresh?: boolean, statuses?: 'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All', isTrial?: boolean, page?: number, pageSize?: number, search?: string, registeredForReservedInstance?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (customerTenantId !== undefined) {
                localVarQueryParameter['CustomerTenantId'] = customerTenantId;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['PublisherId'] = publisherId;
            }

            if (refresh !== undefined) {
                localVarQueryParameter['Refresh'] = refresh;
            }

            if (statuses !== undefined) {
                localVarQueryParameter['Statuses'] = statuses;
            }

            if (isTrial !== undefined) {
                localVarQueryParameter['IsTrial'] = isTrial;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (registeredForReservedInstance !== undefined) {
                localVarQueryParameter['RegisteredForReservedInstance'] = registeredForReservedInstance;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkAsync(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivationLinkAsync.');
            }
            const localVarPath = `/api/v1/Subscriptions/{id}/activationlink`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterReservedInstance(id: number, reservedInstance: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRegisterReservedInstance.');
            }
            // verify required parameter 'reservedInstance' is not null or undefined
            if (reservedInstance === null || reservedInstance === undefined) {
                throw new RequiredError('reservedInstance','Required parameter reservedInstance was null or undefined when calling getRegisterReservedInstance.');
            }
            const localVarPath = `/api/v1/Subscriptions/{reservedInstance}/subscriptionId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"reservedInstance"}}`, encodeURIComponent(String(reservedInstance)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionConversions(subscriptionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionConversions.');
            }
            const localVarPath = `/api/v1/Subscriptions/{subscriptionId}/conversions`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPriceTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Subscriptions/subscriptionpricetypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionTags.');
            }
            const localVarPath = `/api/v1/Subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(subscription?: SubscriptionDetailed, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(subscription || {}) : (subscription || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {SubscriptionConversion} [conversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionConversion(subscriptionId: number, conversion?: SubscriptionConversion, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling postSubscriptionConversion.');
            }
            const localVarPath = `/api/v1/Subscriptions/{subscriptionId}/conversions`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionConversion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(conversion || {}) : (conversion || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, subscription?: SubscriptionDetailed, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling put.');
            }
            const localVarPath = `/api/v1/Subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionDetailed" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(subscription || {}) : (subscription || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerReservedInstance(id: number, reservedInstance: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling registerReservedInstance.');
            }
            // verify required parameter 'reservedInstance' is not null or undefined
            if (reservedInstance === null || reservedInstance === undefined) {
                throw new RequiredError('reservedInstance','Required parameter reservedInstance was null or undefined when calling registerReservedInstance.');
            }
            const localVarPath = `/api/v1/Subscriptions/{reservedInstance}/subscriptionId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"reservedInstance"}}`, encodeURIComponent(String(reservedInstance)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriptionId 
         * @param {SubscriptionTags} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTags(subscriptionId: string, tags?: SubscriptionTags, options: any = {}): FetchArgs {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling setSubscriptionTags.');
            }
            const localVarPath = `/api/v1/Subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionTags" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tags || {}) : (tags || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling subscription.');
            }
            const localVarPath = `/api/v1/Subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).deleteSubscriptionTags(subscriptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [publisherId] 
         * @param {boolean} [refresh] 
         * @param {'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All'} [statuses] 
         * @param {boolean} [isTrial] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {boolean} [registeredForReservedInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, customerTenantId?: number, publisherId?: number, refresh?: boolean, statuses?: 'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All', isTrial?: boolean, page?: number, pageSize?: number, search?: string, registeredForReservedInstance?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscription> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).get(organizationId, customerTenantId, publisherId, refresh, statuses, isTrial, page, pageSize, search, registeredForReservedInstance, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkAsync(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivationLink> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getActivationLinkAsync(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterReservedInstance(id: number, reservedInstance: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfBoolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getRegisterReservedInstance(id, reservedInstance, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionConversions(subscriptionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscriptionConversion> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionConversions(subscriptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPriceTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfObjectReference> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionPriceTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionTags> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionTags(subscriptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(subscription?: SubscriptionDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionDetailed> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).post(subscription, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {SubscriptionConversion} [conversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionConversion(subscriptionId: number, conversion?: SubscriptionConversion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionDetailed> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).postSubscriptionConversion(subscriptionId, conversion, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, subscription?: SubscriptionDetailed, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionDetailed> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).put(id, subscription, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerReservedInstance(id: number, reservedInstance: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).registerReservedInstance(id, reservedInstance, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriptionId 
         * @param {SubscriptionTags} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTags(subscriptionId: string, tags?: SubscriptionTags, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setSubscriptionTags(subscriptionId, tags, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionDetailed> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).subscription(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId: number, options?: any) {
            return SubscriptionsApiFp(configuration).deleteSubscriptionTags(subscriptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [organizationId] 
         * @param {number} [customerTenantId] 
         * @param {number} [publisherId] 
         * @param {boolean} [refresh] 
         * @param {'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All'} [statuses] 
         * @param {boolean} [isTrial] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [search] 
         * @param {boolean} [registeredForReservedInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(organizationId?: number, customerTenantId?: number, publisherId?: number, refresh?: boolean, statuses?: 'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All', isTrial?: boolean, page?: number, pageSize?: number, search?: string, registeredForReservedInstance?: boolean, options?: any) {
            return SubscriptionsApiFp(configuration).get(organizationId, customerTenantId, publisherId, refresh, statuses, isTrial, page, pageSize, search, registeredForReservedInstance, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivationLinkAsync(id: number, options?: any) {
            return SubscriptionsApiFp(configuration).getActivationLinkAsync(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterReservedInstance(id: number, reservedInstance: boolean, options?: any) {
            return SubscriptionsApiFp(configuration).getRegisterReservedInstance(id, reservedInstance, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionConversions(subscriptionId: number, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionConversions(subscriptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionPriceTypes(options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionPriceTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId: number, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionTags(subscriptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(subscription?: SubscriptionDetailed, options?: any) {
            return SubscriptionsApiFp(configuration).post(subscription, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} subscriptionId 
         * @param {SubscriptionConversion} [conversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionConversion(subscriptionId: number, conversion?: SubscriptionConversion, options?: any) {
            return SubscriptionsApiFp(configuration).postSubscriptionConversion(subscriptionId, conversion, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {SubscriptionDetailed} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        put(id: number, subscription?: SubscriptionDetailed, options?: any) {
            return SubscriptionsApiFp(configuration).put(id, subscription, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {boolean} reservedInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerReservedInstance(id: number, reservedInstance: boolean, options?: any) {
            return SubscriptionsApiFp(configuration).registerReservedInstance(id, reservedInstance, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriptionId 
         * @param {SubscriptionTags} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTags(subscriptionId: string, tags?: SubscriptionTags, options?: any) {
            return SubscriptionsApiFp(configuration).setSubscriptionTags(subscriptionId, tags, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription(id: number, options?: any) {
            return SubscriptionsApiFp(configuration).subscription(id, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {number} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscriptionTags(subscriptionId: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).deleteSubscriptionTags(subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [organizationId] 
     * @param {number} [customerTenantId] 
     * @param {number} [publisherId] 
     * @param {boolean} [refresh] 
     * @param {'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All'} [statuses] 
     * @param {boolean} [isTrial] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {boolean} [registeredForReservedInstance] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public get(organizationId?: number, customerTenantId?: number, publisherId?: number, refresh?: boolean, statuses?: 'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All', isTrial?: boolean, page?: number, pageSize?: number, search?: string, registeredForReservedInstance?: boolean, options?: any) {
        return SubscriptionsApiFp(this.configuration).get(organizationId, customerTenantId, publisherId, refresh, statuses, isTrial, page, pageSize, search, registeredForReservedInstance, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getActivationLinkAsync(id: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).getActivationLinkAsync(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {boolean} reservedInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getRegisterReservedInstance(id: number, reservedInstance: boolean, options?: any) {
        return SubscriptionsApiFp(this.configuration).getRegisterReservedInstance(id, reservedInstance, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionConversions(subscriptionId: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionConversions(subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionPriceTypes(options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionPriceTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionTags(subscriptionId: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionTags(subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubscriptionDetailed} [subscription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public post(subscription?: SubscriptionDetailed, options?: any) {
        return SubscriptionsApiFp(this.configuration).post(subscription, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} subscriptionId 
     * @param {SubscriptionConversion} [conversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public postSubscriptionConversion(subscriptionId: number, conversion?: SubscriptionConversion, options?: any) {
        return SubscriptionsApiFp(this.configuration).postSubscriptionConversion(subscriptionId, conversion, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {SubscriptionDetailed} [subscription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public put(id: number, subscription?: SubscriptionDetailed, options?: any) {
        return SubscriptionsApiFp(this.configuration).put(id, subscription, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {boolean} reservedInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public registerReservedInstance(id: number, reservedInstance: boolean, options?: any) {
        return SubscriptionsApiFp(this.configuration).registerReservedInstance(id, reservedInstance, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriptionId 
     * @param {SubscriptionTags} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setSubscriptionTags(subscriptionId: string, tags?: SubscriptionTags, options?: any) {
        return SubscriptionsApiFp(this.configuration).setSubscriptionTags(subscriptionId, tags, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscription(id: number, options?: any) {
        return SubscriptionsApiFp(this.configuration).subscription(id, options)(this.fetch, this.basePath);
    }

}

/**
 * UsageCostApi - fetch parameter creator
 * @export
 */
export const UsageCostApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory(resellerCustomerId: number, subscriptionId: string, category: string, currencyCode: string, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'resellerCustomerId' is not null or undefined
            if (resellerCustomerId === null || resellerCustomerId === undefined) {
                throw new RequiredError('resellerCustomerId','Required parameter resellerCustomerId was null or undefined when calling getForCategory.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getForCategory.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category','Required parameter category was null or undefined when calling getForCategory.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling getForCategory.');
            }
            const localVarPath = `/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/category/{category}/currency/{currencyCode}`
                .replace(`{${"resellerCustomerId"}}`, encodeURIComponent(String(resellerCustomerId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"category"}}`, encodeURIComponent(String(category)))
                .replace(`{${"currencyCode"}}`, encodeURIComponent(String(currencyCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory_1(model?: CategoryUsageCostRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/UsageCost/getForCategory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryUsageCostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForOrganization(organizationId: number, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getForOrganization.');
            }
            const localVarPath = `/api/v1/UsageCost/organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} resourceGroup 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup(resellerCustomerId: number, subscriptionId: string, resourceGroup: string, currencyCode: string, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'resellerCustomerId' is not null or undefined
            if (resellerCustomerId === null || resellerCustomerId === undefined) {
                throw new RequiredError('resellerCustomerId','Required parameter resellerCustomerId was null or undefined when calling getForResourceGroup.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getForResourceGroup.');
            }
            // verify required parameter 'resourceGroup' is not null or undefined
            if (resourceGroup === null || resourceGroup === undefined) {
                throw new RequiredError('resourceGroup','Required parameter resourceGroup was null or undefined when calling getForResourceGroup.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling getForResourceGroup.');
            }
            const localVarPath = `/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/resourceGroup/{resourceGroup}/currency/{currencyCode}`
                .replace(`{${"resellerCustomerId"}}`, encodeURIComponent(String(resellerCustomerId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"resourceGroup"}}`, encodeURIComponent(String(resourceGroup)))
                .replace(`{${"currencyCode"}}`, encodeURIComponent(String(currencyCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResourceGroupUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup_2(model?: ResourceGroupUsageCostRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/UsageCost/getForResourceGroup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceGroupUsageCostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} subcategory 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory(resellerCustomerId: number, subscriptionId: string, category: string, subcategory: string, currencyCode: string, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'resellerCustomerId' is not null or undefined
            if (resellerCustomerId === null || resellerCustomerId === undefined) {
                throw new RequiredError('resellerCustomerId','Required parameter resellerCustomerId was null or undefined when calling getForSubcategory.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getForSubcategory.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category','Required parameter category was null or undefined when calling getForSubcategory.');
            }
            // verify required parameter 'subcategory' is not null or undefined
            if (subcategory === null || subcategory === undefined) {
                throw new RequiredError('subcategory','Required parameter subcategory was null or undefined when calling getForSubcategory.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling getForSubcategory.');
            }
            const localVarPath = `/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/category/{category}/subcategory/{subcategory}/currency/{currencyCode}`
                .replace(`{${"resellerCustomerId"}}`, encodeURIComponent(String(resellerCustomerId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"category"}}`, encodeURIComponent(String(category)))
                .replace(`{${"subcategory"}}`, encodeURIComponent(String(subcategory)))
                .replace(`{${"currencyCode"}}`, encodeURIComponent(String(currencyCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubcategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory_3(model?: SubcategoryUsageCostRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/UsageCost/getForSubcategory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubcategoryUsageCostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'resellerCustomerId' is not null or undefined
            if (resellerCustomerId === null || resellerCustomerId === undefined) {
                throw new RequiredError('resellerCustomerId','Required parameter resellerCustomerId was null or undefined when calling getForSubscription.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getForSubscription.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling getForSubscription.');
            }
            const localVarPath = `/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/currency/{currencyCode}`
                .replace(`{${"resellerCustomerId"}}`, encodeURIComponent(String(resellerCustomerId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"currencyCode"}}`, encodeURIComponent(String(currencyCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'resellerCustomerId' is not null or undefined
            if (resellerCustomerId === null || resellerCustomerId === undefined) {
                throw new RequiredError('resellerCustomerId','Required parameter resellerCustomerId was null or undefined when calling getForSubscriptionWithResourceGroups.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getForSubscriptionWithResourceGroups.');
            }
            // verify required parameter 'currencyCode' is not null or undefined
            if (currencyCode === null || currencyCode === undefined) {
                throw new RequiredError('currencyCode','Required parameter currencyCode was null or undefined when calling getForSubscriptionWithResourceGroups.');
            }
            const localVarPath = `/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/currency/{currencyCode}/resourceGroups`
                .replace(`{${"resellerCustomerId"}}`, encodeURIComponent(String(resellerCustomerId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"currencyCode"}}`, encodeURIComponent(String(currencyCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups_4(model?: SubscriptionUsageCostRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/UsageCost/getForSubscription/resourceGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionUsageCostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription_5(model?: SubscriptionUsageCostRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/UsageCost/getForSubscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscriptionUsageCostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageCostApi - functional programming interface
 * @export
 */
export const UsageCostApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory(resellerCustomerId: number, subscriptionId: string, category: string, currencyCode: string, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfCategoryUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForCategory(resellerCustomerId, subscriptionId, category, currencyCode, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory_1(model?: CategoryUsageCostRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfCategoryUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForCategory_1(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForOrganization(organizationId: number, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfOrganizationUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForOrganization(organizationId, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} resourceGroup 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup(resellerCustomerId: number, subscriptionId: string, resourceGroup: string, currencyCode: string, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfResourceGroupUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForResourceGroup(resellerCustomerId, subscriptionId, resourceGroup, currencyCode, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ResourceGroupUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup_2(model?: ResourceGroupUsageCostRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfResourceGroupUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForResourceGroup_2(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} subcategory 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory(resellerCustomerId: number, subscriptionId: string, category: string, subcategory: string, currencyCode: string, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubcategoryUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubcategory(resellerCustomerId, subscriptionId, category, subcategory, currencyCode, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubcategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory_3(model?: SubcategoryUsageCostRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubcategoryUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubcategory_3(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscriptionUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubscription(resellerCustomerId, subscriptionId, currencyCode, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscriptionResourceGroupUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubscriptionWithResourceGroups(resellerCustomerId, subscriptionId, currencyCode, from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups_4(model?: SubscriptionUsageCostRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscriptionResourceGroupUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubscriptionWithResourceGroups_4(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription_5(model?: SubscriptionUsageCostRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfSubscriptionUsageCost> {
            const localVarFetchArgs = UsageCostApiFetchParamCreator(configuration).getForSubscription_5(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsageCostApi - factory interface
 * @export
 */
export const UsageCostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory(resellerCustomerId: number, subscriptionId: string, category: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForCategory(resellerCustomerId, subscriptionId, category, currencyCode, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForCategory_1(model?: CategoryUsageCostRequest, options?: any) {
            return UsageCostApiFp(configuration).getForCategory_1(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForOrganization(organizationId: number, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForOrganization(organizationId, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} resourceGroup 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup(resellerCustomerId: number, subscriptionId: string, resourceGroup: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForResourceGroup(resellerCustomerId, subscriptionId, resourceGroup, currencyCode, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ResourceGroupUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForResourceGroup_2(model?: ResourceGroupUsageCostRequest, options?: any) {
            return UsageCostApiFp(configuration).getForResourceGroup_2(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} category 
         * @param {string} subcategory 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory(resellerCustomerId: number, subscriptionId: string, category: string, subcategory: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForSubcategory(resellerCustomerId, subscriptionId, category, subcategory, currencyCode, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubcategoryUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubcategory_3(model?: SubcategoryUsageCostRequest, options?: any) {
            return UsageCostApiFp(configuration).getForSubcategory_3(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForSubscription(resellerCustomerId, subscriptionId, currencyCode, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} resellerCustomerId 
         * @param {string} subscriptionId 
         * @param {string} currencyCode 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
            return UsageCostApiFp(configuration).getForSubscriptionWithResourceGroups(resellerCustomerId, subscriptionId, currencyCode, from, to, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscriptionWithResourceGroups_4(model?: SubscriptionUsageCostRequest, options?: any) {
            return UsageCostApiFp(configuration).getForSubscriptionWithResourceGroups_4(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SubscriptionUsageCostRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForSubscription_5(model?: SubscriptionUsageCostRequest, options?: any) {
            return UsageCostApiFp(configuration).getForSubscription_5(model, options)(fetch, basePath);
        },
    };
};

/**
 * UsageCostApi - object-oriented interface
 * @export
 * @class UsageCostApi
 * @extends {BaseAPI}
 */
export class UsageCostApi extends BaseAPI {
    /**
     * 
     * @param {number} resellerCustomerId 
     * @param {string} subscriptionId 
     * @param {string} category 
     * @param {string} currencyCode 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForCategory(resellerCustomerId: number, subscriptionId: string, category: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForCategory(resellerCustomerId, subscriptionId, category, currencyCode, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CategoryUsageCostRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForCategory_1(model?: CategoryUsageCostRequest, options?: any) {
        return UsageCostApiFp(this.configuration).getForCategory_1(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForOrganization(organizationId: number, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForOrganization(organizationId, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} resellerCustomerId 
     * @param {string} subscriptionId 
     * @param {string} resourceGroup 
     * @param {string} currencyCode 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForResourceGroup(resellerCustomerId: number, subscriptionId: string, resourceGroup: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForResourceGroup(resellerCustomerId, subscriptionId, resourceGroup, currencyCode, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ResourceGroupUsageCostRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForResourceGroup_2(model?: ResourceGroupUsageCostRequest, options?: any) {
        return UsageCostApiFp(this.configuration).getForResourceGroup_2(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} resellerCustomerId 
     * @param {string} subscriptionId 
     * @param {string} category 
     * @param {string} subcategory 
     * @param {string} currencyCode 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubcategory(resellerCustomerId: number, subscriptionId: string, category: string, subcategory: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubcategory(resellerCustomerId, subscriptionId, category, subcategory, currencyCode, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubcategoryUsageCostRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubcategory_3(model?: SubcategoryUsageCostRequest, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubcategory_3(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} resellerCustomerId 
     * @param {string} subscriptionId 
     * @param {string} currencyCode 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubscription(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubscription(resellerCustomerId, subscriptionId, currencyCode, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} resellerCustomerId 
     * @param {string} subscriptionId 
     * @param {string} currencyCode 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubscriptionWithResourceGroups(resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubscriptionWithResourceGroups(resellerCustomerId, subscriptionId, currencyCode, from, to, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubscriptionUsageCostRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubscriptionWithResourceGroups_4(model?: SubscriptionUsageCostRequest, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubscriptionWithResourceGroups_4(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SubscriptionUsageCostRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageCostApi
     */
    public getForSubscription_5(model?: SubscriptionUsageCostRequest, options?: any) {
        return UsageCostApiFp(this.configuration).getForSubscription_5(model, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(user?: User, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserChangePassword} [changePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(id: string, changePassword?: UserChangePassword, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling changePassword.');
            }
            const localVarPath = `/api/v1/Users/{id}/changepassword`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserChangePassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(changePassword || {}) : (changePassword || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/api/v1/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {'None' | 'User' | 'TenantAdmin'} [role] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(search?: string, organizationId?: number, role?: 'None' | 'User' | 'TenantAdmin', page?: number, pageSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['OrganizationId'] = organizationId;
            }

            if (role !== undefined) {
                localVarQueryParameter['Role'] = role;
            }

            if (page !== undefined) {
                localVarQueryParameter['Page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getUserById.');
            }
            const localVarPath = `/api/v1/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(userName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/Users/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user?: User, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUser.');
            }
            const localVarPath = `/api/v1/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(user?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).addUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserChangePassword} [changePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(id: string, changePassword?: UserChangePassword, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).changePassword(id, changePassword, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {'None' | 'User' | 'TenantAdmin'} [role] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(search?: string, organizationId?: number, role?: 'None' | 'User' | 'TenantAdmin', page?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiCollectionOfUser> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).get(search, organizationId, role, page, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(userName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserByUserName(userName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user?: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(id, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(user?: User, options?: any) {
            return UsersApiFp(configuration).addUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UserChangePassword} [changePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(id: string, changePassword?: UserChangePassword, options?: any) {
            return UsersApiFp(configuration).changePassword(id, changePassword, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [organizationId] 
         * @param {'None' | 'User' | 'TenantAdmin'} [role] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(search?: string, organizationId?: number, role?: 'None' | 'User' | 'TenantAdmin', page?: number, pageSize?: number, options?: any) {
            return UsersApiFp(configuration).get(search, organizationId, role, page, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: any) {
            return UsersApiFp(configuration).getUserById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [userName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserName(userName?: string, options?: any) {
            return UsersApiFp(configuration).getUserByUserName(userName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user?: User, options?: any) {
            return UsersApiFp(configuration).updateUser(id, user, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUser(user?: User, options?: any) {
        return UsersApiFp(this.configuration).addUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {UserChangePassword} [changePassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePassword(id: string, changePassword?: UserChangePassword, options?: any) {
        return UsersApiFp(this.configuration).changePassword(id, changePassword, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [search] 
     * @param {number} [organizationId] 
     * @param {'None' | 'User' | 'TenantAdmin'} [role] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public get(search?: string, organizationId?: number, role?: 'None' | 'User' | 'TenantAdmin', page?: number, pageSize?: number, options?: any) {
        return UsersApiFp(this.configuration).get(search, organizationId, role, page, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(id: string, options?: any) {
        return UsersApiFp(this.configuration).getUserById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [userName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByUserName(userName?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserByUserName(userName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: string, user?: User, options?: any) {
        return UsersApiFp(this.configuration).updateUser(id, user, options)(this.fetch, this.basePath);
    }

}

