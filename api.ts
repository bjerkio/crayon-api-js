/**
 * Crayon Group Customer API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://apiv1.crayon.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class ActivationLink {
    'subscriptionId'?: string;
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "Uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActivationLink.attributeTypeMap;
    }
}

export class ActivityLog {
    'entity'?: string;
    'items'?: Array<ActivityLogItem>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "Entity",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ActivityLogItem>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActivityLog.attributeTypeMap;
    }
}

export class ActivityLogItem {
    'entity'?: string;
    'id'?: number;
    'changedBy'?: string;
    'changedDate'?: Date;
    'changedColumn'?: string;
    'changedFrom'?: string;
    'changedTo'?: string;
    'customValues'?: { [key: string]: string; };
    'changeType'?: ActivityLogItem.ChangeTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entity",
            "baseName": "Entity",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "changedBy",
            "baseName": "ChangedBy",
            "type": "string"
        },
        {
            "name": "changedDate",
            "baseName": "ChangedDate",
            "type": "Date"
        },
        {
            "name": "changedColumn",
            "baseName": "ChangedColumn",
            "type": "string"
        },
        {
            "name": "changedFrom",
            "baseName": "ChangedFrom",
            "type": "string"
        },
        {
            "name": "changedTo",
            "baseName": "ChangedTo",
            "type": "string"
        },
        {
            "name": "customValues",
            "baseName": "CustomValues",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "changeType",
            "baseName": "ChangeType",
            "type": "ActivityLogItem.ChangeTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ActivityLogItem.attributeTypeMap;
    }
}

export namespace ActivityLogItem {
    export enum ChangeTypeEnum {
        Delete = <any> 'Delete',
        Insert = <any> 'Insert',
        Update = <any> 'Update'
    }
}
export class Address {
    'id'?: number;
    'organization'?: ObjectReference;
    'name'?: string;
    'completeAddress'?: string;
    'street'?: string;
    'zipCode'?: string;
    'city'?: string;
    'county'?: string;
    'state'?: string;
    'countryCode'?: string;
    'primary'?: boolean;
    'addressType'?: Address.AddressTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "completeAddress",
            "baseName": "CompleteAddress",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "zipCode",
            "baseName": "ZipCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "County",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "State",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "primary",
            "baseName": "Primary",
            "type": "boolean"
        },
        {
            "name": "addressType",
            "baseName": "AddressType",
            "type": "Address.AddressTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Address.attributeTypeMap;
    }
}

export namespace Address {
    export enum AddressTypeEnum {
        None = <any> 'None',
        Invoice = <any> 'Invoice',
        Delivery = <any> 'Delivery'
    }
}
export class AddressData {
    'axAddressId'?: number;
    'name'?: string;
    'completeAddress'?: string;
    'street'?: string;
    'zipCode'?: string;
    'city'?: string;
    'county'?: string;
    'state'?: string;
    'countryCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "axAddressId",
            "baseName": "AxAddressId",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "completeAddress",
            "baseName": "CompleteAddress",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "Street",
            "type": "string"
        },
        {
            "name": "zipCode",
            "baseName": "ZipCode",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "County",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "State",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "CountryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddressData.attributeTypeMap;
    }
}

export class AggregationItem {
    'key'?: string;
    'docCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "docCount",
            "baseName": "DocCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AggregationItem.attributeTypeMap;
    }
}

export class Agreement {
    'id'?: number;
    'organization'?: ObjectReference;
    'name'?: string;
    'salesPriceCurrencyCode'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'disabled'?: boolean;
    'publisher'?: ObjectReference;
    'program'?: ObjectReference;
    'number'?: string;
    'customerNumber'?: string;
    'masterAgreement'?: string;
    'hasTerms'?: boolean;
    'agreementType'?: Agreement.AgreementTypeEnum;
    'parentAgreementId'?: number;
    'commitmentLevel'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "salesPriceCurrencyCode",
            "baseName": "SalesPriceCurrencyCode",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "disabled",
            "baseName": "Disabled",
            "type": "boolean"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "ObjectReference"
        },
        {
            "name": "number",
            "baseName": "Number",
            "type": "string"
        },
        {
            "name": "customerNumber",
            "baseName": "CustomerNumber",
            "type": "string"
        },
        {
            "name": "masterAgreement",
            "baseName": "MasterAgreement",
            "type": "string"
        },
        {
            "name": "hasTerms",
            "baseName": "HasTerms",
            "type": "boolean"
        },
        {
            "name": "agreementType",
            "baseName": "AgreementType",
            "type": "Agreement.AgreementTypeEnum"
        },
        {
            "name": "parentAgreementId",
            "baseName": "ParentAgreementId",
            "type": "number"
        },
        {
            "name": "commitmentLevel",
            "baseName": "CommitmentLevel",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Agreement.attributeTypeMap;
    }
}

export namespace Agreement {
    export enum AgreementTypeEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}
export class AgreementAccess {
    'hasAccess'?: boolean;
    'agreement'?: Agreement;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hasAccess",
            "baseName": "HasAccess",
            "type": "boolean"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "Agreement"
        }    ];

    static getAttributeTypeMap() {
        return AgreementAccess.attributeTypeMap;
    }
}

export class AgreementCollection {
    'filter'?: AgreementFilter;
    'items'?: Array<Agreement>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filter",
            "baseName": "Filter",
            "type": "AgreementFilter"
        },
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Agreement>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AgreementCollection.attributeTypeMap;
    }
}

export class AgreementFilter {
    'organizationId'?: number;
    'organizationIds'?: Array<number>;
    'pricelistIds'?: Array<number>;
    'status'?: AgreementFilter.StatusEnum;
    'agreementTypes'?: Array<AgreementFilter.AgreementTypesEnum>;
    'publisherIds'?: Array<number>;
    'programIds'?: Array<number>;
    'searchDate'?: Date;
    'agreementIds'?: Array<number>;
    'salesPriceCurrency'?: string;
    'termRequired'?: boolean;
    'publisherId'?: number;
    'endDateFrom'?: Date;
    'endDateTo'?: Date;
    'page'?: number;
    'pageSize'?: number;
    'search'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "OrganizationId",
            "type": "number"
        },
        {
            "name": "organizationIds",
            "baseName": "OrganizationIds",
            "type": "Array<number>"
        },
        {
            "name": "pricelistIds",
            "baseName": "PricelistIds",
            "type": "Array<number>"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "AgreementFilter.StatusEnum"
        },
        {
            "name": "agreementTypes",
            "baseName": "AgreementTypes",
            "type": "Array<AgreementFilter.AgreementTypesEnum>"
        },
        {
            "name": "publisherIds",
            "baseName": "PublisherIds",
            "type": "Array<number>"
        },
        {
            "name": "programIds",
            "baseName": "ProgramIds",
            "type": "Array<number>"
        },
        {
            "name": "searchDate",
            "baseName": "SearchDate",
            "type": "Date"
        },
        {
            "name": "agreementIds",
            "baseName": "AgreementIds",
            "type": "Array<number>"
        },
        {
            "name": "salesPriceCurrency",
            "baseName": "SalesPriceCurrency",
            "type": "string"
        },
        {
            "name": "termRequired",
            "baseName": "TermRequired",
            "type": "boolean"
        },
        {
            "name": "publisherId",
            "baseName": "PublisherId",
            "type": "number"
        },
        {
            "name": "endDateFrom",
            "baseName": "EndDateFrom",
            "type": "Date"
        },
        {
            "name": "endDateTo",
            "baseName": "EndDateTo",
            "type": "Date"
        },
        {
            "name": "page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "PageSize",
            "type": "number"
        },
        {
            "name": "search",
            "baseName": "Search",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AgreementFilter.attributeTypeMap;
    }
}

export namespace AgreementFilter {
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Inactive = <any> 'Inactive',
        ActiveInactive = <any> 'ActiveInactive'
    }
    export enum AgreementTypesEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}
export class AgreementIdentityReference {
    'id'?: number;
    'name'?: string;
    'agreementNumber'?: string;
    'commitmentLevel'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "agreementNumber",
            "baseName": "AgreementNumber",
            "type": "string"
        },
        {
            "name": "commitmentLevel",
            "baseName": "CommitmentLevel",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AgreementIdentityReference.attributeTypeMap;
    }
}

export class AgreementIdentityReferenceDto {
    'agreementNumber'?: string;
    'commitmentLevel'?: number;
    'id'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementNumber",
            "baseName": "AgreementNumber",
            "type": "string"
        },
        {
            "name": "commitmentLevel",
            "baseName": "CommitmentLevel",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AgreementIdentityReferenceDto.attributeTypeMap;
    }
}

export class AgreementProduct {
    'uniqueId'?: string;
    'productType'?: AgreementProduct.ProductTypeEnum;
    'productVariant'?: ProductVariant;
    'agreement'?: ObjectReference;
    'name'?: string;
    'priceId'?: number;
    'recommendedRetailPrice'?: Price;
    'salesPrice'?: Price;
    'alternativeSalesPrice'?: Price;
    'priceListName'?: string;
    'monthMultiplier'?: number;
    'priceCalculationType'?: AgreementProduct.PriceCalculationTypeEnum;
    'agreementType'?: AgreementProduct.AgreementTypeEnum;
    'productInformation'?: ProductInformation;
    'minimumQuantity'?: number;
    'maximumQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uniqueId",
            "baseName": "UniqueId",
            "type": "string"
        },
        {
            "name": "productType",
            "baseName": "ProductType",
            "type": "AgreementProduct.ProductTypeEnum"
        },
        {
            "name": "productVariant",
            "baseName": "ProductVariant",
            "type": "ProductVariant"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "ObjectReference"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "priceId",
            "baseName": "PriceId",
            "type": "number"
        },
        {
            "name": "recommendedRetailPrice",
            "baseName": "RecommendedRetailPrice",
            "type": "Price"
        },
        {
            "name": "salesPrice",
            "baseName": "SalesPrice",
            "type": "Price"
        },
        {
            "name": "alternativeSalesPrice",
            "baseName": "AlternativeSalesPrice",
            "type": "Price"
        },
        {
            "name": "priceListName",
            "baseName": "PriceListName",
            "type": "string"
        },
        {
            "name": "monthMultiplier",
            "baseName": "MonthMultiplier",
            "type": "number"
        },
        {
            "name": "priceCalculationType",
            "baseName": "PriceCalculationType",
            "type": "AgreementProduct.PriceCalculationTypeEnum"
        },
        {
            "name": "agreementType",
            "baseName": "AgreementType",
            "type": "AgreementProduct.AgreementTypeEnum"
        },
        {
            "name": "productInformation",
            "baseName": "ProductInformation",
            "type": "ProductInformation"
        },
        {
            "name": "minimumQuantity",
            "baseName": "MinimumQuantity",
            "type": "number"
        },
        {
            "name": "maximumQuantity",
            "baseName": "MaximumQuantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AgreementProduct.attributeTypeMap;
    }
}

export namespace AgreementProduct {
    export enum ProductTypeEnum {
        Product = <any> 'Product',
        Bundle = <any> 'Bundle',
        Service = <any> 'Service',
        Internal = <any> 'Internal'
    }
    export enum PriceCalculationTypeEnum {
        None = <any> 'None',
        Default = <any> 'Default',
        SelectPlus = <any> 'SelectPlus',
        AdobeVip = <any> 'AdobeVip',
        Mpsa = <any> 'Mpsa'
    }
    export enum AgreementTypeEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
}
export class AgreementProductCollection {
    'publishers'?: Array<PublisherAggregationItem>;
    'filter'?: AgreementProductFilter;
    'pools'?: Array<AggregationItem>;
    'operatingSystems'?: Array<AggregationItem>;
    'offerings'?: Array<AggregationItem>;
    'levels'?: Array<AggregationItem>;
    'languages'?: Array<AggregationItem>;
    'licenseAgreementTypes'?: Array<AggregationItem>;
    'licenseTypes'?: Array<AggregationItem>;
    'productFamilies'?: Array<AggregationItem>;
    'programs'?: Array<AggregationItem>;
    'productTypes'?: Array<AggregationItem>;
    'purchasePeriods'?: Array<AggregationItem>;
    'purchaseUnits'?: Array<AggregationItem>;
    'versions'?: Array<AggregationItem>;
    'regions'?: Array<AggregationItem>;
    'productCategories'?: Array<AggregationItem>;
    'agreements'?: Array<ObjectReference>;
    'items'?: Array<AgreementProduct>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "publishers",
            "baseName": "Publishers",
            "type": "Array<PublisherAggregationItem>"
        },
        {
            "name": "filter",
            "baseName": "Filter",
            "type": "AgreementProductFilter"
        },
        {
            "name": "pools",
            "baseName": "Pools",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "operatingSystems",
            "baseName": "OperatingSystems",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "offerings",
            "baseName": "Offerings",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "levels",
            "baseName": "Levels",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "languages",
            "baseName": "Languages",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "licenseAgreementTypes",
            "baseName": "LicenseAgreementTypes",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "licenseTypes",
            "baseName": "LicenseTypes",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "productFamilies",
            "baseName": "ProductFamilies",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "programs",
            "baseName": "Programs",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "productTypes",
            "baseName": "ProductTypes",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "purchasePeriods",
            "baseName": "PurchasePeriods",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "purchaseUnits",
            "baseName": "PurchaseUnits",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "versions",
            "baseName": "Versions",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "regions",
            "baseName": "Regions",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "productCategories",
            "baseName": "ProductCategories",
            "type": "Array<AggregationItem>"
        },
        {
            "name": "agreements",
            "baseName": "Agreements",
            "type": "Array<ObjectReference>"
        },
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<AgreementProduct>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AgreementProductCollection.attributeTypeMap;
    }
}

export class AgreementProductFilter {
    'agreementTypeIds'?: Array<AgreementProductFilter.AgreementTypeIdsEnum>;
    'page'?: number;
    'pageSize'?: number;
    'search'?: string;
    'priceListId'?: number;
    'organizationId'?: number;
    'customerTenantId'?: number;
    'agreementId'?: number;
    'isTrial'?: boolean;
    'agreementIds'?: Array<number>;
    'searchDate'?: Date;
    'include'?: AgreementProductsSubFilter;
    'exclude'?: AgreementProductsSubFilter;
    'sortKey'?: string;
    'includeProductInformation'?: boolean;
    'sortOrder'?: AgreementProductFilter.SortOrderEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementTypeIds",
            "baseName": "AgreementTypeIds",
            "type": "Array<AgreementProductFilter.AgreementTypeIdsEnum>"
        },
        {
            "name": "page",
            "baseName": "Page",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "PageSize",
            "type": "number"
        },
        {
            "name": "search",
            "baseName": "Search",
            "type": "string"
        },
        {
            "name": "priceListId",
            "baseName": "PriceListId",
            "type": "number"
        },
        {
            "name": "organizationId",
            "baseName": "OrganizationId",
            "type": "number"
        },
        {
            "name": "customerTenantId",
            "baseName": "CustomerTenantId",
            "type": "number"
        },
        {
            "name": "agreementId",
            "baseName": "AgreementId",
            "type": "number"
        },
        {
            "name": "isTrial",
            "baseName": "IsTrial",
            "type": "boolean"
        },
        {
            "name": "agreementIds",
            "baseName": "AgreementIds",
            "type": "Array<number>"
        },
        {
            "name": "searchDate",
            "baseName": "SearchDate",
            "type": "Date"
        },
        {
            "name": "include",
            "baseName": "Include",
            "type": "AgreementProductsSubFilter"
        },
        {
            "name": "exclude",
            "baseName": "Exclude",
            "type": "AgreementProductsSubFilter"
        },
        {
            "name": "sortKey",
            "baseName": "SortKey",
            "type": "string"
        },
        {
            "name": "includeProductInformation",
            "baseName": "IncludeProductInformation",
            "type": "boolean"
        },
        {
            "name": "sortOrder",
            "baseName": "SortOrder",
            "type": "AgreementProductFilter.SortOrderEnum"
        }    ];

    static getAttributeTypeMap() {
        return AgreementProductFilter.attributeTypeMap;
    }
}

export namespace AgreementProductFilter {
    export enum AgreementTypeIdsEnum {
        None = <any> 'None',
        LicenseAgreement = <any> 'LicenseAgreement',
        OpenAgreement = <any> 'OpenAgreement',
        FrameAgreement = <any> 'FrameAgreement',
        SamAgreement = <any> 'SamAgreement',
        ConsultingAgreement = <any> 'ConsultingAgreement',
        CloudSeatAgreement = <any> 'CloudSeatAgreement',
        CloudUsageAgreement = <any> 'CloudUsageAgreement',
        ReportingAgreement = <any> 'ReportingAgreement',
        OtherAgreement = <any> 'OtherAgreement',
        Reserved1 = <any> 'Reserved1',
        Reserved2 = <any> 'Reserved2',
        Reserved3 = <any> 'Reserved3'
    }
    export enum SortOrderEnum {
        Ascending = <any> 'Ascending',
        Descending = <any> 'Descending'
    }
}
export class AgreementProductsSubFilter {
    'partNumbers'?: Array<string>;
    'publisherIds'?: Array<number>;
    'publisherNames'?: Array<string>;
    'poolNames'?: Array<string>;
    'operatingSystemNames'?: Array<string>;
    'levelNames'?: Array<string>;
    'languageNames'?: Array<string>;
    'licenseAgreementTypeNames'?: Array<string>;
    'licenseTypeNames'?: Array<string>;
    'productFamilyNames'?: Array<string>;
    'productTypeNames'?: Array<string>;
    'programNames'?: Array<string>;
    'offeringNames'?: Array<string>;
    'purchasePeriodNames'?: Array<string>;
    'purchaseUnitNames'?: Array<string>;
    'versionNames'?: Array<string>;
    'regionNames'?: Array<string>;
    'productCategoryNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "partNumbers",
            "baseName": "PartNumbers",
            "type": "Array<string>"
        },
        {
            "name": "publisherIds",
            "baseName": "PublisherIds",
            "type": "Array<number>"
        },
        {
            "name": "publisherNames",
            "baseName": "PublisherNames",
            "type": "Array<string>"
        },
        {
            "name": "poolNames",
            "baseName": "PoolNames",
            "type": "Array<string>"
        },
        {
            "name": "operatingSystemNames",
            "baseName": "OperatingSystemNames",
            "type": "Array<string>"
        },
        {
            "name": "levelNames",
            "baseName": "LevelNames",
            "type": "Array<string>"
        },
        {
            "name": "languageNames",
            "baseName": "LanguageNames",
            "type": "Array<string>"
        },
        {
            "name": "licenseAgreementTypeNames",
            "baseName": "LicenseAgreementTypeNames",
            "type": "Array<string>"
        },
        {
            "name": "licenseTypeNames",
            "baseName": "LicenseTypeNames",
            "type": "Array<string>"
        },
        {
            "name": "productFamilyNames",
            "baseName": "ProductFamilyNames",
            "type": "Array<string>"
        },
        {
            "name": "productTypeNames",
            "baseName": "ProductTypeNames",
            "type": "Array<string>"
        },
        {
            "name": "programNames",
            "baseName": "ProgramNames",
            "type": "Array<string>"
        },
        {
            "name": "offeringNames",
            "baseName": "OfferingNames",
            "type": "Array<string>"
        },
        {
            "name": "purchasePeriodNames",
            "baseName": "PurchasePeriodNames",
            "type": "Array<string>"
        },
        {
            "name": "purchaseUnitNames",
            "baseName": "PurchaseUnitNames",
            "type": "Array<string>"
        },
        {
            "name": "versionNames",
            "baseName": "VersionNames",
            "type": "Array<string>"
        },
        {
            "name": "regionNames",
            "baseName": "RegionNames",
            "type": "Array<string>"
        },
        {
            "name": "productCategoryNames",
            "baseName": "ProductCategoryNames",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return AgreementProductsSubFilter.attributeTypeMap;
    }
}

export class AgreementReport {
    'productContainer'?: ObjectReferenceDto;
    'agreement'?: AgreementIdentityReferenceDto;
    'status'?: AgreementReport.StatusEnum;
    'hasValidAgreementTerm'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productContainer",
            "baseName": "ProductContainer",
            "type": "ObjectReferenceDto"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "AgreementIdentityReferenceDto"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "AgreementReport.StatusEnum"
        },
        {
            "name": "hasValidAgreementTerm",
            "baseName": "HasValidAgreementTerm",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AgreementReport.attributeTypeMap;
    }
}

export namespace AgreementReport {
    export enum StatusEnum {
        None = <any> 'None',
        NotReported = <any> 'NotReported',
        ZeroUsageReported = <any> 'ZeroUsageReported',
        UsageReported = <any> 'UsageReported',
        UsageAndZeroUsageReported = <any> 'UsageAndZeroUsageReported'
    }
}
export class ApiCollectionOfAddress {
    'items'?: Array<Address>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Address>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAddress.attributeTypeMap;
    }
}

export class ApiCollectionOfAgreementReport {
    'items'?: Array<AgreementReport>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<AgreementReport>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAgreementReport.attributeTypeMap;
    }
}

export class ApiCollectionOfAsset {
    'items'?: Array<Asset>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Asset>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAsset.attributeTypeMap;
    }
}

export class ApiCollectionOfAssetOrder {
    'items'?: Array<AssetOrder>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<AssetOrder>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAssetOrder.attributeTypeMap;
    }
}

export class ApiCollectionOfAwsAccount {
    'items'?: Array<AwsAccount>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<AwsAccount>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAwsAccount.attributeTypeMap;
    }
}

export class ApiCollectionOfAzureSubscription {
    'items'?: Array<AzureSubscription>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<AzureSubscription>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfAzureSubscription.attributeTypeMap;
    }
}

export class ApiCollectionOfBillingCycle {
    'items'?: Array<BillingCycle>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<BillingCycle>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfBillingCycle.attributeTypeMap;
    }
}

export class ApiCollectionOfBillingStatement {
    'items'?: Array<BillingStatement>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<BillingStatement>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfBillingStatement.attributeTypeMap;
    }
}

export class ApiCollectionOfBlogItem {
    'items'?: Array<BlogItem>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<BlogItem>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfBlogItem.attributeTypeMap;
    }
}

export class ApiCollectionOfBoolean {
    'items'?: Array<boolean>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<boolean>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfBoolean.attributeTypeMap;
    }
}

export class ApiCollectionOfCategoryUsageCost {
    'items'?: Array<CategoryUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<CategoryUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfCategoryUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfClient {
    'items'?: Array<Client>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Client>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfClient.attributeTypeMap;
    }
}

export class ApiCollectionOfConsumer {
    'items'?: Array<Consumer>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Consumer>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfConsumer.attributeTypeMap;
    }
}

export class ApiCollectionOfCrayonAccount {
    'items'?: Array<CrayonAccount>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<CrayonAccount>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfCrayonAccount.attributeTypeMap;
    }
}

export class ApiCollectionOfCustomerTenant {
    'items'?: Array<CustomerTenant>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<CustomerTenant>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfCustomerTenant.attributeTypeMap;
    }
}

export class ApiCollectionOfGroupedBillingStatement {
    'items'?: Array<GroupedBillingStatement>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<GroupedBillingStatement>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfGroupedBillingStatement.attributeTypeMap;
    }
}

export class ApiCollectionOfGrouping {
    'items'?: Array<Grouping>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Grouping>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfGrouping.attributeTypeMap;
    }
}

export class ApiCollectionOfInvoiceProfile {
    'items'?: Array<InvoiceProfile>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<InvoiceProfile>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfInvoiceProfile.attributeTypeMap;
    }
}

export class ApiCollectionOfManagementLink {
    'items'?: Array<ManagementLink>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ManagementLink>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfManagementLink.attributeTypeMap;
    }
}

export class ApiCollectionOfManagementLinkGrouped {
    'items'?: Array<ManagementLinkGrouped>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ManagementLinkGrouped>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfManagementLinkGrouped.attributeTypeMap;
    }
}

export class ApiCollectionOfObjectReference {
    'items'?: Array<ObjectReference>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ObjectReference>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfObjectReference.attributeTypeMap;
    }
}

export class ApiCollectionOfOrganization {
    'items'?: Array<Organization>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Organization>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfOrganization.attributeTypeMap;
    }
}

export class ApiCollectionOfOrganizationAccess {
    'items'?: Array<OrganizationAccess>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<OrganizationAccess>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfOrganizationAccess.attributeTypeMap;
    }
}

export class ApiCollectionOfOrganizationUsageCost {
    'items'?: Array<OrganizationUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<OrganizationUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfOrganizationUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfProductContainer {
    'items'?: Array<ProductContainer>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ProductContainer>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfProductContainer.attributeTypeMap;
    }
}

export class ApiCollectionOfProgram {
    'items'?: Array<Program>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Program>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfProgram.attributeTypeMap;
    }
}

export class ApiCollectionOfPublisher {
    'items'?: Array<Publisher>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Publisher>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfPublisher.attributeTypeMap;
    }
}

export class ApiCollectionOfRegion {
    'items'?: Array<Region>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Region>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfRegion.attributeTypeMap;
    }
}

export class ApiCollectionOfResourceGroupUsageCost {
    'items'?: Array<ResourceGroupUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ResourceGroupUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfResourceGroupUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfServiceAccountAgreement {
    'items'?: Array<ServiceAccountAgreement>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<ServiceAccountAgreement>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfServiceAccountAgreement.attributeTypeMap;
    }
}

export class ApiCollectionOfSubcategoryUsageCost {
    'items'?: Array<SubcategoryUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<SubcategoryUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfSubcategoryUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfSubscription {
    'items'?: Array<Subscription>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<Subscription>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfSubscription.attributeTypeMap;
    }
}

export class ApiCollectionOfSubscriptionConversion {
    'items'?: Array<SubscriptionConversion>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<SubscriptionConversion>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfSubscriptionConversion.attributeTypeMap;
    }
}

export class ApiCollectionOfSubscriptionResourceGroupUsageCost {
    'items'?: Array<SubscriptionResourceGroupUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<SubscriptionResourceGroupUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfSubscriptionResourceGroupUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfSubscriptionUsageCost {
    'items'?: Array<SubscriptionUsageCost>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<SubscriptionUsageCost>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfSubscriptionUsageCost.attributeTypeMap;
    }
}

export class ApiCollectionOfUser {
    'items'?: Array<User>;
    'totalHits'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "Items",
            "type": "Array<User>"
        },
        {
            "name": "totalHits",
            "baseName": "TotalHits",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiCollectionOfUser.attributeTypeMap;
    }
}

export class Asset {
    'id'?: number;
    'status'?: Asset.StatusEnum;
    'externalOrderId'?: string;
    'quantity'?: number;
    'productId'?: number;
    'productVariantId'?: number;
    'startDate'?: Date;
    'expirationDate'?: Date;
    'resellerCustomerId'?: number;
    'scope'?: Asset.ScopeEnum;
    'assetType'?: Asset.AssetTypeEnum;
    'billingCycle'?: Asset.BillingCycleEnum;
    'publisherId'?: number;
    'programId'?: number;
    'reservationId'?: string;
    'reservationUsedInSubscriptionId'?: number;
    'reservationUsedInSubscription'?: SubscriptionLite;
    'purchaseCurrency'?: string;
    'purchasePrice'?: number;
    'salesCurrency'?: string;
    'salesPrice'?: number;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'changedBy'?: string;
    'resellerPriceType'?: Asset.ResellerPriceTypeEnum;
    'resellerPriceTypeValue'?: number;
    'reservedInstanceArtifactResourceId'?: string;
    'purchaseDate'?: Date;
    'productVariant'?: ProductVariant;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "Asset.StatusEnum"
        },
        {
            "name": "externalOrderId",
            "baseName": "ExternalOrderId",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "productId",
            "baseName": "ProductId",
            "type": "number"
        },
        {
            "name": "productVariantId",
            "baseName": "ProductVariantId",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "expirationDate",
            "baseName": "ExpirationDate",
            "type": "Date"
        },
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "scope",
            "baseName": "Scope",
            "type": "Asset.ScopeEnum"
        },
        {
            "name": "assetType",
            "baseName": "AssetType",
            "type": "Asset.AssetTypeEnum"
        },
        {
            "name": "billingCycle",
            "baseName": "BillingCycle",
            "type": "Asset.BillingCycleEnum"
        },
        {
            "name": "publisherId",
            "baseName": "PublisherId",
            "type": "number"
        },
        {
            "name": "programId",
            "baseName": "ProgramId",
            "type": "number"
        },
        {
            "name": "reservationId",
            "baseName": "ReservationId",
            "type": "string"
        },
        {
            "name": "reservationUsedInSubscriptionId",
            "baseName": "ReservationUsedInSubscriptionId",
            "type": "number"
        },
        {
            "name": "reservationUsedInSubscription",
            "baseName": "ReservationUsedInSubscription",
            "type": "SubscriptionLite"
        },
        {
            "name": "purchaseCurrency",
            "baseName": "PurchaseCurrency",
            "type": "string"
        },
        {
            "name": "purchasePrice",
            "baseName": "PurchasePrice",
            "type": "number"
        },
        {
            "name": "salesCurrency",
            "baseName": "SalesCurrency",
            "type": "string"
        },
        {
            "name": "salesPrice",
            "baseName": "SalesPrice",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "ModifiedDate",
            "type": "Date"
        },
        {
            "name": "changedBy",
            "baseName": "ChangedBy",
            "type": "string"
        },
        {
            "name": "resellerPriceType",
            "baseName": "ResellerPriceType",
            "type": "Asset.ResellerPriceTypeEnum"
        },
        {
            "name": "resellerPriceTypeValue",
            "baseName": "ResellerPriceTypeValue",
            "type": "number"
        },
        {
            "name": "reservedInstanceArtifactResourceId",
            "baseName": "ReservedInstanceArtifactResourceId",
            "type": "string"
        },
        {
            "name": "purchaseDate",
            "baseName": "PurchaseDate",
            "type": "Date"
        },
        {
            "name": "productVariant",
            "baseName": "ProductVariant",
            "type": "ProductVariant"
        }    ];

    static getAttributeTypeMap() {
        return Asset.attributeTypeMap;
    }
}

export namespace Asset {
    export enum StatusEnum {
        None = <any> 'None',
        Fulfilling = <any> 'Fulfilling',
        Succeeded = <any> 'Succeeded',
        Cancelled = <any> 'Cancelled',
        All = <any> 'All'
    }
    export enum ScopeEnum {
        Shared = <any> 'Shared',
        Single = <any> 'Single'
    }
    export enum AssetTypeEnum {
        Reservation = <any> 'Reservation',
        Software = <any> 'Software',
        Subscription = <any> 'Subscription'
    }
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime'
    }
    export enum ResellerPriceTypeEnum {
        None = <any> 'None',
        Margin = <any> 'Margin',
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}
export class AssetOrder {
    'externalOrderId'?: string;
    'countryCode'?: string;
    'resellerCustomerId'?: number;
    'errors'?: Array<AssetOrderError>;
    'orderLines'?: Array<AssetOrderLine>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "externalOrderId",
            "baseName": "ExternalOrderId",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "errors",
            "baseName": "Errors",
            "type": "Array<AssetOrderError>"
        },
        {
            "name": "orderLines",
            "baseName": "OrderLines",
            "type": "Array<AssetOrderLine>"
        }    ];

    static getAttributeTypeMap() {
        return AssetOrder.attributeTypeMap;
    }
}

export class AssetOrderError {
    'orderGroupId'?: string;
    'code'?: number;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderGroupId",
            "baseName": "OrderGroupId",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "Code",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "Description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssetOrderError.attributeTypeMap;
    }
}

export class AssetOrderLine {
    'productId'?: string;
    'subscriptionId'?: number;
    'armRegionName'?: string;
    'skuId'?: string;
    'productVariantId'?: number;
    'quantity'?: number;
    'billingCycle'?: AssetOrderLine.BillingCycleEnum;
    'provisioningContext'?: { [key: string]: string; };
    'type'?: AssetOrderLine.TypeEnum;
    'requiresInventoryCheck'?: boolean;
    'catalogItemId'?: string;
    'termDuration'?: string;
    'scope'?: AssetOrderLine.ScopeEnum;
    'resellerPriceType'?: AssetOrderLine.ResellerPriceTypeEnum;
    'resellerPriceTypeValue'?: number;
    'errors'?: Array<AssetOrderLineError>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productId",
            "baseName": "ProductId",
            "type": "string"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "number"
        },
        {
            "name": "armRegionName",
            "baseName": "ArmRegionName",
            "type": "string"
        },
        {
            "name": "skuId",
            "baseName": "SkuId",
            "type": "string"
        },
        {
            "name": "productVariantId",
            "baseName": "ProductVariantId",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "billingCycle",
            "baseName": "BillingCycle",
            "type": "AssetOrderLine.BillingCycleEnum"
        },
        {
            "name": "provisioningContext",
            "baseName": "ProvisioningContext",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "type",
            "baseName": "Type",
            "type": "AssetOrderLine.TypeEnum"
        },
        {
            "name": "requiresInventoryCheck",
            "baseName": "RequiresInventoryCheck",
            "type": "boolean"
        },
        {
            "name": "catalogItemId",
            "baseName": "CatalogItemId",
            "type": "string"
        },
        {
            "name": "termDuration",
            "baseName": "TermDuration",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "Scope",
            "type": "AssetOrderLine.ScopeEnum"
        },
        {
            "name": "resellerPriceType",
            "baseName": "ResellerPriceType",
            "type": "AssetOrderLine.ResellerPriceTypeEnum"
        },
        {
            "name": "resellerPriceTypeValue",
            "baseName": "ResellerPriceTypeValue",
            "type": "number"
        },
        {
            "name": "errors",
            "baseName": "Errors",
            "type": "Array<AssetOrderLineError>"
        }    ];

    static getAttributeTypeMap() {
        return AssetOrderLine.attributeTypeMap;
    }
}

export namespace AssetOrderLine {
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime'
    }
    export enum TypeEnum {
        Reservation = <any> 'Reservation',
        Software = <any> 'Software',
        Subscription = <any> 'Subscription'
    }
    export enum ScopeEnum {
        Shared = <any> 'Shared',
        Single = <any> 'Single'
    }
    export enum ResellerPriceTypeEnum {
        None = <any> 'None',
        Margin = <any> 'Margin',
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}
export class AssetOrderLineError {
    'reasonCode'?: string;
    'description'?: string;
    'properties'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reasonCode",
            "baseName": "ReasonCode",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "Properties",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return AssetOrderLineError.attributeTypeMap;
    }
}

export class AwsAccount {
    'id'?: number;
    'name'?: string;
    'email'?: string;
    'publisher'?: ObjectReference;
    'externalPublisherCustomerId'?: string;
    'reference'?: string;
    'customerTenantType'?: AwsAccount.CustomerTenantTypeEnum;
    'entityStatus'?: AwsAccount.EntityStatusEnum;
    'organization'?: Organization;
    'invoiceProfile'?: ObjectReference;
    'isActivated'?: boolean;
    'tags'?: SubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "externalPublisherCustomerId",
            "baseName": "ExternalPublisherCustomerId",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "Reference",
            "type": "string"
        },
        {
            "name": "customerTenantType",
            "baseName": "CustomerTenantType",
            "type": "AwsAccount.CustomerTenantTypeEnum"
        },
        {
            "name": "entityStatus",
            "baseName": "EntityStatus",
            "type": "AwsAccount.EntityStatusEnum"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "Organization"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "isActivated",
            "baseName": "IsActivated",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "Tags",
            "type": "SubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return AwsAccount.attributeTypeMap;
    }
}

export namespace AwsAccount {
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
}
export class AzurePlan {
    'id'?: number;
    'name'?: string;
    'publisherSubscriptionId'?: string;
    'status'?: AzurePlan.StatusEnum;
    'registeredForReservedInstance'?: boolean;
    'organization'?: ObjectReference;
    'customerTenant'?: CustomerTenantReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "AzurePlan.StatusEnum"
        },
        {
            "name": "registeredForReservedInstance",
            "baseName": "RegisteredForReservedInstance",
            "type": "boolean"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "customerTenant",
            "baseName": "CustomerTenant",
            "type": "CustomerTenantReference"
        }    ];

    static getAttributeTypeMap() {
        return AzurePlan.attributeTypeMap;
    }
}

export namespace AzurePlan {
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
}
export class AzureSubscription {
    'id'?: number;
    'azurePlanId'?: number;
    'publisherSubscriptionId'?: string;
    'friendlyName'?: string;
    'status'?: string;
    'invoiceProfile'?: ObjectReference;
    'tags'?: AzureSubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "azurePlanId",
            "baseName": "AzurePlanId",
            "type": "number"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "friendlyName",
            "baseName": "FriendlyName",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "tags",
            "baseName": "Tags",
            "type": "AzureSubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return AzureSubscription.attributeTypeMap;
    }
}

export class AzureSubscriptionTags {
    'costCenter'?: string;
    'department'?: string;
    'project'?: string;
    'custom'?: string;
    'owner'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costCenter",
            "baseName": "CostCenter",
            "type": "string"
        },
        {
            "name": "department",
            "baseName": "Department",
            "type": "string"
        },
        {
            "name": "project",
            "baseName": "Project",
            "type": "string"
        },
        {
            "name": "custom",
            "baseName": "Custom",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "Owner",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AzureSubscriptionTags.attributeTypeMap;
    }
}

export class BillingCycle {
    'id'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BillingCycle.attributeTypeMap;
    }
}

export class BillingStatement {
    'id'?: number;
    'totalSalesPrice'?: Price;
    'invoiceProfile'?: ObjectReference;
    'organization'?: ObjectReference;
    'startDate'?: Date;
    'endDate'?: Date;
    'provisionType'?: BillingStatement.ProvisionTypeEnum;
    'orderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "totalSalesPrice",
            "baseName": "TotalSalesPrice",
            "type": "Price"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "provisionType",
            "baseName": "ProvisionType",
            "type": "BillingStatement.ProvisionTypeEnum"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BillingStatement.attributeTypeMap;
    }
}

export namespace BillingStatement {
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
}
export class BlogItem {
    'title'?: string;
    'author'?: string;
    'description'?: string;
    'image'?: string;
    'link'?: string;
    'publicationDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "Title",
            "type": "string"
        },
        {
            "name": "author",
            "baseName": "Author",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "Image",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "Link",
            "type": "string"
        },
        {
            "name": "publicationDate",
            "baseName": "PublicationDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BlogItem.attributeTypeMap;
    }
}

export class CategoryUsageCost {
    'subcategory'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subcategory",
            "baseName": "Subcategory",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CategoryUsageCost.attributeTypeMap;
    }
}

export class CategoryUsageCostRequest {
    'resellerCustomerId'?: number;
    'subscriptionId'?: string;
    'category'?: string;
    'currencyCode'?: string;
    'from'?: Date;
    'to'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "Category",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "to",
            "baseName": "To",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CategoryUsageCostRequest.attributeTypeMap;
    }
}

export class Client {
    'clientId'?: string;
    'clientName'?: string;
    'clientUri'?: string;
    'enabled'?: boolean;
    'clientSecrets'?: Array<Secret>;
    'redirectUris'?: Array<string>;
    'timeStamp'?: Date;
    'flow'?: Client.FlowEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "clientName",
            "baseName": "ClientName",
            "type": "string"
        },
        {
            "name": "clientUri",
            "baseName": "ClientUri",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "Enabled",
            "type": "boolean"
        },
        {
            "name": "clientSecrets",
            "baseName": "ClientSecrets",
            "type": "Array<Secret>"
        },
        {
            "name": "redirectUris",
            "baseName": "RedirectUris",
            "type": "Array<string>"
        },
        {
            "name": "timeStamp",
            "baseName": "TimeStamp",
            "type": "Date"
        },
        {
            "name": "flow",
            "baseName": "Flow",
            "type": "Client.FlowEnum"
        }    ];

    static getAttributeTypeMap() {
        return Client.attributeTypeMap;
    }
}

export namespace Client {
    export enum FlowEnum {
        AuthorizationCode = <any> 'AuthorizationCode',
        Implicit = <any> 'Implicit',
        ResourceOwner = <any> 'ResourceOwner',
        Other = <any> 'Other'
    }
}
export class Consumer {
    'id'?: number;
    'name'?: string;
    'organization'?: ObjectReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        }    ];

    static getAttributeTypeMap() {
        return Consumer.attributeTypeMap;
    }
}

export class CrayonAccount {
    'id'?: number;
    'name'?: string;
    'email'?: string;
    'publisher'?: ObjectReference;
    'externalPublisherCustomerId'?: string;
    'reference'?: string;
    'customerTenantType'?: CrayonAccount.CustomerTenantTypeEnum;
    'entityStatus'?: CrayonAccount.EntityStatusEnum;
    'organization'?: Organization;
    'invoiceProfile'?: ObjectReference;
    'isActivated'?: boolean;
    'contact'?: CustomerTenantContact;
    'program'?: ObjectReference;
    'resellerMarkup'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "externalPublisherCustomerId",
            "baseName": "ExternalPublisherCustomerId",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "Reference",
            "type": "string"
        },
        {
            "name": "customerTenantType",
            "baseName": "CustomerTenantType",
            "type": "CrayonAccount.CustomerTenantTypeEnum"
        },
        {
            "name": "entityStatus",
            "baseName": "EntityStatus",
            "type": "CrayonAccount.EntityStatusEnum"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "Organization"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "isActivated",
            "baseName": "IsActivated",
            "type": "boolean"
        },
        {
            "name": "contact",
            "baseName": "Contact",
            "type": "CustomerTenantContact"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "ObjectReference"
        },
        {
            "name": "resellerMarkup",
            "baseName": "ResellerMarkup",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CrayonAccount.attributeTypeMap;
    }
}

export namespace CrayonAccount {
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
}
export class CreateAzureSubscriptionRequest {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAzureSubscriptionRequest.attributeTypeMap;
    }
}

export class CustomerTenant {
    'id'?: number;
    'name'?: string;
    'publisher'?: ObjectReference;
    'program'?: ObjectReference;
    'publisherCustomerId'?: string;
    'externalPublisherCustomerId'?: string;
    'domain'?: string;
    'domainPrefix'?: string;
    'reference'?: string;
    'customerTenantType'?: CustomerTenant.CustomerTenantTypeEnum;
    'entityStatus'?: CustomerTenant.EntityStatusEnum;
    'organization'?: Organization;
    'invoiceProfile'?: ObjectReference;
    'consumer'?: ObjectReference;
    'resellerMarkup'?: number;
    'defaultSubscriptionPriceType'?: CustomerTenant.DefaultSubscriptionPriceTypeEnum;
    'agreement'?: CustomerTenantAgreement;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "ObjectReference"
        },
        {
            "name": "publisherCustomerId",
            "baseName": "PublisherCustomerId",
            "type": "string"
        },
        {
            "name": "externalPublisherCustomerId",
            "baseName": "ExternalPublisherCustomerId",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "Domain",
            "type": "string"
        },
        {
            "name": "domainPrefix",
            "baseName": "DomainPrefix",
            "type": "string"
        },
        {
            "name": "reference",
            "baseName": "Reference",
            "type": "string"
        },
        {
            "name": "customerTenantType",
            "baseName": "CustomerTenantType",
            "type": "CustomerTenant.CustomerTenantTypeEnum"
        },
        {
            "name": "entityStatus",
            "baseName": "EntityStatus",
            "type": "CustomerTenant.EntityStatusEnum"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "Organization"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "consumer",
            "baseName": "Consumer",
            "type": "ObjectReference"
        },
        {
            "name": "resellerMarkup",
            "baseName": "ResellerMarkup",
            "type": "number"
        },
        {
            "name": "defaultSubscriptionPriceType",
            "baseName": "DefaultSubscriptionPriceType",
            "type": "CustomerTenant.DefaultSubscriptionPriceTypeEnum"
        },
        {
            "name": "agreement",
            "baseName": "agreement",
            "type": "CustomerTenantAgreement"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenant.attributeTypeMap;
    }
}

export namespace CustomerTenant {
    export enum CustomerTenantTypeEnum {
        None = <any> 'None',
        T1 = <any> 'T1',
        T2 = <any> 'T2'
    }
    export enum EntityStatusEnum {
        None = <any> 'None',
        Removed = <any> 'Removed'
    }
    export enum DefaultSubscriptionPriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}
export class CustomerTenantAddress {
    'firstName'?: string;
    'lastName'?: string;
    'addressLine1'?: string;
    'addressLine2'?: string;
    'addressLine3'?: string;
    'city'?: string;
    'region'?: string;
    'postalCode'?: string;
    'countryCode'?: string;
    'countryName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "addressLine1",
            "baseName": "AddressLine1",
            "type": "string"
        },
        {
            "name": "addressLine2",
            "baseName": "AddressLine2",
            "type": "string"
        },
        {
            "name": "addressLine3",
            "baseName": "AddressLine3",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "City",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "Region",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "PostalCode",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "CountryCode",
            "type": "string"
        },
        {
            "name": "countryName",
            "baseName": "CountryName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantAddress.attributeTypeMap;
    }
}

export class CustomerTenantAgreement {
    'firstName'?: string;
    'lastName'?: string;
    'phoneNumber'?: string;
    'email'?: string;
    'sameAsPrimaryContact'?: boolean;
    'dateAgreed'?: Date;
    'accepted'?: boolean;
    'agreementType'?: CustomerTenantAgreement.AgreementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "sameAsPrimaryContact",
            "baseName": "SameAsPrimaryContact",
            "type": "boolean"
        },
        {
            "name": "dateAgreed",
            "baseName": "DateAgreed",
            "type": "Date"
        },
        {
            "name": "accepted",
            "baseName": "Accepted",
            "type": "boolean"
        },
        {
            "name": "agreementType",
            "baseName": "AgreementType",
            "type": "CustomerTenantAgreement.AgreementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantAgreement.attributeTypeMap;
    }
}

export namespace CustomerTenantAgreement {
    export enum AgreementTypeEnum {
        MicrosoftCloudAgreement = <any> 'MicrosoftCloudAgreement',
        MicrosoftCustomerAgreement = <any> 'MicrosoftCustomerAgreement'
    }
}
export class CustomerTenantContact {
    'firstName'?: string;
    'lastName'?: string;
    'email'?: string;
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantContact.attributeTypeMap;
    }
}

export class CustomerTenantDetailed {
    'tenant'?: CustomerTenant;
    'user'?: CustomerTenantUser;
    'profile'?: CustomerTenantProfile;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tenant",
            "baseName": "Tenant",
            "type": "CustomerTenant"
        },
        {
            "name": "user",
            "baseName": "User",
            "type": "CustomerTenantUser"
        },
        {
            "name": "profile",
            "baseName": "Profile",
            "type": "CustomerTenantProfile"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantDetailed.attributeTypeMap;
    }
}

export class CustomerTenantProfile {
    'cultureCode'?: string;
    'languageCode'?: string;
    'contact'?: CustomerTenantContact;
    'address'?: CustomerTenantAddress;
    'agreement'?: CustomerTenantAgreement;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cultureCode",
            "baseName": "CultureCode",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "LanguageCode",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "Contact",
            "type": "CustomerTenantContact"
        },
        {
            "name": "address",
            "baseName": "Address",
            "type": "CustomerTenantAddress"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "CustomerTenantAgreement"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantProfile.attributeTypeMap;
    }
}

export class CustomerTenantReference {
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantReference.attributeTypeMap;
    }
}

export class CustomerTenantUser {
    'userName'?: string;
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "Password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTenantUser.attributeTypeMap;
    }
}

export class FacebookOrder {
    'lines'?: Array<FacebookOrderLine>;
    'contactName'?: string;
    'contactEmail'?: string;
    'consumerContactName'?: string;
    'consumerFullLegalName'?: string;
    'consumerContactEmail'?: string;
    'organizationId'?: number;
    'invoiceProfileId'?: number;
    'subscriptionStartDate'?: Date;
    'consumerSignupEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lines",
            "baseName": "Lines",
            "type": "Array<FacebookOrderLine>"
        },
        {
            "name": "contactName",
            "baseName": "ContactName",
            "type": "string"
        },
        {
            "name": "contactEmail",
            "baseName": "ContactEmail",
            "type": "string"
        },
        {
            "name": "consumerContactName",
            "baseName": "ConsumerContactName",
            "type": "string"
        },
        {
            "name": "consumerFullLegalName",
            "baseName": "ConsumerFullLegalName",
            "type": "string"
        },
        {
            "name": "consumerContactEmail",
            "baseName": "ConsumerContactEmail",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "OrganizationId",
            "type": "number"
        },
        {
            "name": "invoiceProfileId",
            "baseName": "InvoiceProfileId",
            "type": "number"
        },
        {
            "name": "subscriptionStartDate",
            "baseName": "SubscriptionStartDate",
            "type": "Date"
        },
        {
            "name": "consumerSignupEmail",
            "baseName": "ConsumerSignupEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FacebookOrder.attributeTypeMap;
    }
}

export class FacebookOrderLine {
    'publisherId'?: number;
    'agreementId'?: number;
    'productVariantId'?: number;
    'sku'?: string;
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "publisherId",
            "baseName": "PublisherId",
            "type": "number"
        },
        {
            "name": "agreementId",
            "baseName": "AgreementId",
            "type": "number"
        },
        {
            "name": "productVariantId",
            "baseName": "ProductVariantId",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FacebookOrderLine.attributeTypeMap;
    }
}

export class GoogleOrder {
    'lines'?: Array<GoogleOrderLine>;
    'contactName'?: string;
    'contactEmail'?: string;
    'consumerContactName'?: string;
    'consumerFullLegalName'?: string;
    'consumerContactEmail'?: string;
    'organizationId'?: number;
    'invoiceProfileId'?: number;
    'subscriptionStartDate'?: Date;
    'domainName'?: string;
    'consumerCountry'?: string;
    'consumerStreetAddress'?: string;
    'consumerCity'?: string;
    'consumerState'?: string;
    'consumerZipCode'?: string;
    'consumerPhoneNumber'?: string;
    'primaryAdminName'?: string;
    'primaryAdminUserName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lines",
            "baseName": "Lines",
            "type": "Array<GoogleOrderLine>"
        },
        {
            "name": "contactName",
            "baseName": "ContactName",
            "type": "string"
        },
        {
            "name": "contactEmail",
            "baseName": "ContactEmail",
            "type": "string"
        },
        {
            "name": "consumerContactName",
            "baseName": "ConsumerContactName",
            "type": "string"
        },
        {
            "name": "consumerFullLegalName",
            "baseName": "ConsumerFullLegalName",
            "type": "string"
        },
        {
            "name": "consumerContactEmail",
            "baseName": "ConsumerContactEmail",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "OrganizationId",
            "type": "number"
        },
        {
            "name": "invoiceProfileId",
            "baseName": "InvoiceProfileId",
            "type": "number"
        },
        {
            "name": "subscriptionStartDate",
            "baseName": "SubscriptionStartDate",
            "type": "Date"
        },
        {
            "name": "domainName",
            "baseName": "DomainName",
            "type": "string"
        },
        {
            "name": "consumerCountry",
            "baseName": "ConsumerCountry",
            "type": "string"
        },
        {
            "name": "consumerStreetAddress",
            "baseName": "ConsumerStreetAddress",
            "type": "string"
        },
        {
            "name": "consumerCity",
            "baseName": "ConsumerCity",
            "type": "string"
        },
        {
            "name": "consumerState",
            "baseName": "ConsumerState",
            "type": "string"
        },
        {
            "name": "consumerZipCode",
            "baseName": "ConsumerZipCode",
            "type": "string"
        },
        {
            "name": "consumerPhoneNumber",
            "baseName": "ConsumerPhoneNumber",
            "type": "string"
        },
        {
            "name": "primaryAdminName",
            "baseName": "PrimaryAdminName",
            "type": "string"
        },
        {
            "name": "primaryAdminUserName",
            "baseName": "PrimaryAdminUserName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GoogleOrder.attributeTypeMap;
    }
}

export class GoogleOrderLine {
    'publisherId'?: number;
    'agreementId'?: number;
    'productVariantId'?: number;
    'sku'?: string;
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "publisherId",
            "baseName": "PublisherId",
            "type": "number"
        },
        {
            "name": "agreementId",
            "baseName": "AgreementId",
            "type": "number"
        },
        {
            "name": "productVariantId",
            "baseName": "ProductVariantId",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "Sku",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GoogleOrderLine.attributeTypeMap;
    }
}

export class GroupedBillingStatement {
    'groupId'?: number;
    'id'?: number;
    'totalSalesPrice'?: Price;
    'invoiceProfile'?: ObjectReference;
    'organization'?: ObjectReference;
    'startDate'?: Date;
    'endDate'?: Date;
    'provisionType'?: GroupedBillingStatement.ProvisionTypeEnum;
    'orderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupId",
            "baseName": "GroupId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "totalSalesPrice",
            "baseName": "TotalSalesPrice",
            "type": "Price"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "provisionType",
            "baseName": "ProvisionType",
            "type": "GroupedBillingStatement.ProvisionTypeEnum"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GroupedBillingStatement.attributeTypeMap;
    }
}

export namespace GroupedBillingStatement {
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
}
export class Grouping {
    'id'?: number;
    'name'?: string;
    'invoiceProfile'?: ObjectReference;
    'organization'?: ObjectReference;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'isDisabled'?: boolean;
    'isRemoved'?: boolean;
    'invoiceReference'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "createdDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "ModifiedDate",
            "type": "Date"
        },
        {
            "name": "isDisabled",
            "baseName": "IsDisabled",
            "type": "boolean"
        },
        {
            "name": "isRemoved",
            "baseName": "IsRemoved",
            "type": "boolean"
        },
        {
            "name": "invoiceReference",
            "baseName": "InvoiceReference",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Grouping.attributeTypeMap;
    }
}

export class InvoiceProfile {
    'id'?: number;
    'organization'?: ObjectReference;
    'name'?: string;
    'invoiceReference'?: string;
    'customerReference'?: string;
    'requisitionNumber'?: string;
    'invoiceAddressId'?: number;
    'deliveryAddressId'?: number;
    'deliveryAddress'?: AddressData;
    'invoiceAddress'?: AddressData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "invoiceReference",
            "baseName": "InvoiceReference",
            "type": "string"
        },
        {
            "name": "customerReference",
            "baseName": "CustomerReference",
            "type": "string"
        },
        {
            "name": "requisitionNumber",
            "baseName": "RequisitionNumber",
            "type": "string"
        },
        {
            "name": "invoiceAddressId",
            "baseName": "InvoiceAddressId",
            "type": "number"
        },
        {
            "name": "deliveryAddressId",
            "baseName": "DeliveryAddressId",
            "type": "number"
        },
        {
            "name": "deliveryAddress",
            "baseName": "DeliveryAddress",
            "type": "AddressData"
        },
        {
            "name": "invoiceAddress",
            "baseName": "InvoiceAddress",
            "type": "AddressData"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceProfile.attributeTypeMap;
    }
}

export class ManagementLink {
    'link'?: string;
    'resellerCustomer'?: ObjectReference;
    'subscription'?: ObjectReference;
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "Link",
            "type": "string"
        },
        {
            "name": "resellerCustomer",
            "baseName": "ResellerCustomer",
            "type": "ObjectReference"
        },
        {
            "name": "subscription",
            "baseName": "Subscription",
            "type": "ObjectReference"
        },
        {
            "name": "text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ManagementLink.attributeTypeMap;
    }
}

export class ManagementLinkGrouped {
    'link'?: string;
    'resellerCustomer'?: ObjectReference;
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "Link",
            "type": "string"
        },
        {
            "name": "resellerCustomer",
            "baseName": "ResellerCustomer",
            "type": "ObjectReference"
        },
        {
            "name": "text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ManagementLinkGrouped.attributeTypeMap;
    }
}

export class Me {
    'userId'?: string;
    'userName'?: string;
    'token'?: string;
    'claims'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "Token",
            "type": "string"
        },
        {
            "name": "claims",
            "baseName": "Claims",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Me.attributeTypeMap;
    }
}

export class MinimumCommitmentLight {
    'id'?: number;
    'months'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "months",
            "baseName": "Months",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MinimumCommitmentLight.attributeTypeMap;
    }
}

export class ObjectReference {
    'id'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObjectReference.attributeTypeMap;
    }
}

export class ObjectReferenceDto {
    'id'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ObjectReferenceDto.attributeTypeMap;
    }
}

export class Organization {
    'id'?: number;
    'name'?: string;
    'parentId'?: number;
    'crayonCompanyName'?: string;
    'accountNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "ParentId",
            "type": "number"
        },
        {
            "name": "crayonCompanyName",
            "baseName": "CrayonCompanyName",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "AccountNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Organization.attributeTypeMap;
    }
}

export class OrganizationAccess {
    'id'?: number;
    'allAgreements'?: boolean;
    'agreements'?: Array<AgreementAccess>;
    'organization'?: Organization;
    'user'?: UserProfile;
    'role'?: OrganizationAccess.RoleEnum;
    'crayonCompanyName'?: string;
    'timestamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "allAgreements",
            "baseName": "AllAgreements",
            "type": "boolean"
        },
        {
            "name": "agreements",
            "baseName": "Agreements",
            "type": "Array<AgreementAccess>"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "Organization"
        },
        {
            "name": "user",
            "baseName": "User",
            "type": "UserProfile"
        },
        {
            "name": "role",
            "baseName": "Role",
            "type": "OrganizationAccess.RoleEnum"
        },
        {
            "name": "crayonCompanyName",
            "baseName": "CrayonCompanyName",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "Timestamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationAccess.attributeTypeMap;
    }
}

export namespace OrganizationAccess {
    export enum RoleEnum {
        None = <any> 'None',
        User = <any> 'User',
        Administrator = <any> 'Administrator',
        Viewer = <any> 'Viewer',
        EditRights = <any> 'EditRights',
        All = <any> 'All'
    }
}
export class OrganizationSalesContact {
    'fullName'?: string;
    'email'?: string;
    'phone'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fullName",
            "baseName": "FullName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "Phone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationSalesContact.attributeTypeMap;
    }
}

export class OrganizationUsageCost {
    'supplier'?: string;
    'accountId'?: number;
    'accountName'?: string;
    'subscriptionName'?: string;
    'subscriptionId'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "supplier",
            "baseName": "Supplier",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "AccountId",
            "type": "number"
        },
        {
            "name": "accountName",
            "baseName": "AccountName",
            "type": "string"
        },
        {
            "name": "subscriptionName",
            "baseName": "SubscriptionName",
            "type": "string"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationUsageCost.attributeTypeMap;
    }
}

export class Price {
    'value'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "Value",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Price.attributeTypeMap;
    }
}

export class ProductContainer {
    'id'?: number;
    'orderListId'?: number;
    'note'?: string;
    'usageMonth'?: Date;
    'name'?: string;
    'activeDraft'?: boolean;
    'removed'?: boolean;
    'createdByUserId'?: string;
    'axContactUserId'?: string;
    'createdDate'?: Date;
    'orderStatusChangedDate'?: Date;
    'contactUser'?: UserProfile;
    'organization'?: ObjectReference;
    'publisher'?: ObjectReference;
    'program'?: Program;
    'productRows'?: Array<ProductRow>;
    'comments'?: Array<ProductContainerComment>;
    'invoiceProfile'?: InvoiceProfile;
    'deliveryAddress'?: AddressData;
    'invoiceAddress'?: AddressData;
    'type'?: ProductContainer.TypeEnum;
    'category'?: ProductContainer.CategoryEnum;
    'quoteValidToDate'?: Date;
    'totalSalesPrice'?: Array<Price>;
    'totalAlternativeSalesPrice'?: Array<Price>;
    'issues'?: Array<ProductContainerIssue>;
    'submittedBy'?: ProductContainerCommentUser;
    'sent'?: Date;
    'invoiceReference'?: string;
    'orderReference'?: string;
    'requisition'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "orderListId",
            "baseName": "OrderListId",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "Note",
            "type": "string"
        },
        {
            "name": "usageMonth",
            "baseName": "UsageMonth",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "activeDraft",
            "baseName": "ActiveDraft",
            "type": "boolean"
        },
        {
            "name": "removed",
            "baseName": "Removed",
            "type": "boolean"
        },
        {
            "name": "createdByUserId",
            "baseName": "CreatedByUserId",
            "type": "string"
        },
        {
            "name": "axContactUserId",
            "baseName": "AxContactUserId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "orderStatusChangedDate",
            "baseName": "OrderStatusChangedDate",
            "type": "Date"
        },
        {
            "name": "contactUser",
            "baseName": "ContactUser",
            "type": "UserProfile"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "Program"
        },
        {
            "name": "productRows",
            "baseName": "ProductRows",
            "type": "Array<ProductRow>"
        },
        {
            "name": "comments",
            "baseName": "Comments",
            "type": "Array<ProductContainerComment>"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "InvoiceProfile"
        },
        {
            "name": "deliveryAddress",
            "baseName": "DeliveryAddress",
            "type": "AddressData"
        },
        {
            "name": "invoiceAddress",
            "baseName": "InvoiceAddress",
            "type": "AddressData"
        },
        {
            "name": "type",
            "baseName": "Type",
            "type": "ProductContainer.TypeEnum"
        },
        {
            "name": "category",
            "baseName": "Category",
            "type": "ProductContainer.CategoryEnum"
        },
        {
            "name": "quoteValidToDate",
            "baseName": "QuoteValidToDate",
            "type": "Date"
        },
        {
            "name": "totalSalesPrice",
            "baseName": "TotalSalesPrice",
            "type": "Array<Price>"
        },
        {
            "name": "totalAlternativeSalesPrice",
            "baseName": "TotalAlternativeSalesPrice",
            "type": "Array<Price>"
        },
        {
            "name": "issues",
            "baseName": "Issues",
            "type": "Array<ProductContainerIssue>"
        },
        {
            "name": "submittedBy",
            "baseName": "SubmittedBy",
            "type": "ProductContainerCommentUser"
        },
        {
            "name": "sent",
            "baseName": "Sent",
            "type": "Date"
        },
        {
            "name": "invoiceReference",
            "baseName": "InvoiceReference",
            "type": "string"
        },
        {
            "name": "orderReference",
            "baseName": "OrderReference",
            "type": "string"
        },
        {
            "name": "requisition",
            "baseName": "Requisition",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductContainer.attributeTypeMap;
    }
}

export namespace ProductContainer {
    export enum TypeEnum {
        None = <any> 'None',
        Draft = <any> 'Draft',
        Request = <any> 'Request',
        Order = <any> 'Order',
        Quote = <any> 'Quote',
        Template = <any> 'Template'
    }
    export enum CategoryEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Report = <any> 'Report'
    }
}
export class ProductContainerComment {
    'id'?: number;
    'productContainerId'?: number;
    'user'?: ProductContainerCommentUser;
    'message'?: string;
    'timeStamp'?: Date;
    'modified'?: Date;
    'removed'?: boolean;
    'productContainerCommentType'?: ProductContainerComment.ProductContainerCommentTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "productContainerId",
            "baseName": "ProductContainerId",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "User",
            "type": "ProductContainerCommentUser"
        },
        {
            "name": "message",
            "baseName": "Message",
            "type": "string"
        },
        {
            "name": "timeStamp",
            "baseName": "TimeStamp",
            "type": "Date"
        },
        {
            "name": "modified",
            "baseName": "Modified",
            "type": "Date"
        },
        {
            "name": "removed",
            "baseName": "Removed",
            "type": "boolean"
        },
        {
            "name": "productContainerCommentType",
            "baseName": "ProductContainerCommentType",
            "type": "ProductContainerComment.ProductContainerCommentTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ProductContainerComment.attributeTypeMap;
    }
}

export namespace ProductContainerComment {
    export enum ProductContainerCommentTypeEnum {
        None = <any> 'None',
        Comment = <any> 'Comment',
        DraftCreated = <any> 'DraftCreated',
        DraftModified = <any> 'DraftModified',
        QuoteCreated = <any> 'QuoteCreated',
        QuoteModified = <any> 'QuoteModified',
        RequestCreated = <any> 'RequestCreated',
        RequestModifed = <any> 'RequestModifed',
        OrderSubmitted = <any> 'OrderSubmitted',
        OrderInvoiced = <any> 'OrderInvoiced',
        Removed = <any> 'Removed',
        TemplateCreated = <any> 'TemplateCreated',
        TemplateModifed = <any> 'TemplateModifed',
        RequestDeclined = <any> 'RequestDeclined',
        SystemMessage = <any> 'SystemMessage'
    }
}
export class ProductContainerCommentUser {
    'id'?: string;
    'userName'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'crayonEmployee'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "crayonEmployee",
            "baseName": "CrayonEmployee",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProductContainerCommentUser.attributeTypeMap;
    }
}

export class ProductContainerIssue {
    'code'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "Message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductContainerIssue.attributeTypeMap;
    }
}

export class ProductInformation {
    'externalProductId'?: number;
    'cultureCode'?: string;
    'description'?: string;
    'learnMoreLink'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "externalProductId",
            "baseName": "ExternalProductId",
            "type": "number"
        },
        {
            "name": "cultureCode",
            "baseName": "CultureCode",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "learnMoreLink",
            "baseName": "LearnMoreLink",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductInformation.attributeTypeMap;
    }
}

export class ProductReference {
    'id'?: number;
    'partNumber'?: string;
    'publisherProductId'?: string;
    'itemLegalName'?: string;
    'itemName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "partNumber",
            "baseName": "PartNumber",
            "type": "string"
        },
        {
            "name": "publisherProductId",
            "baseName": "PublisherProductId",
            "type": "string"
        },
        {
            "name": "itemLegalName",
            "baseName": "ItemLegalName",
            "type": "string"
        },
        {
            "name": "itemName",
            "baseName": "ItemName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProductReference.attributeTypeMap;
    }
}

export class ProductRow {
    'id'?: number;
    'productContainerId'?: number;
    'quantity'?: number;
    'comment'?: string;
    'usageCountryCode'?: string;
    'salesUnitPrice'?: Price;
    'alternativeSalesUnitPrice'?: Price;
    'publisher'?: ObjectReference;
    'program'?: ObjectReference;
    'agreement'?: AgreementIdentityReference;
    'product'?: ProductReference;
    'user'?: ProductRowUser;
    'productVariant'?: ObjectReference;
    'invoiceProfile'?: ObjectReference;
    'grouping'?: Grouping;
    'issues'?: Array<ProductContainerIssue>;
    'offeringType'?: string;
    'priceCalculation'?: ProductRow.PriceCalculationEnum;
    'invoiceReference'?: string;
    'customerReference'?: string;
    'salesPricePerAlternativeUnit'?: number;
    'levelValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "productContainerId",
            "baseName": "ProductContainerId",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "usageCountryCode",
            "baseName": "UsageCountryCode",
            "type": "string"
        },
        {
            "name": "salesUnitPrice",
            "baseName": "SalesUnitPrice",
            "type": "Price"
        },
        {
            "name": "alternativeSalesUnitPrice",
            "baseName": "AlternativeSalesUnitPrice",
            "type": "Price"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "ObjectReference"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "AgreementIdentityReference"
        },
        {
            "name": "product",
            "baseName": "Product",
            "type": "ProductReference"
        },
        {
            "name": "user",
            "baseName": "User",
            "type": "ProductRowUser"
        },
        {
            "name": "productVariant",
            "baseName": "ProductVariant",
            "type": "ObjectReference"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "grouping",
            "baseName": "Grouping",
            "type": "Grouping"
        },
        {
            "name": "issues",
            "baseName": "Issues",
            "type": "Array<ProductContainerIssue>"
        },
        {
            "name": "offeringType",
            "baseName": "OfferingType",
            "type": "string"
        },
        {
            "name": "priceCalculation",
            "baseName": "PriceCalculation",
            "type": "ProductRow.PriceCalculationEnum"
        },
        {
            "name": "invoiceReference",
            "baseName": "InvoiceReference",
            "type": "string"
        },
        {
            "name": "customerReference",
            "baseName": "CustomerReference",
            "type": "string"
        },
        {
            "name": "salesPricePerAlternativeUnit",
            "baseName": "SalesPricePerAlternativeUnit",
            "type": "number"
        },
        {
            "name": "levelValue",
            "baseName": "LevelValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ProductRow.attributeTypeMap;
    }
}

export namespace ProductRow {
    export enum PriceCalculationEnum {
        None = <any> 'None',
        Default = <any> 'Default',
        SelectPlus = <any> 'SelectPlus',
        AdobeVip = <any> 'AdobeVip',
        Mpsa = <any> 'Mpsa'
    }
}
export class ProductRowPatch {
    'id'?: number;
    'quantity'?: number;
    'comment'?: string;
    'usageCountryCode'?: string;
    'userId'?: string;
    'agreement'?: ObjectReference;
    'productVariant'?: ObjectReference;
    'grouping'?: ObjectReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "comment",
            "baseName": "Comment",
            "type": "string"
        },
        {
            "name": "usageCountryCode",
            "baseName": "UsageCountryCode",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "agreement",
            "baseName": "Agreement",
            "type": "ObjectReference"
        },
        {
            "name": "productVariant",
            "baseName": "ProductVariant",
            "type": "ObjectReference"
        },
        {
            "name": "grouping",
            "baseName": "Grouping",
            "type": "ObjectReference"
        }    ];

    static getAttributeTypeMap() {
        return ProductRowPatch.attributeTypeMap;
    }
}

export class ProductRowUser {
    'id'?: string;
    'userName'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'crayonEmployee'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "crayonEmployee",
            "baseName": "CrayonEmployee",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ProductRowUser.attributeTypeMap;
    }
}

export class ProductVariant {
    'id'?: number;
    'product'?: ProductReference;
    'partNumber'?: string;
    'productName'?: string;
    'publisher'?: ObjectReference;
    'program'?: ObjectReference;
    'productFamily'?: ObjectReference;
    'language'?: ObjectReference;
    'level'?: ObjectReference;
    'productType'?: ObjectReference;
    'pool'?: ObjectReference;
    'licenseType'?: ObjectReference;
    'licenseAgreementType'?: ObjectReference;
    'operatingSystem'?: ObjectReference;
    'offering'?: ObjectReference;
    'minimumCommitment'?: MinimumCommitmentLight;
    'unitCount'?: number;
    'version'?: string;
    'purchaseUnit'?: string;
    'addDate'?: Date;
    'deleteDate'?: Date;
    'productCategory'?: string;
    'region'?: string;
    'isTrial'?: boolean;
    'defaultBillingCycleId'?: number;
    'availableBillingCycleIds'?: Array<number>;
    'attributes'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "product",
            "baseName": "Product",
            "type": "ProductReference"
        },
        {
            "name": "partNumber",
            "baseName": "PartNumber",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "ProductName",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "program",
            "baseName": "Program",
            "type": "ObjectReference"
        },
        {
            "name": "productFamily",
            "baseName": "ProductFamily",
            "type": "ObjectReference"
        },
        {
            "name": "language",
            "baseName": "Language",
            "type": "ObjectReference"
        },
        {
            "name": "level",
            "baseName": "Level",
            "type": "ObjectReference"
        },
        {
            "name": "productType",
            "baseName": "ProductType",
            "type": "ObjectReference"
        },
        {
            "name": "pool",
            "baseName": "Pool",
            "type": "ObjectReference"
        },
        {
            "name": "licenseType",
            "baseName": "LicenseType",
            "type": "ObjectReference"
        },
        {
            "name": "licenseAgreementType",
            "baseName": "LicenseAgreementType",
            "type": "ObjectReference"
        },
        {
            "name": "operatingSystem",
            "baseName": "OperatingSystem",
            "type": "ObjectReference"
        },
        {
            "name": "offering",
            "baseName": "Offering",
            "type": "ObjectReference"
        },
        {
            "name": "minimumCommitment",
            "baseName": "MinimumCommitment",
            "type": "MinimumCommitmentLight"
        },
        {
            "name": "unitCount",
            "baseName": "UnitCount",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "purchaseUnit",
            "baseName": "PurchaseUnit",
            "type": "string"
        },
        {
            "name": "addDate",
            "baseName": "AddDate",
            "type": "Date"
        },
        {
            "name": "deleteDate",
            "baseName": "DeleteDate",
            "type": "Date"
        },
        {
            "name": "productCategory",
            "baseName": "ProductCategory",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "Region",
            "type": "string"
        },
        {
            "name": "isTrial",
            "baseName": "IsTrial",
            "type": "boolean"
        },
        {
            "name": "defaultBillingCycleId",
            "baseName": "DefaultBillingCycleId",
            "type": "number"
        },
        {
            "name": "availableBillingCycleIds",
            "baseName": "AvailableBillingCycleIds",
            "type": "Array<number>"
        },
        {
            "name": "attributes",
            "baseName": "Attributes",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return ProductVariant.attributeTypeMap;
    }
}

export class Program {
    'id'?: number;
    'name'?: string;
    'isCommitment'?: boolean;
    'publisher'?: ObjectReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "isCommitment",
            "baseName": "IsCommitment",
            "type": "boolean"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        }    ];

    static getAttributeTypeMap() {
        return Program.attributeTypeMap;
    }
}

export class Publisher {
    'id'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Publisher.attributeTypeMap;
    }
}

export class PublisherAggregationItem {
    'key'?: string;
    'docCount'?: number;
    'programs'?: Array<AggregationItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "Key",
            "type": "string"
        },
        {
            "name": "docCount",
            "baseName": "DocCount",
            "type": "number"
        },
        {
            "name": "programs",
            "baseName": "Programs",
            "type": "Array<AggregationItem>"
        }    ];

    static getAttributeTypeMap() {
        return PublisherAggregationItem.attributeTypeMap;
    }
}

export class PutAzureSubscription {
    'id'?: number;
    'invoiceProfile'?: ObjectReference;
    'tags'?: AzureSubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "tags",
            "baseName": "Tags",
            "type": "AzureSubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return PutAzureSubscription.attributeTypeMap;
    }
}

export class Region {
    'code'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "Code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Region.attributeTypeMap;
    }
}

export class ResellerSalesPrice {
    'objectId'?: number;
    'objectType'?: ResellerSalesPrice.ObjectTypeEnum;
    'type'?: ResellerSalesPrice.TypeEnum;
    'priceType'?: ResellerSalesPrice.PriceTypeEnum;
    'value'?: number;
    'fromDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "objectId",
            "baseName": "ObjectId",
            "type": "number"
        },
        {
            "name": "objectType",
            "baseName": "ObjectType",
            "type": "ResellerSalesPrice.ObjectTypeEnum"
        },
        {
            "name": "type",
            "baseName": "Type",
            "type": "ResellerSalesPrice.TypeEnum"
        },
        {
            "name": "priceType",
            "baseName": "PriceType",
            "type": "ResellerSalesPrice.PriceTypeEnum"
        },
        {
            "name": "value",
            "baseName": "Value",
            "type": "number"
        },
        {
            "name": "fromDate",
            "baseName": "FromDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ResellerSalesPrice.attributeTypeMap;
    }
}

export namespace ResellerSalesPrice {
    export enum ObjectTypeEnum {
        Organization = <any> 'Organization',
        CustomerTenant = <any> 'CustomerTenant',
        Subscription = <any> 'Subscription',
        SubscriptionAddon = <any> 'SubscriptionAddon'
    }
    export enum TypeEnum {
        License = <any> 'License',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime'
    }
    export enum PriceTypeEnum {
        Markup = <any> 'Markup',
        FixedPrice = <any> 'FixedPrice',
        ListPrice = <any> 'ListPrice'
    }
}
export class ResellerSalesPriceToggle {
    'toggle'?: boolean;
    'objectId'?: number;
    'objectType'?: ResellerSalesPriceToggle.ObjectTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "toggle",
            "baseName": "Toggle",
            "type": "boolean"
        },
        {
            "name": "objectId",
            "baseName": "ObjectId",
            "type": "number"
        },
        {
            "name": "objectType",
            "baseName": "ObjectType",
            "type": "ResellerSalesPriceToggle.ObjectTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ResellerSalesPriceToggle.attributeTypeMap;
    }
}

export namespace ResellerSalesPriceToggle {
    export enum ObjectTypeEnum {
        Organization = <any> 'Organization',
        CustomerTenant = <any> 'CustomerTenant',
        Subscription = <any> 'Subscription',
        SubscriptionAddon = <any> 'SubscriptionAddon'
    }
}
export class ResourceGroupUsageCost {
    'category'?: string;
    'subcategory'?: string;
    'meter'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "Category",
            "type": "string"
        },
        {
            "name": "subcategory",
            "baseName": "Subcategory",
            "type": "string"
        },
        {
            "name": "meter",
            "baseName": "Meter",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResourceGroupUsageCost.attributeTypeMap;
    }
}

export class ResourceGroupUsageCostRequest {
    'resellerCustomerId'?: number;
    'subscriptionId'?: string;
    'resourceGroup'?: string;
    'currencyCode'?: string;
    'from'?: Date;
    'to'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "resourceGroup",
            "baseName": "ResourceGroup",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "to",
            "baseName": "To",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ResourceGroupUsageCostRequest.attributeTypeMap;
    }
}

export class Secret {
    'id'?: number;
    'clientId'?: string;
    'value'?: string;
    'description'?: string;
    'expiration'?: Date;
    'timeStamp'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "ClientId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "Value",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "Description",
            "type": "string"
        },
        {
            "name": "expiration",
            "baseName": "Expiration",
            "type": "Date"
        },
        {
            "name": "timeStamp",
            "baseName": "TimeStamp",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Secret.attributeTypeMap;
    }
}

export class ServiceAccountAgreement {
    'firstName'?: string;
    'lastName'?: string;
    'phoneNumber'?: string;
    'email'?: string;
    'dateAgreed'?: Date;
    'agreementType'?: ServiceAccountAgreement.AgreementTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "dateAgreed",
            "baseName": "DateAgreed",
            "type": "Date"
        },
        {
            "name": "agreementType",
            "baseName": "AgreementType",
            "type": "ServiceAccountAgreement.AgreementTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ServiceAccountAgreement.attributeTypeMap;
    }
}

export namespace ServiceAccountAgreement {
    export enum AgreementTypeEnum {
        MicrosoftCloudAgreement = <any> 'MicrosoftCloudAgreement',
        MicrosoftCustomerAgreement = <any> 'MicrosoftCustomerAgreement'
    }
}
export class SubcategoryUsageCost {
    'meter'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "meter",
            "baseName": "Meter",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubcategoryUsageCost.attributeTypeMap;
    }
}

export class SubcategoryUsageCostRequest {
    'resellerCustomerId'?: number;
    'subscriptionId'?: string;
    'category'?: string;
    'subcategory'?: string;
    'currencyCode'?: string;
    'from'?: Date;
    'to'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "Category",
            "type": "string"
        },
        {
            "name": "subcategory",
            "baseName": "Subcategory",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "to",
            "baseName": "To",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SubcategoryUsageCostRequest.attributeTypeMap;
    }
}

export class Subscription {
    'id'?: number;
    'publisherSubscriptionId'?: string;
    'entitlementId'?: string;
    'publisher'?: ObjectReference;
    'organization'?: ObjectReference;
    'customerTenant'?: CustomerTenantReference;
    'product'?: ProductReference;
    'quantity'?: number;
    'name'?: string;
    'status'?: Subscription.StatusEnum;
    'provisionType'?: Subscription.ProvisionTypeEnum;
    'availableAddonsCount'?: number;
    'subscriptions'?: Array<SubscriptionAddOn>;
    'orderId'?: string;
    'creationDate'?: Date;
    'billingCycle'?: Subscription.BillingCycleEnum;
    'markup'?: number;
    'isTrial'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'priceType'?: Subscription.PriceTypeEnum;
    'salesPrice'?: number;
    'registeredForReservedInstance'?: boolean;
    'invoiceProfile'?: ObjectReference;
    'subscriptionTags'?: SubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "entitlementId",
            "baseName": "EntitlementId",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "customerTenant",
            "baseName": "CustomerTenant",
            "type": "CustomerTenantReference"
        },
        {
            "name": "product",
            "baseName": "Product",
            "type": "ProductReference"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "Subscription.StatusEnum"
        },
        {
            "name": "provisionType",
            "baseName": "ProvisionType",
            "type": "Subscription.ProvisionTypeEnum"
        },
        {
            "name": "availableAddonsCount",
            "baseName": "AvailableAddonsCount",
            "type": "number"
        },
        {
            "name": "subscriptions",
            "baseName": "Subscriptions",
            "type": "Array<SubscriptionAddOn>"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "CreationDate",
            "type": "Date"
        },
        {
            "name": "billingCycle",
            "baseName": "BillingCycle",
            "type": "Subscription.BillingCycleEnum"
        },
        {
            "name": "markup",
            "baseName": "Markup",
            "type": "number"
        },
        {
            "name": "isTrial",
            "baseName": "IsTrial",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "priceType",
            "baseName": "PriceType",
            "type": "Subscription.PriceTypeEnum"
        },
        {
            "name": "salesPrice",
            "baseName": "SalesPrice",
            "type": "number"
        },
        {
            "name": "registeredForReservedInstance",
            "baseName": "RegisteredForReservedInstance",
            "type": "boolean"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "subscriptionTags",
            "baseName": "SubscriptionTags",
            "type": "SubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

export namespace Subscription {
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
    export enum PriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}
export class SubscriptionAddOn {
    'id'?: number;
    'publisherSubscriptionId'?: string;
    'publisherCustomerId'?: string;
    'name'?: string;
    'status'?: SubscriptionAddOn.StatusEnum;
    'quantity'?: number;
    'organization'?: ObjectReference;
    'orderId'?: string;
    'creationDate'?: Date;
    'product'?: ProductReference;
    'publisher'?: ObjectReference;
    'markup'?: number;
    'subscriptionTags'?: SubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "publisherCustomerId",
            "baseName": "PublisherCustomerId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "SubscriptionAddOn.StatusEnum"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "CreationDate",
            "type": "Date"
        },
        {
            "name": "product",
            "baseName": "Product",
            "type": "ProductReference"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "markup",
            "baseName": "Markup",
            "type": "number"
        },
        {
            "name": "subscriptionTags",
            "baseName": "SubscriptionTags",
            "type": "SubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionAddOn.attributeTypeMap;
    }
}

export namespace SubscriptionAddOn {
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
}
export class SubscriptionConversion {
    'billingCycle'?: SubscriptionConversion.BillingCycleEnum;
    'offerId'?: string;
    'orderId'?: string;
    'quantity'?: number;
    'targetOfferId'?: string;
    'productName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingCycle",
            "baseName": "BillingCycle",
            "type": "SubscriptionConversion.BillingCycleEnum"
        },
        {
            "name": "offerId",
            "baseName": "OfferId",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "targetOfferId",
            "baseName": "TargetOfferId",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "ProductName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionConversion.attributeTypeMap;
    }
}

export namespace SubscriptionConversion {
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
}
export class SubscriptionDetailed {
    'effectiveStartDate'?: Date;
    'commitmentEndDate'?: Date;
    'suspensionReasons'?: string;
    'originalAgreementId'?: number;
    'pricing'?: SubscriptionPricing;
    'id'?: number;
    'publisherSubscriptionId'?: string;
    'entitlementId'?: string;
    'publisher'?: ObjectReference;
    'organization'?: ObjectReference;
    'customerTenant'?: CustomerTenantReference;
    'product'?: ProductReference;
    'quantity'?: number;
    'name'?: string;
    'status'?: SubscriptionDetailed.StatusEnum;
    'provisionType'?: SubscriptionDetailed.ProvisionTypeEnum;
    'availableAddonsCount'?: number;
    'subscriptions'?: Array<SubscriptionAddOn>;
    'orderId'?: string;
    'creationDate'?: Date;
    'billingCycle'?: SubscriptionDetailed.BillingCycleEnum;
    'markup'?: number;
    'isTrial'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'priceType'?: SubscriptionDetailed.PriceTypeEnum;
    'salesPrice'?: number;
    'registeredForReservedInstance'?: boolean;
    'invoiceProfile'?: ObjectReference;
    'subscriptionTags'?: SubscriptionTags;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "effectiveStartDate",
            "baseName": "EffectiveStartDate",
            "type": "Date"
        },
        {
            "name": "commitmentEndDate",
            "baseName": "CommitmentEndDate",
            "type": "Date"
        },
        {
            "name": "suspensionReasons",
            "baseName": "SuspensionReasons",
            "type": "string"
        },
        {
            "name": "originalAgreementId",
            "baseName": "OriginalAgreementId",
            "type": "number"
        },
        {
            "name": "pricing",
            "baseName": "Pricing",
            "type": "SubscriptionPricing"
        },
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "entitlementId",
            "baseName": "EntitlementId",
            "type": "string"
        },
        {
            "name": "publisher",
            "baseName": "Publisher",
            "type": "ObjectReference"
        },
        {
            "name": "organization",
            "baseName": "Organization",
            "type": "ObjectReference"
        },
        {
            "name": "customerTenant",
            "baseName": "CustomerTenant",
            "type": "CustomerTenantReference"
        },
        {
            "name": "product",
            "baseName": "Product",
            "type": "ProductReference"
        },
        {
            "name": "quantity",
            "baseName": "Quantity",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "Status",
            "type": "SubscriptionDetailed.StatusEnum"
        },
        {
            "name": "provisionType",
            "baseName": "ProvisionType",
            "type": "SubscriptionDetailed.ProvisionTypeEnum"
        },
        {
            "name": "availableAddonsCount",
            "baseName": "AvailableAddonsCount",
            "type": "number"
        },
        {
            "name": "subscriptions",
            "baseName": "Subscriptions",
            "type": "Array<SubscriptionAddOn>"
        },
        {
            "name": "orderId",
            "baseName": "OrderId",
            "type": "string"
        },
        {
            "name": "creationDate",
            "baseName": "CreationDate",
            "type": "Date"
        },
        {
            "name": "billingCycle",
            "baseName": "BillingCycle",
            "type": "SubscriptionDetailed.BillingCycleEnum"
        },
        {
            "name": "markup",
            "baseName": "Markup",
            "type": "number"
        },
        {
            "name": "isTrial",
            "baseName": "IsTrial",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "StartDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "EndDate",
            "type": "Date"
        },
        {
            "name": "priceType",
            "baseName": "PriceType",
            "type": "SubscriptionDetailed.PriceTypeEnum"
        },
        {
            "name": "salesPrice",
            "baseName": "SalesPrice",
            "type": "number"
        },
        {
            "name": "registeredForReservedInstance",
            "baseName": "RegisteredForReservedInstance",
            "type": "boolean"
        },
        {
            "name": "invoiceProfile",
            "baseName": "InvoiceProfile",
            "type": "ObjectReference"
        },
        {
            "name": "subscriptionTags",
            "baseName": "SubscriptionTags",
            "type": "SubscriptionTags"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionDetailed.attributeTypeMap;
    }
}

export namespace SubscriptionDetailed {
    export enum StatusEnum {
        None = <any> 'None',
        Active = <any> 'Active',
        Suspended = <any> 'Suspended',
        Deleted = <any> 'Deleted',
        CustomerCancellation = <any> 'CustomerCancellation',
        Converted = <any> 'Converted',
        Inactive = <any> 'Inactive',
        All = <any> 'All'
    }
    export enum ProvisionTypeEnum {
        None = <any> 'None',
        Seat = <any> 'Seat',
        Usage = <any> 'Usage',
        OneTime = <any> 'OneTime',
        Crayon = <any> 'Crayon',
        AzureMarketplace = <any> 'AzureMarketplace'
    }
    export enum BillingCycleEnum {
        Unknown = <any> 'Unknown',
        Monthly = <any> 'Monthly',
        Annual = <any> 'Annual',
        None = <any> 'None',
        OneTime = <any> 'OneTime',
        BiAnnually = <any> 'BiAnnually',
        TwoYears = <any> 'TwoYears',
        ThreeYears = <any> 'ThreeYears',
        Quarterly = <any> 'Quarterly'
    }
    export enum PriceTypeEnum {
        PurchasePrice = <any> 'PurchasePrice',
        ListPrice = <any> 'ListPrice',
        FixedPrice = <any> 'FixedPrice'
    }
}
export class SubscriptionLite {
    'id'?: number;
    'name'?: string;
    'publisherSubscriptionId'?: string;
    'resellerCustomerName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "publisherSubscriptionId",
            "baseName": "PublisherSubscriptionId",
            "type": "string"
        },
        {
            "name": "resellerCustomerName",
            "baseName": "ResellerCustomerName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionLite.attributeTypeMap;
    }
}

export class SubscriptionPricing {
    'currencyCode'?: string;
    'purchasePrice'?: number;
    'recommendedRetailPrice'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "purchasePrice",
            "baseName": "PurchasePrice",
            "type": "number"
        },
        {
            "name": "recommendedRetailPrice",
            "baseName": "RecommendedRetailPrice",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionPricing.attributeTypeMap;
    }
}

export class SubscriptionResourceGroupUsageCost {
    'resourceGroup'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resourceGroup",
            "baseName": "ResourceGroup",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionResourceGroupUsageCost.attributeTypeMap;
    }
}

export class SubscriptionTags {
    'subscriptionId'?: number;
    'costCenter'?: string;
    'department'?: string;
    'project'?: string;
    'custom'?: string;
    'owner'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "number"
        },
        {
            "name": "costCenter",
            "baseName": "CostCenter",
            "type": "string"
        },
        {
            "name": "department",
            "baseName": "Department",
            "type": "string"
        },
        {
            "name": "project",
            "baseName": "Project",
            "type": "string"
        },
        {
            "name": "custom",
            "baseName": "Custom",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "Owner",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "CreatedDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "ModifiedDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionTags.attributeTypeMap;
    }
}

export class SubscriptionUsageCost {
    'category'?: string;
    'amount'?: number;
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "Category",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "Amount",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionUsageCost.attributeTypeMap;
    }
}

export class SubscriptionUsageCostRequest {
    'resellerCustomerId'?: number;
    'subscriptionId'?: string;
    'currencyCode'?: string;
    'from'?: Date;
    'to'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resellerCustomerId",
            "baseName": "ResellerCustomerId",
            "type": "number"
        },
        {
            "name": "subscriptionId",
            "baseName": "SubscriptionId",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "CurrencyCode",
            "type": "string"
        },
        {
            "name": "from",
            "baseName": "From",
            "type": "Date"
        },
        {
            "name": "to",
            "baseName": "To",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionUsageCostRequest.attributeTypeMap;
    }
}

export class Token {
    'accessToken'?: string;
    'identityToken'?: string;
    'error'?: string;
    'expiresIn'?: number;
    'tokenType'?: string;
    'refreshToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "AccessToken",
            "type": "string"
        },
        {
            "name": "identityToken",
            "baseName": "IdentityToken",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "Error",
            "type": "string"
        },
        {
            "name": "expiresIn",
            "baseName": "ExpiresIn",
            "type": "number"
        },
        {
            "name": "tokenType",
            "baseName": "TokenType",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "RefreshToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Token.attributeTypeMap;
    }
}

export class User {
    'id'?: string;
    'userName'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'email'?: string;
    'emailConfirmed'?: boolean;
    'lockoutEnabled'?: boolean;
    'lockoutEnd'?: Date;
    'phoneNumber'?: string;
    'phoneNumberConfirmed'?: boolean;
    'twoFactorEnabled'?: boolean;
    'tenantAdmin'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "emailConfirmed",
            "baseName": "EmailConfirmed",
            "type": "boolean"
        },
        {
            "name": "lockoutEnabled",
            "baseName": "LockoutEnabled",
            "type": "boolean"
        },
        {
            "name": "lockoutEnd",
            "baseName": "LockoutEnd",
            "type": "Date"
        },
        {
            "name": "phoneNumber",
            "baseName": "PhoneNumber",
            "type": "string"
        },
        {
            "name": "phoneNumberConfirmed",
            "baseName": "PhoneNumberConfirmed",
            "type": "boolean"
        },
        {
            "name": "twoFactorEnabled",
            "baseName": "TwoFactorEnabled",
            "type": "boolean"
        },
        {
            "name": "tenantAdmin",
            "baseName": "TenantAdmin",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserChangePassword {
    'userId'?: string;
    'oldPassword'?: string;
    'newPassword'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "oldPassword",
            "baseName": "OldPassword",
            "type": "string"
        },
        {
            "name": "newPassword",
            "baseName": "NewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserChangePassword.attributeTypeMap;
    }
}

export class UserProfile {
    'id'?: string;
    'userName'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "Id",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "UserName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "Email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "FirstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "LastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserProfile.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "ActivityLogItem.ChangeTypeEnum": ActivityLogItem.ChangeTypeEnum,
        "Address.AddressTypeEnum": Address.AddressTypeEnum,
        "Agreement.AgreementTypeEnum": Agreement.AgreementTypeEnum,
        "AgreementFilter.StatusEnum": AgreementFilter.StatusEnum,
        "AgreementFilter.AgreementTypesEnum": AgreementFilter.AgreementTypesEnum,
        "AgreementProduct.ProductTypeEnum": AgreementProduct.ProductTypeEnum,
        "AgreementProduct.PriceCalculationTypeEnum": AgreementProduct.PriceCalculationTypeEnum,
        "AgreementProduct.AgreementTypeEnum": AgreementProduct.AgreementTypeEnum,
        "AgreementProductFilter.AgreementTypeIdsEnum": AgreementProductFilter.AgreementTypeIdsEnum,
        "AgreementProductFilter.SortOrderEnum": AgreementProductFilter.SortOrderEnum,
        "AgreementReport.StatusEnum": AgreementReport.StatusEnum,
        "Asset.StatusEnum": Asset.StatusEnum,
        "Asset.ScopeEnum": Asset.ScopeEnum,
        "Asset.AssetTypeEnum": Asset.AssetTypeEnum,
        "Asset.BillingCycleEnum": Asset.BillingCycleEnum,
        "Asset.ResellerPriceTypeEnum": Asset.ResellerPriceTypeEnum,
        "AssetOrderLine.BillingCycleEnum": AssetOrderLine.BillingCycleEnum,
        "AssetOrderLine.TypeEnum": AssetOrderLine.TypeEnum,
        "AssetOrderLine.ScopeEnum": AssetOrderLine.ScopeEnum,
        "AssetOrderLine.ResellerPriceTypeEnum": AssetOrderLine.ResellerPriceTypeEnum,
        "AwsAccount.CustomerTenantTypeEnum": AwsAccount.CustomerTenantTypeEnum,
        "AwsAccount.EntityStatusEnum": AwsAccount.EntityStatusEnum,
        "AzurePlan.StatusEnum": AzurePlan.StatusEnum,
        "BillingStatement.ProvisionTypeEnum": BillingStatement.ProvisionTypeEnum,
        "Client.FlowEnum": Client.FlowEnum,
        "CrayonAccount.CustomerTenantTypeEnum": CrayonAccount.CustomerTenantTypeEnum,
        "CrayonAccount.EntityStatusEnum": CrayonAccount.EntityStatusEnum,
        "CustomerTenant.CustomerTenantTypeEnum": CustomerTenant.CustomerTenantTypeEnum,
        "CustomerTenant.EntityStatusEnum": CustomerTenant.EntityStatusEnum,
        "CustomerTenant.DefaultSubscriptionPriceTypeEnum": CustomerTenant.DefaultSubscriptionPriceTypeEnum,
        "CustomerTenantAgreement.AgreementTypeEnum": CustomerTenantAgreement.AgreementTypeEnum,
        "GroupedBillingStatement.ProvisionTypeEnum": GroupedBillingStatement.ProvisionTypeEnum,
        "OrganizationAccess.RoleEnum": OrganizationAccess.RoleEnum,
        "ProductContainer.TypeEnum": ProductContainer.TypeEnum,
        "ProductContainer.CategoryEnum": ProductContainer.CategoryEnum,
        "ProductContainerComment.ProductContainerCommentTypeEnum": ProductContainerComment.ProductContainerCommentTypeEnum,
        "ProductRow.PriceCalculationEnum": ProductRow.PriceCalculationEnum,
        "ResellerSalesPrice.ObjectTypeEnum": ResellerSalesPrice.ObjectTypeEnum,
        "ResellerSalesPrice.TypeEnum": ResellerSalesPrice.TypeEnum,
        "ResellerSalesPrice.PriceTypeEnum": ResellerSalesPrice.PriceTypeEnum,
        "ResellerSalesPriceToggle.ObjectTypeEnum": ResellerSalesPriceToggle.ObjectTypeEnum,
        "ServiceAccountAgreement.AgreementTypeEnum": ServiceAccountAgreement.AgreementTypeEnum,
        "Subscription.StatusEnum": Subscription.StatusEnum,
        "Subscription.ProvisionTypeEnum": Subscription.ProvisionTypeEnum,
        "Subscription.BillingCycleEnum": Subscription.BillingCycleEnum,
        "Subscription.PriceTypeEnum": Subscription.PriceTypeEnum,
        "SubscriptionAddOn.StatusEnum": SubscriptionAddOn.StatusEnum,
        "SubscriptionConversion.BillingCycleEnum": SubscriptionConversion.BillingCycleEnum,
        "SubscriptionDetailed.StatusEnum": SubscriptionDetailed.StatusEnum,
        "SubscriptionDetailed.ProvisionTypeEnum": SubscriptionDetailed.ProvisionTypeEnum,
        "SubscriptionDetailed.BillingCycleEnum": SubscriptionDetailed.BillingCycleEnum,
        "SubscriptionDetailed.PriceTypeEnum": SubscriptionDetailed.PriceTypeEnum,
}

let typeMap: {[index: string]: any} = {
    "ActivationLink": ActivationLink,
    "ActivityLog": ActivityLog,
    "ActivityLogItem": ActivityLogItem,
    "Address": Address,
    "AddressData": AddressData,
    "AggregationItem": AggregationItem,
    "Agreement": Agreement,
    "AgreementAccess": AgreementAccess,
    "AgreementCollection": AgreementCollection,
    "AgreementFilter": AgreementFilter,
    "AgreementIdentityReference": AgreementIdentityReference,
    "AgreementIdentityReferenceDto": AgreementIdentityReferenceDto,
    "AgreementProduct": AgreementProduct,
    "AgreementProductCollection": AgreementProductCollection,
    "AgreementProductFilter": AgreementProductFilter,
    "AgreementProductsSubFilter": AgreementProductsSubFilter,
    "AgreementReport": AgreementReport,
    "ApiCollectionOfAddress": ApiCollectionOfAddress,
    "ApiCollectionOfAgreementReport": ApiCollectionOfAgreementReport,
    "ApiCollectionOfAsset": ApiCollectionOfAsset,
    "ApiCollectionOfAssetOrder": ApiCollectionOfAssetOrder,
    "ApiCollectionOfAwsAccount": ApiCollectionOfAwsAccount,
    "ApiCollectionOfAzureSubscription": ApiCollectionOfAzureSubscription,
    "ApiCollectionOfBillingCycle": ApiCollectionOfBillingCycle,
    "ApiCollectionOfBillingStatement": ApiCollectionOfBillingStatement,
    "ApiCollectionOfBlogItem": ApiCollectionOfBlogItem,
    "ApiCollectionOfBoolean": ApiCollectionOfBoolean,
    "ApiCollectionOfCategoryUsageCost": ApiCollectionOfCategoryUsageCost,
    "ApiCollectionOfClient": ApiCollectionOfClient,
    "ApiCollectionOfConsumer": ApiCollectionOfConsumer,
    "ApiCollectionOfCrayonAccount": ApiCollectionOfCrayonAccount,
    "ApiCollectionOfCustomerTenant": ApiCollectionOfCustomerTenant,
    "ApiCollectionOfGroupedBillingStatement": ApiCollectionOfGroupedBillingStatement,
    "ApiCollectionOfGrouping": ApiCollectionOfGrouping,
    "ApiCollectionOfInvoiceProfile": ApiCollectionOfInvoiceProfile,
    "ApiCollectionOfManagementLink": ApiCollectionOfManagementLink,
    "ApiCollectionOfManagementLinkGrouped": ApiCollectionOfManagementLinkGrouped,
    "ApiCollectionOfObjectReference": ApiCollectionOfObjectReference,
    "ApiCollectionOfOrganization": ApiCollectionOfOrganization,
    "ApiCollectionOfOrganizationAccess": ApiCollectionOfOrganizationAccess,
    "ApiCollectionOfOrganizationUsageCost": ApiCollectionOfOrganizationUsageCost,
    "ApiCollectionOfProductContainer": ApiCollectionOfProductContainer,
    "ApiCollectionOfProgram": ApiCollectionOfProgram,
    "ApiCollectionOfPublisher": ApiCollectionOfPublisher,
    "ApiCollectionOfRegion": ApiCollectionOfRegion,
    "ApiCollectionOfResourceGroupUsageCost": ApiCollectionOfResourceGroupUsageCost,
    "ApiCollectionOfServiceAccountAgreement": ApiCollectionOfServiceAccountAgreement,
    "ApiCollectionOfSubcategoryUsageCost": ApiCollectionOfSubcategoryUsageCost,
    "ApiCollectionOfSubscription": ApiCollectionOfSubscription,
    "ApiCollectionOfSubscriptionConversion": ApiCollectionOfSubscriptionConversion,
    "ApiCollectionOfSubscriptionResourceGroupUsageCost": ApiCollectionOfSubscriptionResourceGroupUsageCost,
    "ApiCollectionOfSubscriptionUsageCost": ApiCollectionOfSubscriptionUsageCost,
    "ApiCollectionOfUser": ApiCollectionOfUser,
    "Asset": Asset,
    "AssetOrder": AssetOrder,
    "AssetOrderError": AssetOrderError,
    "AssetOrderLine": AssetOrderLine,
    "AssetOrderLineError": AssetOrderLineError,
    "AwsAccount": AwsAccount,
    "AzurePlan": AzurePlan,
    "AzureSubscription": AzureSubscription,
    "AzureSubscriptionTags": AzureSubscriptionTags,
    "BillingCycle": BillingCycle,
    "BillingStatement": BillingStatement,
    "BlogItem": BlogItem,
    "CategoryUsageCost": CategoryUsageCost,
    "CategoryUsageCostRequest": CategoryUsageCostRequest,
    "Client": Client,
    "Consumer": Consumer,
    "CrayonAccount": CrayonAccount,
    "CreateAzureSubscriptionRequest": CreateAzureSubscriptionRequest,
    "CustomerTenant": CustomerTenant,
    "CustomerTenantAddress": CustomerTenantAddress,
    "CustomerTenantAgreement": CustomerTenantAgreement,
    "CustomerTenantContact": CustomerTenantContact,
    "CustomerTenantDetailed": CustomerTenantDetailed,
    "CustomerTenantProfile": CustomerTenantProfile,
    "CustomerTenantReference": CustomerTenantReference,
    "CustomerTenantUser": CustomerTenantUser,
    "FacebookOrder": FacebookOrder,
    "FacebookOrderLine": FacebookOrderLine,
    "GoogleOrder": GoogleOrder,
    "GoogleOrderLine": GoogleOrderLine,
    "GroupedBillingStatement": GroupedBillingStatement,
    "Grouping": Grouping,
    "InvoiceProfile": InvoiceProfile,
    "ManagementLink": ManagementLink,
    "ManagementLinkGrouped": ManagementLinkGrouped,
    "Me": Me,
    "MinimumCommitmentLight": MinimumCommitmentLight,
    "ObjectReference": ObjectReference,
    "ObjectReferenceDto": ObjectReferenceDto,
    "Organization": Organization,
    "OrganizationAccess": OrganizationAccess,
    "OrganizationSalesContact": OrganizationSalesContact,
    "OrganizationUsageCost": OrganizationUsageCost,
    "Price": Price,
    "ProductContainer": ProductContainer,
    "ProductContainerComment": ProductContainerComment,
    "ProductContainerCommentUser": ProductContainerCommentUser,
    "ProductContainerIssue": ProductContainerIssue,
    "ProductInformation": ProductInformation,
    "ProductReference": ProductReference,
    "ProductRow": ProductRow,
    "ProductRowPatch": ProductRowPatch,
    "ProductRowUser": ProductRowUser,
    "ProductVariant": ProductVariant,
    "Program": Program,
    "Publisher": Publisher,
    "PublisherAggregationItem": PublisherAggregationItem,
    "PutAzureSubscription": PutAzureSubscription,
    "Region": Region,
    "ResellerSalesPrice": ResellerSalesPrice,
    "ResellerSalesPriceToggle": ResellerSalesPriceToggle,
    "ResourceGroupUsageCost": ResourceGroupUsageCost,
    "ResourceGroupUsageCostRequest": ResourceGroupUsageCostRequest,
    "Secret": Secret,
    "ServiceAccountAgreement": ServiceAccountAgreement,
    "SubcategoryUsageCost": SubcategoryUsageCost,
    "SubcategoryUsageCostRequest": SubcategoryUsageCostRequest,
    "Subscription": Subscription,
    "SubscriptionAddOn": SubscriptionAddOn,
    "SubscriptionConversion": SubscriptionConversion,
    "SubscriptionDetailed": SubscriptionDetailed,
    "SubscriptionLite": SubscriptionLite,
    "SubscriptionPricing": SubscriptionPricing,
    "SubscriptionResourceGroupUsageCost": SubscriptionResourceGroupUsageCost,
    "SubscriptionTags": SubscriptionTags,
    "SubscriptionUsageCost": SubscriptionUsageCost,
    "SubscriptionUsageCostRequest": SubscriptionUsageCostRequest,
    "Token": Token,
    "User": User,
    "UserChangePassword": UserChangePassword,
    "UserProfile": UserProfile,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActivityLogsApiApiKeys {
    Bearer,
}

export class ActivityLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivityLogsApiApiKeys, value: string) {
        (this.authentications as any)[ActivityLogsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param entity 
     * @param id 
     * @param ids 
     * @param searchDate 
     * @param from 
     * @param to 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (entity?: string, id?: number, ids?: Array<number>, searchDate?: Date, from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ActivityLog;  }> {
        const localVarPath = this.basePath + '/api/v1/ActivityLogs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (entity !== undefined) {
            localVarQueryParameters['Entity'] = ObjectSerializer.serialize(entity, "string");
        }

        if (id !== undefined) {
            localVarQueryParameters['Id'] = ObjectSerializer.serialize(id, "number");
        }

        if (ids !== undefined) {
            localVarQueryParameters['Ids'] = ObjectSerializer.serialize(ids, "Array<number>");
        }

        if (searchDate !== undefined) {
            localVarQueryParameters['SearchDate'] = ObjectSerializer.serialize(searchDate, "Date");
        }

        if (from !== undefined) {
            localVarQueryParameters['From'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['To'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityLog;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityLog");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddressesApiApiKeys {
    Bearer,
}

export class AddressesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AddressesApiApiKeys, value: string) {
        (this.authentications as any)[AddressesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param organizationId 
     * @param type 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId: number, type?: 'None' | 'Invoice' | 'Delivery', options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAddress;  }> {
        const localVarPath = this.basePath + '/api/v1/organizations/{organizationId}/Addresses'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling get.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'None' | 'Invoice' | 'Delivery'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAddress;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAddress");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (organizationId: number, id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Address;  }> {
        const localVarPath = this.basePath + '/api/v1/organizations/{organizationId}/Addresses/{id}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getById.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Address;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Address");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AgreementProductsApiApiKeys {
    Bearer,
}

export class AgreementProductsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AgreementProductsApiApiKeys, value: string) {
        (this.authentications as any)[AgreementProductsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param agreementTypeIds 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param priceListId 
     * @param organizationId 
     * @param customerTenantId 
     * @param agreementId 
     * @param isTrial 
     * @param agreementIds 
     * @param searchDate 
     * @param includePartNumbers 
     * @param includePublisherIds 
     * @param includePublisherNames 
     * @param includePoolNames 
     * @param includeOperatingSystemNames 
     * @param includeLevelNames 
     * @param includeLanguageNames 
     * @param includeLicenseAgreementTypeNames 
     * @param includeLicenseTypeNames 
     * @param includeProductFamilyNames 
     * @param includeProductTypeNames 
     * @param includeProgramNames 
     * @param includeOfferingNames 
     * @param includePurchasePeriodNames 
     * @param includePurchaseUnitNames 
     * @param includeVersionNames 
     * @param includeRegionNames 
     * @param includeProductCategoryNames 
     * @param excludePartNumbers 
     * @param excludePublisherIds 
     * @param excludePublisherNames 
     * @param excludePoolNames 
     * @param excludeOperatingSystemNames 
     * @param excludeLevelNames 
     * @param excludeLanguageNames 
     * @param excludeLicenseAgreementTypeNames 
     * @param excludeLicenseTypeNames 
     * @param excludeProductFamilyNames 
     * @param excludeProductTypeNames 
     * @param excludeProgramNames 
     * @param excludeOfferingNames 
     * @param excludePurchasePeriodNames 
     * @param excludePurchaseUnitNames 
     * @param excludeVersionNames 
     * @param excludeRegionNames 
     * @param excludeProductCategoryNames 
     * @param sortKey 
     * @param includeProductInformation 
     * @param sortOrder 
     * @param {*} [options] Override http request options.
     */
    public get (agreementTypeIds?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, page?: number, pageSize?: number, search?: string, priceListId?: number, organizationId?: number, customerTenantId?: number, agreementId?: number, isTrial?: boolean, agreementIds?: Array<number>, searchDate?: Date, includePartNumbers?: Array<string>, includePublisherIds?: Array<number>, includePublisherNames?: Array<string>, includePoolNames?: Array<string>, includeOperatingSystemNames?: Array<string>, includeLevelNames?: Array<string>, includeLanguageNames?: Array<string>, includeLicenseAgreementTypeNames?: Array<string>, includeLicenseTypeNames?: Array<string>, includeProductFamilyNames?: Array<string>, includeProductTypeNames?: Array<string>, includeProgramNames?: Array<string>, includeOfferingNames?: Array<string>, includePurchasePeriodNames?: Array<string>, includePurchaseUnitNames?: Array<string>, includeVersionNames?: Array<string>, includeRegionNames?: Array<string>, includeProductCategoryNames?: Array<string>, excludePartNumbers?: Array<string>, excludePublisherIds?: Array<number>, excludePublisherNames?: Array<string>, excludePoolNames?: Array<string>, excludeOperatingSystemNames?: Array<string>, excludeLevelNames?: Array<string>, excludeLanguageNames?: Array<string>, excludeLicenseAgreementTypeNames?: Array<string>, excludeLicenseTypeNames?: Array<string>, excludeProductFamilyNames?: Array<string>, excludeProductTypeNames?: Array<string>, excludeProgramNames?: Array<string>, excludeOfferingNames?: Array<string>, excludePurchasePeriodNames?: Array<string>, excludePurchaseUnitNames?: Array<string>, excludeVersionNames?: Array<string>, excludeRegionNames?: Array<string>, excludeProductCategoryNames?: Array<string>, sortKey?: string, includeProductInformation?: boolean, sortOrder?: 'Ascending' | 'Descending', options: any = {}) : Promise<{ response: http.ClientResponse; body: AgreementProductCollection;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementProducts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (agreementTypeIds !== undefined) {
            localVarQueryParameters['AgreementTypeIds'] = ObjectSerializer.serialize(agreementTypeIds, "Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (priceListId !== undefined) {
            localVarQueryParameters['PriceListId'] = ObjectSerializer.serialize(priceListId, "number");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (customerTenantId !== undefined) {
            localVarQueryParameters['CustomerTenantId'] = ObjectSerializer.serialize(customerTenantId, "number");
        }

        if (agreementId !== undefined) {
            localVarQueryParameters['AgreementId'] = ObjectSerializer.serialize(agreementId, "number");
        }

        if (isTrial !== undefined) {
            localVarQueryParameters['IsTrial'] = ObjectSerializer.serialize(isTrial, "boolean");
        }

        if (agreementIds !== undefined) {
            localVarQueryParameters['AgreementIds'] = ObjectSerializer.serialize(agreementIds, "Array<number>");
        }

        if (searchDate !== undefined) {
            localVarQueryParameters['SearchDate'] = ObjectSerializer.serialize(searchDate, "Date");
        }

        if (includePartNumbers !== undefined) {
            localVarQueryParameters['Include.PartNumbers'] = ObjectSerializer.serialize(includePartNumbers, "Array<string>");
        }

        if (includePublisherIds !== undefined) {
            localVarQueryParameters['Include.PublisherIds'] = ObjectSerializer.serialize(includePublisherIds, "Array<number>");
        }

        if (includePublisherNames !== undefined) {
            localVarQueryParameters['Include.PublisherNames'] = ObjectSerializer.serialize(includePublisherNames, "Array<string>");
        }

        if (includePoolNames !== undefined) {
            localVarQueryParameters['Include.PoolNames'] = ObjectSerializer.serialize(includePoolNames, "Array<string>");
        }

        if (includeOperatingSystemNames !== undefined) {
            localVarQueryParameters['Include.OperatingSystemNames'] = ObjectSerializer.serialize(includeOperatingSystemNames, "Array<string>");
        }

        if (includeLevelNames !== undefined) {
            localVarQueryParameters['Include.LevelNames'] = ObjectSerializer.serialize(includeLevelNames, "Array<string>");
        }

        if (includeLanguageNames !== undefined) {
            localVarQueryParameters['Include.LanguageNames'] = ObjectSerializer.serialize(includeLanguageNames, "Array<string>");
        }

        if (includeLicenseAgreementTypeNames !== undefined) {
            localVarQueryParameters['Include.LicenseAgreementTypeNames'] = ObjectSerializer.serialize(includeLicenseAgreementTypeNames, "Array<string>");
        }

        if (includeLicenseTypeNames !== undefined) {
            localVarQueryParameters['Include.LicenseTypeNames'] = ObjectSerializer.serialize(includeLicenseTypeNames, "Array<string>");
        }

        if (includeProductFamilyNames !== undefined) {
            localVarQueryParameters['Include.ProductFamilyNames'] = ObjectSerializer.serialize(includeProductFamilyNames, "Array<string>");
        }

        if (includeProductTypeNames !== undefined) {
            localVarQueryParameters['Include.ProductTypeNames'] = ObjectSerializer.serialize(includeProductTypeNames, "Array<string>");
        }

        if (includeProgramNames !== undefined) {
            localVarQueryParameters['Include.ProgramNames'] = ObjectSerializer.serialize(includeProgramNames, "Array<string>");
        }

        if (includeOfferingNames !== undefined) {
            localVarQueryParameters['Include.OfferingNames'] = ObjectSerializer.serialize(includeOfferingNames, "Array<string>");
        }

        if (includePurchasePeriodNames !== undefined) {
            localVarQueryParameters['Include.PurchasePeriodNames'] = ObjectSerializer.serialize(includePurchasePeriodNames, "Array<string>");
        }

        if (includePurchaseUnitNames !== undefined) {
            localVarQueryParameters['Include.PurchaseUnitNames'] = ObjectSerializer.serialize(includePurchaseUnitNames, "Array<string>");
        }

        if (includeVersionNames !== undefined) {
            localVarQueryParameters['Include.VersionNames'] = ObjectSerializer.serialize(includeVersionNames, "Array<string>");
        }

        if (includeRegionNames !== undefined) {
            localVarQueryParameters['Include.RegionNames'] = ObjectSerializer.serialize(includeRegionNames, "Array<string>");
        }

        if (includeProductCategoryNames !== undefined) {
            localVarQueryParameters['Include.ProductCategoryNames'] = ObjectSerializer.serialize(includeProductCategoryNames, "Array<string>");
        }

        if (excludePartNumbers !== undefined) {
            localVarQueryParameters['Exclude.PartNumbers'] = ObjectSerializer.serialize(excludePartNumbers, "Array<string>");
        }

        if (excludePublisherIds !== undefined) {
            localVarQueryParameters['Exclude.PublisherIds'] = ObjectSerializer.serialize(excludePublisherIds, "Array<number>");
        }

        if (excludePublisherNames !== undefined) {
            localVarQueryParameters['Exclude.PublisherNames'] = ObjectSerializer.serialize(excludePublisherNames, "Array<string>");
        }

        if (excludePoolNames !== undefined) {
            localVarQueryParameters['Exclude.PoolNames'] = ObjectSerializer.serialize(excludePoolNames, "Array<string>");
        }

        if (excludeOperatingSystemNames !== undefined) {
            localVarQueryParameters['Exclude.OperatingSystemNames'] = ObjectSerializer.serialize(excludeOperatingSystemNames, "Array<string>");
        }

        if (excludeLevelNames !== undefined) {
            localVarQueryParameters['Exclude.LevelNames'] = ObjectSerializer.serialize(excludeLevelNames, "Array<string>");
        }

        if (excludeLanguageNames !== undefined) {
            localVarQueryParameters['Exclude.LanguageNames'] = ObjectSerializer.serialize(excludeLanguageNames, "Array<string>");
        }

        if (excludeLicenseAgreementTypeNames !== undefined) {
            localVarQueryParameters['Exclude.LicenseAgreementTypeNames'] = ObjectSerializer.serialize(excludeLicenseAgreementTypeNames, "Array<string>");
        }

        if (excludeLicenseTypeNames !== undefined) {
            localVarQueryParameters['Exclude.LicenseTypeNames'] = ObjectSerializer.serialize(excludeLicenseTypeNames, "Array<string>");
        }

        if (excludeProductFamilyNames !== undefined) {
            localVarQueryParameters['Exclude.ProductFamilyNames'] = ObjectSerializer.serialize(excludeProductFamilyNames, "Array<string>");
        }

        if (excludeProductTypeNames !== undefined) {
            localVarQueryParameters['Exclude.ProductTypeNames'] = ObjectSerializer.serialize(excludeProductTypeNames, "Array<string>");
        }

        if (excludeProgramNames !== undefined) {
            localVarQueryParameters['Exclude.ProgramNames'] = ObjectSerializer.serialize(excludeProgramNames, "Array<string>");
        }

        if (excludeOfferingNames !== undefined) {
            localVarQueryParameters['Exclude.OfferingNames'] = ObjectSerializer.serialize(excludeOfferingNames, "Array<string>");
        }

        if (excludePurchasePeriodNames !== undefined) {
            localVarQueryParameters['Exclude.PurchasePeriodNames'] = ObjectSerializer.serialize(excludePurchasePeriodNames, "Array<string>");
        }

        if (excludePurchaseUnitNames !== undefined) {
            localVarQueryParameters['Exclude.PurchaseUnitNames'] = ObjectSerializer.serialize(excludePurchaseUnitNames, "Array<string>");
        }

        if (excludeVersionNames !== undefined) {
            localVarQueryParameters['Exclude.VersionNames'] = ObjectSerializer.serialize(excludeVersionNames, "Array<string>");
        }

        if (excludeRegionNames !== undefined) {
            localVarQueryParameters['Exclude.RegionNames'] = ObjectSerializer.serialize(excludeRegionNames, "Array<string>");
        }

        if (excludeProductCategoryNames !== undefined) {
            localVarQueryParameters['Exclude.ProductCategoryNames'] = ObjectSerializer.serialize(excludeProductCategoryNames, "Array<string>");
        }

        if (sortKey !== undefined) {
            localVarQueryParameters['SortKey'] = ObjectSerializer.serialize(sortKey, "string");
        }

        if (includeProductInformation !== undefined) {
            localVarQueryParameters['IncludeProductInformation'] = ObjectSerializer.serialize(includeProductInformation, "boolean");
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['SortOrder'] = ObjectSerializer.serialize(sortOrder, "'Ascending' | 'Descending'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AgreementProductCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AgreementProductCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param filter 
     * @param {*} [options] Override http request options.
     */
    public getAsExcelFile (filter?: AgreementProductFilter, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementProducts/file/xlsx';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(filter, "AgreementProductFilter")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param filter 
     * @param {*} [options] Override http request options.
     */
    public getOperationSdk133 (filter?: AgreementProductFilter, options: any = {}) : Promise<{ response: http.ClientResponse; body: AgreementProductCollection;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementProducts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(filter, "AgreementProductFilter")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AgreementProductCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AgreementProductCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param partNumber 
     * @param resellerCustomerId 
     * @param {*} [options] Override http request options.
     */
    public getSupportedBillingCycles (partNumber: string, resellerCustomerId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementProducts/{partNumber}/supportedbillingcycles'
            .replace('{' + 'partNumber' + '}', encodeURIComponent(String(partNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'partNumber' is not null or undefined
        if (partNumber === null || partNumber === undefined) {
            throw new Error('Required parameter partNumber was null or undefined when calling getSupportedBillingCycles.');
        }

        if (resellerCustomerId !== undefined) {
            localVarQueryParameters['resellerCustomerId'] = ObjectSerializer.serialize(resellerCustomerId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AgreementReportsApiApiKeys {
    Bearer,
}

export class AgreementReportsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AgreementReportsApiApiKeys, value: string) {
        (this.authentications as any)[AgreementReportsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param productContainerId 
     * @param {*} [options] Override http request options.
     */
    public get (productContainerId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAgreementReport;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementReports/{productContainerId}'
            .replace('{' + 'productContainerId' + '}', encodeURIComponent(String(productContainerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productContainerId' is not null or undefined
        if (productContainerId === null || productContainerId === undefined) {
            throw new Error('Required parameter productContainerId was null or undefined when calling get.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAgreementReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAgreementReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param agreementId 
     * @param agreementReport 
     * @param {*} [options] Override http request options.
     */
    public update (agreementId: number, agreementReport?: AgreementReport, options: any = {}) : Promise<{ response: http.ClientResponse; body: AgreementReport;  }> {
        const localVarPath = this.basePath + '/api/v1/AgreementReports/{agreementId}'
            .replace('{' + 'agreementId' + '}', encodeURIComponent(String(agreementId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'agreementId' is not null or undefined
        if (agreementId === null || agreementId === undefined) {
            throw new Error('Required parameter agreementId was null or undefined when calling update.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(agreementReport, "AgreementReport")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AgreementReport;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AgreementReport");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AgreementsApiApiKeys {
    Bearer,
}

export class AgreementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AgreementsApiApiKeys, value: string) {
        (this.authentications as any)[AgreementsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param organizationId 
     * @param organizationIds 
     * @param pricelistIds 
     * @param status 
     * @param agreementTypes 
     * @param publisherIds 
     * @param programIds 
     * @param searchDate 
     * @param agreementIds 
     * @param salesPriceCurrency 
     * @param termRequired 
     * @param publisherId 
     * @param endDateFrom 
     * @param endDateTo 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, organizationIds?: Array<number>, pricelistIds?: Array<number>, status?: 'None' | 'Active' | 'Inactive' | 'ActiveInactive', agreementTypes?: Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>, publisherIds?: Array<number>, programIds?: Array<number>, searchDate?: Date, agreementIds?: Array<number>, salesPriceCurrency?: string, termRequired?: boolean, publisherId?: number, endDateFrom?: Date, endDateTo?: Date, page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AgreementCollection;  }> {
        const localVarPath = this.basePath + '/api/v1/Agreements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (organizationIds !== undefined) {
            localVarQueryParameters['OrganizationIds'] = ObjectSerializer.serialize(organizationIds, "Array<number>");
        }

        if (pricelistIds !== undefined) {
            localVarQueryParameters['PricelistIds'] = ObjectSerializer.serialize(pricelistIds, "Array<number>");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'None' | 'Active' | 'Inactive' | 'ActiveInactive'");
        }

        if (agreementTypes !== undefined) {
            localVarQueryParameters['AgreementTypes'] = ObjectSerializer.serialize(agreementTypes, "Array<'None' | 'LicenseAgreement' | 'OpenAgreement' | 'FrameAgreement' | 'SamAgreement' | 'ConsultingAgreement' | 'CloudSeatAgreement' | 'CloudUsageAgreement' | 'ReportingAgreement' | 'OtherAgreement' | 'Reserved1' | 'Reserved2' | 'Reserved3'>");
        }

        if (publisherIds !== undefined) {
            localVarQueryParameters['PublisherIds'] = ObjectSerializer.serialize(publisherIds, "Array<number>");
        }

        if (programIds !== undefined) {
            localVarQueryParameters['ProgramIds'] = ObjectSerializer.serialize(programIds, "Array<number>");
        }

        if (searchDate !== undefined) {
            localVarQueryParameters['SearchDate'] = ObjectSerializer.serialize(searchDate, "Date");
        }

        if (agreementIds !== undefined) {
            localVarQueryParameters['AgreementIds'] = ObjectSerializer.serialize(agreementIds, "Array<number>");
        }

        if (salesPriceCurrency !== undefined) {
            localVarQueryParameters['SalesPriceCurrency'] = ObjectSerializer.serialize(salesPriceCurrency, "string");
        }

        if (termRequired !== undefined) {
            localVarQueryParameters['TermRequired'] = ObjectSerializer.serialize(termRequired, "boolean");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (endDateFrom !== undefined) {
            localVarQueryParameters['EndDateFrom'] = ObjectSerializer.serialize(endDateFrom, "Date");
        }

        if (endDateTo !== undefined) {
            localVarQueryParameters['EndDateTo'] = ObjectSerializer.serialize(endDateTo, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AgreementCollection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AgreementCollection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetsApiApiKeys {
    Bearer,
}

export class AssetsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AssetsApiApiKeys, value: string) {
        (this.authentications as any)[AssetsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param order 
     * @param {*} [options] Override http request options.
     */
    public checkoutAsync (order?: AssetOrder, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/Assets/checkout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "AssetOrder")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param publisherId 
     * @param externalOrderId 
     * @param externalOrderIds 
     * @param reservationId 
     * @param assetType 
     * @param status 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAsset;  }> {
        const localVarPath = this.basePath + '/api/v1/Assets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (resellerCustomerId !== undefined) {
            localVarQueryParameters['ResellerCustomerId'] = ObjectSerializer.serialize(resellerCustomerId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (externalOrderId !== undefined) {
            localVarQueryParameters['ExternalOrderId'] = ObjectSerializer.serialize(externalOrderId, "string");
        }

        if (externalOrderIds !== undefined) {
            localVarQueryParameters['ExternalOrderIds'] = ObjectSerializer.serialize(externalOrderIds, "Array<string>");
        }

        if (reservationId !== undefined) {
            localVarQueryParameters['ReservationId'] = ObjectSerializer.serialize(reservationId, "string");
        }

        if (assetType !== undefined) {
            localVarQueryParameters['AssetType'] = ObjectSerializer.serialize(assetType, "'Reservation' | 'Software' | 'Subscription'");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAsset;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAsset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param publisherId 
     * @param externalOrderId 
     * @param externalOrderIds 
     * @param reservationId 
     * @param assetType 
     * @param status 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public getAssetOrdersAsync (resellerCustomerId?: number, publisherId?: number, externalOrderId?: string, externalOrderIds?: Array<string>, reservationId?: string, assetType?: 'Reservation' | 'Software' | 'Subscription', status?: 'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All', page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAssetOrder;  }> {
        const localVarPath = this.basePath + '/api/v1/Assets/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (resellerCustomerId !== undefined) {
            localVarQueryParameters['ResellerCustomerId'] = ObjectSerializer.serialize(resellerCustomerId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (externalOrderId !== undefined) {
            localVarQueryParameters['ExternalOrderId'] = ObjectSerializer.serialize(externalOrderId, "string");
        }

        if (externalOrderIds !== undefined) {
            localVarQueryParameters['ExternalOrderIds'] = ObjectSerializer.serialize(externalOrderIds, "Array<string>");
        }

        if (reservationId !== undefined) {
            localVarQueryParameters['ReservationId'] = ObjectSerializer.serialize(reservationId, "string");
        }

        if (assetType !== undefined) {
            localVarQueryParameters['AssetType'] = ObjectSerializer.serialize(assetType, "'Reservation' | 'Software' | 'Subscription'");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'None' | 'Fulfilling' | 'Succeeded' | 'Cancelled' | 'All'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAssetOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAssetOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param order 
     * @param {*} [options] Override http request options.
     */
    public verifyAsync (order?: AssetOrder, options: any = {}) : Promise<{ response: http.ClientResponse; body: AssetOrder;  }> {
        const localVarPath = this.basePath + '/api/v1/Assets/verify';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "AssetOrder")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AssetOrder;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AssetOrder");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AwsAccountsApiApiKeys {
    Bearer,
}

export class AwsAccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AwsAccountsApiApiKeys, value: string) {
        (this.authentications as any)[AwsAccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getAwsAccountById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AwsAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/AwsAccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAwsAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AwsAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AwsAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param publisherId 
     * @param consumerId 
     * @param customerTenantType 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public getAwsAccounts (organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAwsAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/AwsAccounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (consumerId !== undefined) {
            localVarQueryParameters['ConsumerId'] = ObjectSerializer.serialize(consumerId, "number");
        }

        if (customerTenantType !== undefined) {
            localVarQueryParameters['CustomerTenantType'] = ObjectSerializer.serialize(customerTenantType, "'None' | 'T1' | 'T2'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAwsAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAwsAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param awsAccount 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, awsAccount?: AwsAccount, options: any = {}) : Promise<{ response: http.ClientResponse; body: AwsAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/AwsAccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(awsAccount, "AwsAccount")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AwsAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AwsAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AzurePlansApiApiKeys {
    Bearer,
}

export class AzurePlansApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AzurePlansApiApiKeys, value: string) {
        (this.authentications as any)[AzurePlansApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param azurePlanId 
     * @param requestBody 
     * @param {*} [options] Override http request options.
     */
    public createSubscription (azurePlanId: number, requestBody?: CreateAzureSubscriptionRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions'
            .replace('{' + 'azurePlanId' + '}', encodeURIComponent(String(azurePlanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'azurePlanId' is not null or undefined
        if (azurePlanId === null || azurePlanId === undefined) {
            throw new Error('Required parameter azurePlanId was null or undefined when calling createSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestBody, "CreateAzureSubscriptionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param azurePlanId 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionById (azurePlanId: number, id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AzureSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions/{id}'
            .replace('{' + 'azurePlanId' + '}', encodeURIComponent(String(azurePlanId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'azurePlanId' is not null or undefined
        if (azurePlanId === null || azurePlanId === undefined) {
            throw new Error('Required parameter azurePlanId was null or undefined when calling getSubscriptionById.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscriptionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AzureSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AzureSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param azurePlanId 
     * @param search 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptions (azurePlanId: number, search?: string, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfAzureSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions'
            .replace('{' + 'azurePlanId' + '}', encodeURIComponent(String(azurePlanId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'azurePlanId' is not null or undefined
        if (azurePlanId === null || azurePlanId === undefined) {
            throw new Error('Required parameter azurePlanId was null or undefined when calling getSubscriptions.');
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfAzureSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfAzureSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param azurePlanId 
     * @param id 
     * @param azureSubscription 
     * @param {*} [options] Override http request options.
     */
    public updateSubscription (azurePlanId: number, id: number, azureSubscription?: PutAzureSubscription, options: any = {}) : Promise<{ response: http.ClientResponse; body: AzureSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1/AzurePlans/{azurePlanId}/azureSubscriptions/{id}'
            .replace('{' + 'azurePlanId' + '}', encodeURIComponent(String(azurePlanId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'azurePlanId' is not null or undefined
        if (azurePlanId === null || azurePlanId === undefined) {
            throw new Error('Required parameter azurePlanId was null or undefined when calling updateSubscription.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(azureSubscription, "PutAzureSubscription")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AzureSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AzureSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BillingCyclesApiApiKeys {
    Bearer,
}

export class BillingCyclesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BillingCyclesApiApiKeys, value: string) {
        (this.authentications as any)[BillingCyclesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param includeUnknown 
     * @param {*} [options] Override http request options.
     */
    public getAllBillingCycles (includeUnknown?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingCycle;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingCycles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (includeUnknown !== undefined) {
            localVarQueryParameters['includeUnknown'] = ObjectSerializer.serialize(includeUnknown, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingCycle;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfBillingCycle");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param productVariantId 
     * @param {*} [options] Override http request options.
     */
    public getByProductVariantId (productVariantId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingCycle;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingCycles/productVariant/{productVariantId}'
            .replace('{' + 'productVariantId' + '}', encodeURIComponent(String(productVariantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productVariantId' is not null or undefined
        if (productVariantId === null || productVariantId === undefined) {
            throw new Error('Required parameter productVariantId was null or undefined when calling getByProductVariantId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingCycle;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfBillingCycle");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getCspNameDictionary (options: any = {}) : Promise<{ response: http.ClientResponse; body: { [key: string]: string; };  }> {
        const localVarPath = this.basePath + '/api/v1/BillingCycles/cspNameDictionary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: { [key: string]: string; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: string; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BillingStatementsApiApiKeys {
    Bearer,
}

export class BillingStatementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BillingStatementsApiApiKeys, value: string) {
        (this.authentications as any)[BillingStatementsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getBillingRecordsFile (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingStatements/{id}/billingrecordsfile'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBillingRecordsFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getBillingStatementFile (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingStatements/file/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBillingStatementFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param invoiceProfileId 
     * @param organizationId 
     * @param provisionType 
     * @param from 
     * @param to 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getBillingStatements (invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingStatement;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingStatements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (invoiceProfileId !== undefined) {
            localVarQueryParameters['InvoiceProfileId'] = ObjectSerializer.serialize(invoiceProfileId, "number");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (provisionType !== undefined) {
            localVarQueryParameters['ProvisionType'] = ObjectSerializer.serialize(provisionType, "'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'");
        }

        if (from !== undefined) {
            localVarQueryParameters['From'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['To'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfBillingStatement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfBillingStatement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param invoiceProfileId 
     * @param organizationId 
     * @param provisionType 
     * @param from 
     * @param to 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getGroupedBillingStatements (invoiceProfileId?: number, organizationId?: number, provisionType?: 'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace', from?: Date, to?: Date, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfGroupedBillingStatement;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingStatements/grouped';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (invoiceProfileId !== undefined) {
            localVarQueryParameters['InvoiceProfileId'] = ObjectSerializer.serialize(invoiceProfileId, "number");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (provisionType !== undefined) {
            localVarQueryParameters['ProvisionType'] = ObjectSerializer.serialize(provisionType, "'None' | 'Seat' | 'Usage' | 'OneTime' | 'Crayon' | 'AzureMarketplace'");
        }

        if (from !== undefined) {
            localVarQueryParameters['From'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['To'] = ObjectSerializer.serialize(to, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfGroupedBillingStatement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfGroupedBillingStatement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getReconciliationFile (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/BillingStatements/{id}/reconciliationfile'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getReconciliationFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BlogItemsApiApiKeys {
    Bearer,
}

export class BlogItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BlogItemsApiApiKeys, value: string) {
        (this.authentications as any)[BlogItemsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param count 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getForDirectCustomers (count?: number, organizationId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfBlogItem;  }> {
        const localVarPath = this.basePath + '/api/v1/BlogItems';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfBlogItem;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfBlogItem");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClientsApiApiKeys {
    Bearer,
}

export class ClientsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClientsApiApiKeys, value: string) {
        (this.authentications as any)[ClientsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param clientId 
     * @param {*} [options] Override http request options.
     */
    public _delete (clientId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Clients/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling _delete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfClient;  }> {
        const localVarPath = this.basePath + '/api/v1/Clients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfClient;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfClient");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param clientId 
     * @param {*} [options] Override http request options.
     */
    public getById (clientId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Client;  }> {
        const localVarPath = this.basePath + '/api/v1/Clients/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Client;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Client");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param client 
     * @param {*} [options] Override http request options.
     */
    public post (client?: Client, options: any = {}) : Promise<{ response: http.ClientResponse; body: Client;  }> {
        const localVarPath = this.basePath + '/api/v1/Clients';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(client, "Client")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Client;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Client");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param clientId 
     * @param client 
     * @param {*} [options] Override http request options.
     */
    public put (clientId: string, client?: Client, options: any = {}) : Promise<{ response: http.ClientResponse; body: Client;  }> {
        const localVarPath = this.basePath + '/api/v1/Clients/{clientId}'
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(client, "Client")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Client;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Client");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConsumersApiApiKeys {
    Bearer,
}

export class ConsumersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConsumersApiApiKeys, value: string) {
        (this.authentications as any)[ConsumersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param consumer 
     * @param {*} [options] Override http request options.
     */
    public addConsumer (consumer?: Consumer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Consumer;  }> {
        const localVarPath = this.basePath + '/api/v1/Consumers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(consumer, "Consumer")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Consumer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Consumer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteConsumer (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Consumers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteConsumer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param search 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, search?: string, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfConsumer;  }> {
        const localVarPath = this.basePath + '/api/v1/Consumers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfConsumer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfConsumer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getConsumerById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Consumer;  }> {
        const localVarPath = this.basePath + '/api/v1/Consumers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConsumerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Consumer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Consumer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param consumer 
     * @param {*} [options] Override http request options.
     */
    public updateConsumer (id: number, consumer?: Consumer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Consumer;  }> {
        const localVarPath = this.basePath + '/api/v1/Consumers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateConsumer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(consumer, "Consumer")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Consumer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Consumer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CrayonAccountsApiApiKeys {
    Bearer,
}

export class CrayonAccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CrayonAccountsApiApiKeys, value: string) {
        (this.authentications as any)[CrayonAccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getCrayonAccountById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CrayonAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/CrayonAccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCrayonAccountById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrayonAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CrayonAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param publisherId 
     * @param consumerId 
     * @param customerTenantType 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public getCrayonAccounts (organizationId?: number, publisherId?: number, consumerId?: number, customerTenantType?: 'None' | 'T1' | 'T2', page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfCrayonAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/CrayonAccounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (consumerId !== undefined) {
            localVarQueryParameters['ConsumerId'] = ObjectSerializer.serialize(consumerId, "number");
        }

        if (customerTenantType !== undefined) {
            localVarQueryParameters['CustomerTenantType'] = ObjectSerializer.serialize(customerTenantType, "'None' | 'T1' | 'T2'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfCrayonAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfCrayonAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param crayonAccount 
     * @param {*} [options] Override http request options.
     */
    public post (crayonAccount?: CrayonAccount, options: any = {}) : Promise<{ response: http.ClientResponse; body: CrayonAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/CrayonAccounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(crayonAccount, "CrayonAccount")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrayonAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CrayonAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param crayonAccount 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, crayonAccount?: CrayonAccount, options: any = {}) : Promise<{ response: http.ClientResponse; body: CrayonAccount;  }> {
        const localVarPath = this.basePath + '/api/v1/CrayonAccounts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(crayonAccount, "CrayonAccount")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CrayonAccount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CrayonAccount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerTenantAgreementsApiApiKeys {
    Bearer,
}

export class CustomerTenantAgreementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerTenantAgreementsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerTenantAgreementsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param customerTenantId 
     * @param agreement 
     * @param {*} [options] Override http request options.
     */
    public add (customerTenantId: number, agreement?: ServiceAccountAgreement, options: any = {}) : Promise<{ response: http.ClientResponse; body: ServiceAccountAgreement;  }> {
        const localVarPath = this.basePath + '/api/v1/customertenants/{customerTenantId}/agreements'
            .replace('{' + 'customerTenantId' + '}', encodeURIComponent(String(customerTenantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerTenantId' is not null or undefined
        if (customerTenantId === null || customerTenantId === undefined) {
            throw new Error('Required parameter customerTenantId was null or undefined when calling add.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(agreement, "ServiceAccountAgreement")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ServiceAccountAgreement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServiceAccountAgreement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customerTenantId 
     * @param agreementTypeConsent 
     * @param {*} [options] Override http request options.
     */
    public get (customerTenantId: number, agreementTypeConsent?: 'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement', options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfServiceAccountAgreement;  }> {
        const localVarPath = this.basePath + '/api/v1/customertenants/{customerTenantId}/agreements'
            .replace('{' + 'customerTenantId' + '}', encodeURIComponent(String(customerTenantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerTenantId' is not null or undefined
        if (customerTenantId === null || customerTenantId === undefined) {
            throw new Error('Required parameter customerTenantId was null or undefined when calling get.');
        }

        if (agreementTypeConsent !== undefined) {
            localVarQueryParameters['AgreementTypeConsent'] = ObjectSerializer.serialize(agreementTypeConsent, "'MicrosoftCloudAgreement' | 'MicrosoftCustomerAgreement'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfServiceAccountAgreement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfServiceAccountAgreement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerTenantsApiApiKeys {
    Bearer,
}

export class CustomerTenantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerTenantsApiApiKeys, value: string) {
        (this.authentications as any)[CustomerTenantsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param existingTenant 
     * @param syncFromPublisher 
     * @param {*} [options] Override http request options.
     */
    public addExisting (existingTenant?: CustomerTenantDetailed, syncFromPublisher?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/existing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (syncFromPublisher !== undefined) {
            localVarQueryParameters['syncFromPublisher'] = ObjectSerializer.serialize(syncFromPublisher, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(existingTenant, "CustomerTenantDetailed")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerTenantDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteCustomerById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param publisherId 
     * @param programId 
     * @param consumerId 
     * @param domain 
     * @param domainPrefix 
     * @param customerTenantType 
     * @param invoiceProfileId 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, publisherId?: number, programId?: number, consumerId?: number, domain?: string, domainPrefix?: string, customerTenantType?: 'None' | 'T1' | 'T2', invoiceProfileId?: number, page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfCustomerTenant;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (programId !== undefined) {
            localVarQueryParameters['ProgramId'] = ObjectSerializer.serialize(programId, "number");
        }

        if (consumerId !== undefined) {
            localVarQueryParameters['ConsumerId'] = ObjectSerializer.serialize(consumerId, "number");
        }

        if (domain !== undefined) {
            localVarQueryParameters['Domain'] = ObjectSerializer.serialize(domain, "string");
        }

        if (domainPrefix !== undefined) {
            localVarQueryParameters['DomainPrefix'] = ObjectSerializer.serialize(domainPrefix, "string");
        }

        if (customerTenantType !== undefined) {
            localVarQueryParameters['CustomerTenantType'] = ObjectSerializer.serialize(customerTenantType, "'None' | 'T1' | 'T2'");
        }

        if (invoiceProfileId !== undefined) {
            localVarQueryParameters['InvoiceProfileId'] = ObjectSerializer.serialize(invoiceProfileId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfCustomerTenant;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfCustomerTenant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customerTenantId 
     * @param {*} [options] Override http request options.
     */
    public getAzurePlan (customerTenantId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: AzurePlan;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/{customerTenantId}/azurePlan'
            .replace('{' + 'customerTenantId' + '}', encodeURIComponent(String(customerTenantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerTenantId' is not null or undefined
        if (customerTenantId === null || customerTenantId === undefined) {
            throw new Error('Required parameter customerTenantId was null or undefined when calling getAzurePlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AzurePlan;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AzurePlan");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getCustomerTenantById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerTenant;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomerTenantById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerTenant;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerTenant");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getCustomerTenantDetailedById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/{id}/detailed'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomerTenantDetailedById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerTenantDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customerTenant 
     * @param {*} [options] Override http request options.
     */
    public post (customerTenant?: CustomerTenantDetailed, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customerTenant, "CustomerTenantDetailed")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerTenantDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param customerTenant 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, customerTenant?: CustomerTenantDetailed, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/CustomerTenants/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customerTenant, "CustomerTenantDetailed")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerTenantDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerTenantDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerTokenApiApiKeys {
    Bearer,
}

export class CustomerTokenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerTokenApiApiKeys, value: string) {
        (this.authentications as any)[CustomerTokenApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public post (options: any = {}) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/api/v1/connect/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FacebookOrdersApiApiKeys {
    Bearer,
}

export class FacebookOrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FacebookOrdersApiApiKeys, value: string) {
        (this.authentications as any)[FacebookOrdersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param order 
     * @param {*} [options] Override http request options.
     */
    public checkoutAsync (order?: FacebookOrder, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/FacebookOrders/checkout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "FacebookOrder")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoogleOrdersApiApiKeys {
    Bearer,
}

export class GoogleOrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GoogleOrdersApiApiKeys, value: string) {
        (this.authentications as any)[GoogleOrdersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param order 
     * @param {*} [options] Override http request options.
     */
    public checkoutAsync (order?: GoogleOrder, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/GoogleOrders/checkout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "GoogleOrder")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GroupingsApiApiKeys {
    Bearer,
}

export class GroupingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GroupingsApiApiKeys, value: string) {
        (this.authentications as any)[GroupingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public _delete (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/Groupings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param includeRemoved 
     * @param search 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, includeRemoved?: boolean, search?: string, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfGrouping;  }> {
        const localVarPath = this.basePath + '/api/v1/Groupings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (includeRemoved !== undefined) {
            localVarQueryParameters['IncludeRemoved'] = ObjectSerializer.serialize(includeRemoved, "boolean");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfGrouping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfGrouping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Grouping;  }> {
        const localVarPath = this.basePath + '/api/v1/Groupings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Grouping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Grouping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param grouping 
     * @param {*} [options] Override http request options.
     */
    public post (grouping?: Grouping, options: any = {}) : Promise<{ response: http.ClientResponse; body: Grouping;  }> {
        const localVarPath = this.basePath + '/api/v1/Groupings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(grouping, "Grouping")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Grouping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Grouping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param grouping 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, grouping?: Grouping, options: any = {}) : Promise<{ response: http.ClientResponse; body: Grouping;  }> {
        const localVarPath = this.basePath + '/api/v1/Groupings/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(grouping, "Grouping")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Grouping;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Grouping");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceProfilesApiApiKeys {
    Bearer,
}

export class InvoiceProfilesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoiceProfilesApiApiKeys, value: string) {
        (this.authentications as any)[InvoiceProfilesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public _delete (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/InvoiceProfiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfInvoiceProfile;  }> {
        const localVarPath = this.basePath + '/api/v1/InvoiceProfiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfInvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfInvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }> {
        const localVarPath = this.basePath + '/api/v1/InvoiceProfiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param invoiceProfile 
     * @param {*} [options] Override http request options.
     */
    public post (invoiceProfile?: InvoiceProfile, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }> {
        const localVarPath = this.basePath + '/api/v1/InvoiceProfiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(invoiceProfile, "InvoiceProfile")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param invoiceProfile 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, invoiceProfile?: InvoiceProfile, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }> {
        const localVarPath = this.basePath + '/api/v1/InvoiceProfiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(invoiceProfile, "InvoiceProfile")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoiceProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoiceProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ManagementLinksApiApiKeys {
    Bearer,
}

export class ManagementLinksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ManagementLinksApiApiKeys, value: string) {
        (this.authentications as any)[ManagementLinksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param subscriptionIds 
     * @param resellerCustomerIds 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfManagementLink;  }> {
        const localVarPath = this.basePath + '/api/v1/ManagementLinks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (subscriptionIds !== undefined) {
            localVarQueryParameters['SubscriptionIds'] = ObjectSerializer.serialize(subscriptionIds, "Array<number>");
        }

        if (resellerCustomerIds !== undefined) {
            localVarQueryParameters['ResellerCustomerIds'] = ObjectSerializer.serialize(resellerCustomerIds, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfManagementLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfManagementLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscriptionIds 
     * @param resellerCustomerIds 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getGrouped (subscriptionIds?: Array<number>, resellerCustomerIds?: Array<number>, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfManagementLinkGrouped;  }> {
        const localVarPath = this.basePath + '/api/v1/ManagementLinks/grouped';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (subscriptionIds !== undefined) {
            localVarQueryParameters['SubscriptionIds'] = ObjectSerializer.serialize(subscriptionIds, "Array<number>");
        }

        if (resellerCustomerIds !== undefined) {
            localVarQueryParameters['ResellerCustomerIds'] = ObjectSerializer.serialize(resellerCustomerIds, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfManagementLinkGrouped;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfManagementLinkGrouped");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MeApiApiKeys {
    Bearer,
}

export class MeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MeApiApiKeys, value: string) {
        (this.authentications as any)[MeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public get (options: any = {}) : Promise<{ response: http.ClientResponse; body: Me;  }> {
        const localVarPath = this.basePath + '/api/v1/Me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Me;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Me");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationAccessApiApiKeys {
    Bearer,
}

export class OrganizationAccessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationAccessApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationAccessApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param userId 
     * @param organizationId 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (userId?: string, organizationId?: number, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationAccess;  }> {
        const localVarPath = this.basePath + '/api/v1/OrganizationAccess/grant';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationAccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfOrganizationAccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param userId 
     * @param organizationId 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getOrganizationAccess (userId?: string, organizationId?: number, page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationAccess;  }> {
        const localVarPath = this.basePath + '/api/v1/OrganizationAccess';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationAccess;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfOrganizationAccess");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param list 
     * @param {*} [options] Override http request options.
     */
    public put (list?: Array<OrganizationAccess>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OrganizationAccess>;  }> {
        const localVarPath = this.basePath + '/api/v1/OrganizationAccess';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(list, "Array<OrganizationAccess>")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OrganizationAccess>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OrganizationAccess>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationsApiApiKeys {
    Bearer,
}

export class OrganizationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationsApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganization;  }> {
        const localVarPath = this.basePath + '/api/v1/Organizations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfOrganization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Organization;  }> {
        const localVarPath = this.basePath + '/api/v1/Organizations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getOrganizationSalesContact (organizationId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrganizationSalesContact;  }> {
        const localVarPath = this.basePath + '/api/v1/Organizations/{organizationId}/salescontact'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationSalesContact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrganizationSalesContact;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationSalesContact");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public hasAccessAsync (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Organizations/HasAccess/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling hasAccessAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PingApiApiKeys {
    Bearer,
}

export class PingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PingApiApiKeys, value: string) {
        (this.authentications as any)[PingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public get (options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/Ping';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductContainersApiApiKeys {
    Bearer,
}

export class ProductContainersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductContainersApiApiKeys, value: string) {
        (this.authentications as any)[ProductContainersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param year 
     * @param month 
     * @param programId 
     * @param organizationId 
     * @param copyLast 
     * @param {*} [options] Override http request options.
     */
    public createReportAsync (year?: number, month?: number, programId?: number, organizationId?: number, copyLast?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/reportbymonth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (year !== undefined) {
            localVarQueryParameters['year'] = ObjectSerializer.serialize(year, "number");
        }

        if (month !== undefined) {
            localVarQueryParameters['month'] = ObjectSerializer.serialize(month, "number");
        }

        if (programId !== undefined) {
            localVarQueryParameters['programId'] = ObjectSerializer.serialize(programId, "number");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (copyLast !== undefined) {
            localVarQueryParameters['copyLast'] = ObjectSerializer.serialize(copyLast, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteProductContainer (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductContainer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param search 
     * @param page 
     * @param pageSize 
     * @param activeDraft 
     * @param programId 
     * @param year 
     * @param month 
     * @param userId 
     * @param sentByUserId 
     * @param type 
     * @param category 
     * @param from 
     * @param to 
     * @param includeRemoved 
     * @param includeSubsidiaries 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, search?: string, page?: number, pageSize?: number, activeDraft?: boolean, programId?: number, year?: number, month?: number, userId?: string, sentByUserId?: string, type?: 'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template', category?: 'None' | 'Seat' | 'Report', from?: Date, to?: Date, includeRemoved?: boolean, includeSubsidiaries?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (activeDraft !== undefined) {
            localVarQueryParameters['ActiveDraft'] = ObjectSerializer.serialize(activeDraft, "boolean");
        }

        if (programId !== undefined) {
            localVarQueryParameters['ProgramId'] = ObjectSerializer.serialize(programId, "number");
        }

        if (year !== undefined) {
            localVarQueryParameters['Year'] = ObjectSerializer.serialize(year, "number");
        }

        if (month !== undefined) {
            localVarQueryParameters['Month'] = ObjectSerializer.serialize(month, "number");
        }

        if (userId !== undefined) {
            localVarQueryParameters['UserId'] = ObjectSerializer.serialize(userId, "string");
        }

        if (sentByUserId !== undefined) {
            localVarQueryParameters['SentByUserId'] = ObjectSerializer.serialize(sentByUserId, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['Type'] = ObjectSerializer.serialize(type, "'None' | 'Draft' | 'Request' | 'Order' | 'Quote' | 'Template'");
        }

        if (category !== undefined) {
            localVarQueryParameters['Category'] = ObjectSerializer.serialize(category, "'None' | 'Seat' | 'Report'");
        }

        if (from !== undefined) {
            localVarQueryParameters['From'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['To'] = ObjectSerializer.serialize(to, "Date");
        }

        if (includeRemoved !== undefined) {
            localVarQueryParameters['IncludeRemoved'] = ObjectSerializer.serialize(includeRemoved, "boolean");
        }

        if (includeSubsidiaries !== undefined) {
            localVarQueryParameters['IncludeSubsidiaries'] = ObjectSerializer.serialize(includeSubsidiaries, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getByIdWithRowIssues (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/rowissues/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getByIdWithRowIssues.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getOrCreateShoppingCart (organizationId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/getorcreateshoppingcart';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param productContainerId 
     * @param productRowId 
     * @param productRowPatch 
     * @param {*} [options] Override http request options.
     */
    public patchProductRow (productContainerId: number, productRowId: number, productRowPatch?: ProductRowPatch, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/{productContainerId}/row/{productRowId}'
            .replace('{' + 'productContainerId' + '}', encodeURIComponent(String(productContainerId)))
            .replace('{' + 'productRowId' + '}', encodeURIComponent(String(productRowId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'productContainerId' is not null or undefined
        if (productContainerId === null || productContainerId === undefined) {
            throw new Error('Required parameter productContainerId was null or undefined when calling patchProductRow.');
        }

        // verify required parameter 'productRowId' is not null or undefined
        if (productRowId === null || productRowId === undefined) {
            throw new Error('Required parameter productRowId was null or undefined when calling patchProductRow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(productRowPatch, "ProductRowPatch")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param productContainer 
     * @param requireEulaAnalysis 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, productContainer?: ProductContainer, requireEulaAnalysis?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ProductContainer;  }> {
        const localVarPath = this.basePath + '/api/v1/ProductContainers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        if (requireEulaAnalysis !== undefined) {
            localVarQueryParameters['requireEulaAnalysis'] = ObjectSerializer.serialize(requireEulaAnalysis, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(productContainer, "ProductContainer")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProductContainer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProductContainer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProgramsApiApiKeys {
    Bearer,
}

export class ProgramsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProgramsApiApiKeys, value: string) {
        (this.authentications as any)[ProgramsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param publisherId 
     * @param programType 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public get (publisherId?: number, programType?: 'None' | 'License' | 'Report' | 'Cloud', page?: number, pageSize?: number, search?: string, organizationId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfProgram;  }> {
        const localVarPath = this.basePath + '/api/v1/Programs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (programType !== undefined) {
            localVarQueryParameters['ProgramType'] = ObjectSerializer.serialize(programType, "'None' | 'License' | 'Report' | 'Cloud'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfProgram;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfProgram");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Program;  }> {
        const localVarPath = this.basePath + '/api/v1/Programs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Program;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Program");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PublishersApiApiKeys {
    Bearer,
}

export class PublishersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PublishersApiApiKeys, value: string) {
        (this.authentications as any)[PublishersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param names 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param programType 
     * @param {*} [options] Override http request options.
     */
    public get (names?: Array<string>, page?: number, pageSize?: number, search?: string, programType?: 'None' | 'License' | 'Report' | 'Cloud', options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfPublisher;  }> {
        const localVarPath = this.basePath + '/api/v1/Publishers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (names !== undefined) {
            localVarQueryParameters['Names'] = ObjectSerializer.serialize(names, "Array<string>");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (programType !== undefined) {
            localVarQueryParameters['ProgramType'] = ObjectSerializer.serialize(programType, "'None' | 'License' | 'Report' | 'Cloud'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfPublisher;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfPublisher");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getById (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Publisher;  }> {
        const localVarPath = this.basePath + '/api/v1/Publishers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Publisher;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Publisher");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RegionsApiApiKeys {
    Bearer,
}

export class RegionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RegionsApiApiKeys, value: string) {
        (this.authentications as any)[RegionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param regionList 
     * @param organizationId 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param {*} [options] Override http request options.
     */
    public get (regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', organizationId?: number, page?: number, pageSize?: number, search?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfRegion;  }> {
        const localVarPath = this.basePath + '/api/v1/Regions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (regionList !== undefined) {
            localVarQueryParameters['RegionList'] = ObjectSerializer.serialize(regionList, "'None' | 'MicrosoftCsp' | 'OrganizationSpecific'");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfRegion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfRegion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param regionCode 
     * @param regionList 
     * @param {*} [options] Override http request options.
     */
    public getByRegionCode (regionCode?: string, regionList?: 'None' | 'MicrosoftCsp' | 'OrganizationSpecific', options: any = {}) : Promise<{ response: http.ClientResponse; body: Region;  }> {
        const localVarPath = this.basePath + '/api/v1/Regions/bycode';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (regionCode !== undefined) {
            localVarQueryParameters['regionCode'] = ObjectSerializer.serialize(regionCode, "string");
        }

        if (regionList !== undefined) {
            localVarQueryParameters['regionList'] = ObjectSerializer.serialize(regionList, "'None' | 'MicrosoftCsp' | 'OrganizationSpecific'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Region;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Region");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ResellerSalesPricesApiApiKeys {
    Bearer,
}

export class ResellerSalesPricesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ResellerSalesPricesApiApiKeys, value: string) {
        (this.authentications as any)[ResellerSalesPricesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param type 
     * @param objectId 
     * @param objectType 
     * @param fromDate 
     * @param {*} [options] Override http request options.
     */
    public deleteByFilterAsync (type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['Type'] = ObjectSerializer.serialize(type, "'License' | 'Usage' | 'OneTime'");
        }

        if (objectId !== undefined) {
            localVarQueryParameters['ObjectId'] = ObjectSerializer.serialize(objectId, "number");
        }

        if (objectType !== undefined) {
            localVarQueryParameters['ObjectType'] = ObjectSerializer.serialize(objectType, "'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['FromDate'] = ObjectSerializer.serialize(fromDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param type 
     * @param objectId 
     * @param objectType 
     * @param fromDate 
     * @param {*} [options] Override http request options.
     */
    public getAsync (type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ResellerSalesPrice>;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['Type'] = ObjectSerializer.serialize(type, "'License' | 'Usage' | 'OneTime'");
        }

        if (objectId !== undefined) {
            localVarQueryParameters['ObjectId'] = ObjectSerializer.serialize(objectId, "number");
        }

        if (objectType !== undefined) {
            localVarQueryParameters['ObjectType'] = ObjectSerializer.serialize(objectType, "'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['FromDate'] = ObjectSerializer.serialize(fromDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ResellerSalesPrice>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResellerSalesPrice>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param type 
     * @param objectId 
     * @param objectType 
     * @param fromDate 
     * @param {*} [options] Override http request options.
     */
    public getCurrentAsync (type?: 'License' | 'Usage' | 'OneTime', objectId?: number, objectType?: 'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon', fromDate?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices/current';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['Type'] = ObjectSerializer.serialize(type, "'License' | 'Usage' | 'OneTime'");
        }

        if (objectId !== undefined) {
            localVarQueryParameters['ObjectId'] = ObjectSerializer.serialize(objectId, "number");
        }

        if (objectType !== undefined) {
            localVarQueryParameters['ObjectType'] = ObjectSerializer.serialize(objectType, "'Organization' | 'CustomerTenant' | 'Subscription' | 'SubscriptionAddon'");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['FromDate'] = ObjectSerializer.serialize(fromDate, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResellerSalesPrice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerSalesPrice 
     * @param {*} [options] Override http request options.
     */
    public postAsync (resellerSalesPrice?: ResellerSalesPrice, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerSalesPrice, "ResellerSalesPrice")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResellerSalesPrice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param oldFromDate 
     * @param resellerSalesPrice 
     * @param {*} [options] Override http request options.
     */
    public putAsync (oldFromDate: Date, resellerSalesPrice?: ResellerSalesPrice, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices/{oldFromDate}'
            .replace('{' + 'oldFromDate' + '}', encodeURIComponent(String(oldFromDate)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'oldFromDate' is not null or undefined
        if (oldFromDate === null || oldFromDate === undefined) {
            throw new Error('Required parameter oldFromDate was null or undefined when calling putAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerSalesPrice, "ResellerSalesPrice")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResellerSalesPrice;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResellerSalesPrice");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerSalesPriceToggle 
     * @param {*} [options] Override http request options.
     */
    public toggleAsync (resellerSalesPriceToggle?: ResellerSalesPriceToggle, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/ResellerSalesPrices/toggle';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(resellerSalesPriceToggle, "ResellerSalesPriceToggle")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecretsApiApiKeys {
    Bearer,
}

export class SecretsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SecretsApiApiKeys, value: string) {
        (this.authentications as any)[SecretsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param clientId 
     * @param secretId 
     * @param {*} [options] Override http request options.
     */
    public _delete (clientId?: string, secretId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (secretId !== undefined) {
            localVarQueryParameters['secretId'] = ObjectSerializer.serialize(secretId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param secret 
     * @param {*} [options] Override http request options.
     */
    public post (secret?: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/api/v1/Secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secret, "Secret")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsApiApiKeys {
    Bearer,
}

export class SubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param subscriptionId 
     * @param {*} [options] Override http request options.
     */
    public deleteSubscriptionTags (subscriptionId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{subscriptionId}/tags'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling deleteSubscriptionTags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param customerTenantId 
     * @param publisherId 
     * @param refresh 
     * @param statuses 
     * @param isTrial 
     * @param page 
     * @param pageSize 
     * @param search 
     * @param registeredForReservedInstance 
     * @param {*} [options] Override http request options.
     */
    public get (organizationId?: number, customerTenantId?: number, publisherId?: number, refresh?: boolean, statuses?: 'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All', isTrial?: boolean, page?: number, pageSize?: number, search?: string, registeredForReservedInstance?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscription;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (customerTenantId !== undefined) {
            localVarQueryParameters['CustomerTenantId'] = ObjectSerializer.serialize(customerTenantId, "number");
        }

        if (publisherId !== undefined) {
            localVarQueryParameters['PublisherId'] = ObjectSerializer.serialize(publisherId, "number");
        }

        if (refresh !== undefined) {
            localVarQueryParameters['Refresh'] = ObjectSerializer.serialize(refresh, "boolean");
        }

        if (statuses !== undefined) {
            localVarQueryParameters['Statuses'] = ObjectSerializer.serialize(statuses, "'None' | 'Active' | 'Suspended' | 'Deleted' | 'CustomerCancellation' | 'Converted' | 'Inactive' | 'All'");
        }

        if (isTrial !== undefined) {
            localVarQueryParameters['IsTrial'] = ObjectSerializer.serialize(isTrial, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (registeredForReservedInstance !== undefined) {
            localVarQueryParameters['RegisteredForReservedInstance'] = ObjectSerializer.serialize(registeredForReservedInstance, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getActivationLinkAsync (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ActivationLink;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{id}/activationlink'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivationLinkAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivationLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivationLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param reservedInstance 
     * @param {*} [options] Override http request options.
     */
    public getRegisterReservedInstance (id: number, reservedInstance: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfBoolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{reservedInstance}/subscriptionId/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'reservedInstance' + '}', encodeURIComponent(String(reservedInstance)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRegisterReservedInstance.');
        }

        // verify required parameter 'reservedInstance' is not null or undefined
        if (reservedInstance === null || reservedInstance === undefined) {
            throw new Error('Required parameter reservedInstance was null or undefined when calling getRegisterReservedInstance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfBoolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfBoolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscriptionId 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionConversions (subscriptionId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionConversion;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{subscriptionId}/conversions'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getSubscriptionConversions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionConversion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscriptionConversion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionPriceTypes (options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfObjectReference;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/subscriptionpricetypes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfObjectReference;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfObjectReference");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscriptionId 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionTags (subscriptionId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubscriptionTags;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{subscriptionId}/tags'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getSubscriptionTags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionTags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionTags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscription 
     * @param {*} [options] Override http request options.
     */
    public post (subscription?: SubscriptionDetailed, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscription, "SubscriptionDetailed")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscriptionId 
     * @param conversion 
     * @param {*} [options] Override http request options.
     */
    public postSubscriptionConversion (subscriptionId: number, conversion?: SubscriptionConversion, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{subscriptionId}/conversions'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling postSubscriptionConversion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(conversion, "SubscriptionConversion")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param subscription 
     * @param {*} [options] Override http request options.
     */
    public put (id: number, subscription?: SubscriptionDetailed, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling put.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(subscription, "SubscriptionDetailed")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param reservedInstance 
     * @param {*} [options] Override http request options.
     */
    public registerReservedInstance (id: number, reservedInstance: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{reservedInstance}/subscriptionId/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'reservedInstance' + '}', encodeURIComponent(String(reservedInstance)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling registerReservedInstance.');
        }

        // verify required parameter 'reservedInstance' is not null or undefined
        if (reservedInstance === null || reservedInstance === undefined) {
            throw new Error('Required parameter reservedInstance was null or undefined when calling registerReservedInstance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param subscriptionId 
     * @param tags 
     * @param {*} [options] Override http request options.
     */
    public setSubscriptionTags (subscriptionId: string, tags?: SubscriptionTags, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{subscriptionId}/tags'
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling setSubscriptionTags.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tags, "SubscriptionTags")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public subscription (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }> {
        const localVarPath = this.basePath + '/api/v1/Subscriptions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling subscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SubscriptionDetailed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SubscriptionDetailed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsageCostApiApiKeys {
    Bearer,
}

export class UsageCostApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsageCostApiApiKeys, value: string) {
        (this.authentications as any)[UsageCostApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param subscriptionId 
     * @param category 
     * @param currencyCode 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForCategory (resellerCustomerId: number, subscriptionId: string, category: string, currencyCode: string, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfCategoryUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/category/{category}/currency/{currencyCode}'
            .replace('{' + 'resellerCustomerId' + '}', encodeURIComponent(String(resellerCustomerId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)))
            .replace('{' + 'currencyCode' + '}', encodeURIComponent(String(currencyCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resellerCustomerId' is not null or undefined
        if (resellerCustomerId === null || resellerCustomerId === undefined) {
            throw new Error('Required parameter resellerCustomerId was null or undefined when calling getForCategory.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getForCategory.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getForCategory.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getForCategory.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfCategoryUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfCategoryUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public getForCategory_1 (model?: CategoryUsageCostRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfCategoryUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/getForCategory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CategoryUsageCostRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfCategoryUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfCategoryUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForOrganization (organizationId: number, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/organization/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getForOrganization.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfOrganizationUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfOrganizationUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param subscriptionId 
     * @param resourceGroup 
     * @param currencyCode 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForResourceGroup (resellerCustomerId: number, subscriptionId: string, resourceGroup: string, currencyCode: string, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfResourceGroupUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/resourceGroup/{resourceGroup}/currency/{currencyCode}'
            .replace('{' + 'resellerCustomerId' + '}', encodeURIComponent(String(resellerCustomerId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)))
            .replace('{' + 'resourceGroup' + '}', encodeURIComponent(String(resourceGroup)))
            .replace('{' + 'currencyCode' + '}', encodeURIComponent(String(currencyCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resellerCustomerId' is not null or undefined
        if (resellerCustomerId === null || resellerCustomerId === undefined) {
            throw new Error('Required parameter resellerCustomerId was null or undefined when calling getForResourceGroup.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getForResourceGroup.');
        }

        // verify required parameter 'resourceGroup' is not null or undefined
        if (resourceGroup === null || resourceGroup === undefined) {
            throw new Error('Required parameter resourceGroup was null or undefined when calling getForResourceGroup.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getForResourceGroup.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfResourceGroupUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfResourceGroupUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public getForResourceGroup_2 (model?: ResourceGroupUsageCostRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfResourceGroupUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/getForResourceGroup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ResourceGroupUsageCostRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfResourceGroupUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfResourceGroupUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param subscriptionId 
     * @param category 
     * @param subcategory 
     * @param currencyCode 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForSubcategory (resellerCustomerId: number, subscriptionId: string, category: string, subcategory: string, currencyCode: string, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubcategoryUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/category/{category}/subcategory/{subcategory}/currency/{currencyCode}'
            .replace('{' + 'resellerCustomerId' + '}', encodeURIComponent(String(resellerCustomerId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)))
            .replace('{' + 'category' + '}', encodeURIComponent(String(category)))
            .replace('{' + 'subcategory' + '}', encodeURIComponent(String(subcategory)))
            .replace('{' + 'currencyCode' + '}', encodeURIComponent(String(currencyCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resellerCustomerId' is not null or undefined
        if (resellerCustomerId === null || resellerCustomerId === undefined) {
            throw new Error('Required parameter resellerCustomerId was null or undefined when calling getForSubcategory.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getForSubcategory.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling getForSubcategory.');
        }

        // verify required parameter 'subcategory' is not null or undefined
        if (subcategory === null || subcategory === undefined) {
            throw new Error('Required parameter subcategory was null or undefined when calling getForSubcategory.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getForSubcategory.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubcategoryUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubcategoryUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public getForSubcategory_3 (model?: SubcategoryUsageCostRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubcategoryUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/getForSubcategory';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "SubcategoryUsageCostRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubcategoryUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubcategoryUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param subscriptionId 
     * @param currencyCode 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForSubscription (resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/currency/{currencyCode}'
            .replace('{' + 'resellerCustomerId' + '}', encodeURIComponent(String(resellerCustomerId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)))
            .replace('{' + 'currencyCode' + '}', encodeURIComponent(String(currencyCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resellerCustomerId' is not null or undefined
        if (resellerCustomerId === null || resellerCustomerId === undefined) {
            throw new Error('Required parameter resellerCustomerId was null or undefined when calling getForSubscription.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getForSubscription.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getForSubscription.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscriptionUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param resellerCustomerId 
     * @param subscriptionId 
     * @param currencyCode 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getForSubscriptionWithResourceGroups (resellerCustomerId: number, subscriptionId: string, currencyCode: string, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionResourceGroupUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/resellerCustomer/{resellerCustomerId}/subscription/{subscriptionId}/currency/{currencyCode}/resourceGroups'
            .replace('{' + 'resellerCustomerId' + '}', encodeURIComponent(String(resellerCustomerId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)))
            .replace('{' + 'currencyCode' + '}', encodeURIComponent(String(currencyCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'resellerCustomerId' is not null or undefined
        if (resellerCustomerId === null || resellerCustomerId === undefined) {
            throw new Error('Required parameter resellerCustomerId was null or undefined when calling getForSubscriptionWithResourceGroups.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling getForSubscriptionWithResourceGroups.');
        }

        // verify required parameter 'currencyCode' is not null or undefined
        if (currencyCode === null || currencyCode === undefined) {
            throw new Error('Required parameter currencyCode was null or undefined when calling getForSubscriptionWithResourceGroups.');
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionResourceGroupUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscriptionResourceGroupUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public getForSubscriptionWithResourceGroups_4 (model?: SubscriptionUsageCostRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionResourceGroupUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/getForSubscription/resourceGroups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "SubscriptionUsageCostRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionResourceGroupUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscriptionResourceGroupUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public getForSubscription_5 (model?: SubscriptionUsageCostRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionUsageCost;  }> {
        const localVarPath = this.basePath + '/api/v1/UsageCost/getForSubscription';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "SubscriptionUsageCostRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfSubscriptionUsageCost;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfSubscriptionUsageCost");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    Bearer,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param user 
     * @param {*} [options] Override http request options.
     */
    public addUser (user?: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/api/v1/Users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param changePassword 
     * @param {*} [options] Override http request options.
     */
    public changePassword (id: string, changePassword?: UserChangePassword, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Users/{id}/changepassword'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling changePassword.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(changePassword, "UserChangePassword")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public deleteUser (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/v1/Users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param search 
     * @param organizationId 
     * @param role 
     * @param page 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public get (search?: string, organizationId?: number, role?: 'None' | 'User' | 'TenantAdmin', page?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApiCollectionOfUser;  }> {
        const localVarPath = this.basePath + '/api/v1/Users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['OrganizationId'] = ObjectSerializer.serialize(organizationId, "number");
        }

        if (role !== undefined) {
            localVarQueryParameters['Role'] = ObjectSerializer.serialize(role, "'None' | 'User' | 'TenantAdmin'");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCollectionOfUser;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCollectionOfUser");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public getUserById (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/api/v1/Users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param userName 
     * @param {*} [options] Override http request options.
     */
    public getUserByUserName (userName?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/api/v1/Users/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param id 
     * @param user 
     * @param {*} [options] Override http request options.
     */
    public updateUser (id: string, user?: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/api/v1/Users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
